<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RNG Trader - Spin & Trade Empire</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0a0e27;
            --bg-medium: #1a1f3a;
            --bg-light: #2a3154;
            --accent-primary: #00ffcc;
            --accent-secondary: #ff00aa;
            --accent-gold: #ffd700;
            --text-primary: #ffffff;
            --text-secondary: #a0a8c0;
            --success: #00ff88;
            --danger: #ff3366;
            --warning: #ffaa00;
            
            --rarity-common: #b0b0b0;
            --rarity-uncommon: #5eff5e;
            --rarity-rare: #5e9eff;
            --rarity-epic: #b45eff;
            --rarity-legendary: #ffaa00;
            --rarity-mythic: #ff3366;
            --rarity-exotic: #00ffcc;
            --rarity-celestial: #ffe4f5;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Space Mono', monospace;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #1a1535 100%);
            color: var(--text-primary);
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        /* Animated background stars */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, white, transparent),
                radial-gradient(2px 2px at 60% 70%, white, transparent),
                radial-gradient(1px 1px at 50% 50%, white, transparent),
                radial-gradient(1px 1px at 80% 10%, white, transparent),
                radial-gradient(2px 2px at 90% 60%, white, transparent),
                radial-gradient(1px 1px at 33% 80%, white, transparent);
            background-size: 200% 200%;
            animation: stars 120s linear infinite;
            opacity: 0.3;
            pointer-events: none;
            z-index: 0;
        }
        
        @keyframes stars {
            from { background-position: 0 0; }
            to { background-position: 200% 200%; }
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        header {
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            padding: 30px 0;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 2rem;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { filter: drop-shadow(0 0 5px var(--accent-primary)); }
            to { filter: drop-shadow(0 0 20px var(--accent-secondary)); }
        }
        
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: linear-gradient(135deg, var(--bg-medium), var(--bg-light));
            border: 2px solid var(--accent-primary);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 255, 204, 0.2);
            transition: all 0.3s;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 255, 204, 0.4);
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-primary);
            margin-top: 5px;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .tab-button {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            padding: 15px 25px;
            background: var(--bg-medium);
            border: 2px solid var(--accent-primary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }
        
        .tab-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 204, 0.3), transparent);
            transition: left 0.5s;
        }
        
        .tab-button:hover::before {
            left: 100%;
        }
        
        .tab-button:hover {
            background: var(--bg-light);
            transform: translateY(-2px);
        }
        
        .tab-button.active {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-dark);
            border-color: var(--accent-gold);
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.6);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .spin-section {
            background: var(--bg-medium);
            border: 3px solid var(--accent-primary);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 10px 50px rgba(0, 255, 204, 0.3);
            margin-bottom: 30px;
        }
        
        .spin-button {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.2rem;
            padding: 25px 50px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border: none;
            color: var(--bg-dark);
            cursor: pointer;
            border-radius: 15px;
            transition: all 0.3s;
            box-shadow: 0 8px 25px rgba(255, 0, 170, 0.4);
            position: relative;
            overflow: hidden;
        }
        
        .spin-button:hover {
            transform: scale(1.1) rotate(-2deg);
            box-shadow: 0 12px 35px rgba(255, 0, 170, 0.6);
        }
        
        .spin-button:active {
            transform: scale(0.95);
        }
        
        .spin-button.spinning {
            animation: spin-pulse 0.5s ease-in-out infinite;
            pointer-events: none;
        }
        
        @keyframes spin-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .result-display {
            margin-top: 30px;
            padding: 30px;
            background: var(--bg-light);
            border-radius: 15px;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px dashed var(--accent-primary);
        }
        
        .item-display {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 10px 0;
            padding: 15px 30px;
            border-radius: 10px;
            animation: itemAppear 0.5s ease-out;
        }
        
        @keyframes itemAppear {
            from { transform: scale(0) rotate(-180deg); opacity: 0; }
            to { transform: scale(1) rotate(0); opacity: 1; }
        }
        
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .inventory-item {
            background: var(--bg-light);
            border: 2px solid;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        
        .inventory-item:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 255, 204, 0.4);
        }
        
        .inventory-item.flexed {
            border-width: 4px;
            animation: flex-glow 1s ease-in-out infinite;
        }
        
        @keyframes flex-glow {
            0%, 100% { box-shadow: 0 0 10px currentColor; }
            50% { box-shadow: 0 0 25px currentColor; }
        }
        
        .item-name {
            font-weight: bold;
            margin: 10px 0 5px;
        }
        
        .item-value {
            color: var(--accent-gold);
            font-size: 0.9rem;
        }
        
        .item-count {
            position: absolute;
            top: 5px;
            right: 5px;
            background: var(--accent-secondary);
            color: white;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .npc-container {
            background: var(--bg-medium);
            border: 2px solid var(--accent-secondary);
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
        }
        
        .npc-card {
            background: var(--bg-light);
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            animation: slideIn 0.5s ease-out;
        }
        
        @keyframes slideIn {
            from { transform: translateX(-50px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .npc-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .npc-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: var(--accent-primary);
        }
        
        .npc-type {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.7rem;
            text-transform: uppercase;
        }
        
        .npc-type.honest { background: var(--success); color: var(--bg-dark); }
        .npc-type.scammer { background: var(--danger); color: white; }
        .npc-type.fair { background: var(--warning); color: var(--bg-dark); }
        
        .trade-offer {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
            padding: 15px;
            background: var(--bg-medium);
            border-radius: 10px;
        }
        
        .trade-buttons {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            padding: 12px 25px;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        
        .btn-accept {
            background: var(--success);
            border-color: var(--success);
            color: var(--bg-dark);
        }
        
        .btn-accept:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.5);
        }
        
        .btn-decline {
            background: var(--danger);
            border-color: var(--danger);
            color: white;
        }
        
        .btn-decline:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(255, 51, 102, 0.5);
        }
        
        .crafting-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .recipe-card {
            background: var(--bg-light);
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s;
        }
        
        .recipe-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 255, 204, 0.3);
        }
        
        .recipe-requirements {
            margin: 15px 0;
            padding: 15px;
            background: var(--bg-medium);
            border-radius: 8px;
        }
        
        .achievement-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .achievement-card {
            background: var(--bg-light);
            border: 2px solid var(--text-secondary);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s;
            opacity: 0.6;
        }
        
        .achievement-card.unlocked {
            border-color: var(--accent-gold);
            opacity: 1;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }
        
        .achievement-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .battlepass-tier {
            background: var(--bg-light);
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .battlepass-tier.unlocked {
            background: linear-gradient(135deg, var(--bg-light), var(--bg-medium));
            border-color: var(--accent-gold);
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: var(--bg-light);
            border: 2px solid var(--accent-primary);
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transition: width 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .event-banner {
            background: linear-gradient(135deg, #ff0000, #00ff00);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin: 20px 0;
            font-family: 'Press Start 2P', cursive;
            animation: rainbow 3s linear infinite;
        }
        
        @keyframes rainbow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-medium);
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 255, 204, 0.5);
            animation: slideInRight 0.5s ease-out;
            z-index: 1000;
            max-width: 350px;
        }
        
        @keyframes slideInRight {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .enchant-slots {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .enchant-slot {
            padding: 15px 25px;
            background: var(--bg-light);
            border: 2px dashed var(--accent-primary);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .enchant-slot:hover {
            background: var(--bg-medium);
            border-style: solid;
        }
        
        .enchant-slot.filled {
            border-color: var(--accent-gold);
            border-style: solid;
            background: var(--accent-primary);
            color: var(--bg-dark);
        }
        
        @media (max-width: 768px) {
            header {
                font-size: 1.2rem;
            }
            
            .tab-button {
                font-size: 0.6rem;
                padding: 12px 18px;
            }
            
            .spin-button {
                font-size: 0.9rem;
                padding: 18px 35px;
            }
        }
        
        /* Epic Animations for Ultra-Rare Pulls */
        .ultra-rare-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9999;
        }
        
        /* Cosmic (1/1024) - Purple sparkles */
        @keyframes cosmic-sparkle {
            0% { opacity: 0; transform: scale(0) rotate(0deg); }
            50% { opacity: 1; }
            100% { opacity: 0; transform: scale(2) rotate(360deg); }
        }
        
        /* Infinite (1/2048) - Rainbow waves */
        @keyframes infinite-wave {
            0% { transform: translateX(-100%) scale(1); opacity: 0; }
            50% { opacity: 0.8; }
            100% { transform: translateX(100%) scale(1.5); opacity: 0; }
        }
        
        /* Transcendent (1/4096) - Cyan lightning */
        @keyframes transcendent-lightning {
            0%, 100% { opacity: 0; }
            10%, 30%, 50% { opacity: 1; }
            20%, 40%, 60% { opacity: 0.3; }
        }
        
        /* Ethereal (1/8192) - Ghost wisps */
        @keyframes ethereal-wisp {
            0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            20% { opacity: 0.8; }
            80% { opacity: 0.8; }
            100% { transform: translateY(-100vh) rotate(720deg); opacity: 0; }
        }
        
        /* Primordial (1/16384) - Fire explosion */
        @keyframes primordial-explosion {
            0% { transform: scale(0); opacity: 1; }
            50% { transform: scale(3); opacity: 0.8; }
            100% { transform: scale(6); opacity: 0; }
        }
        
        /* Omega (1/32768) - Black hole vortex */
        @keyframes omega-vortex {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(2) rotate(1800deg); opacity: 1; }
            100% { transform: scale(0) rotate(3600deg); opacity: 0; }
        }
        
        /* Supreme (1/65536) - Golden rays */
        @keyframes supreme-rays {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: scale(4) rotate(180deg); opacity: 0; }
        }
        
        /* Godlike (1/131072) - Divine pillars */
        @keyframes godlike-pillar {
            0% { transform: translateY(100vh) scaleY(0); opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { transform: translateY(-100vh) scaleY(2); opacity: 0; }
        }
        
        /* Universal (1/262144) - Galaxy spiral */
        @keyframes universal-spiral {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(5) rotate(1080deg); opacity: 1; }
            100% { transform: scale(10) rotate(2160deg); opacity: 0; }
        }
        
        /* Multiversal (1/524288) - Reality fracture */
        @keyframes multiversal-fracture {
            0%, 100% { opacity: 0; }
            10%, 30%, 50%, 70%, 90% { opacity: 1; }
            20%, 40%, 60%, 80% { opacity: 0; }
        }
        
        /* Omnipotent (1/1048576) - World shake */
        @keyframes omnipotent-shake {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-10px, -10px); }
            20% { transform: translate(10px, 10px); }
            30% { transform: translate(-10px, 10px); }
            40% { transform: translate(10px, -10px); }
            50% { transform: translate(-10px, -10px); }
            60% { transform: translate(10px, 10px); }
            70% { transform: translate(-10px, 10px); }
            80% { transform: translate(10px, -10px); }
            90% { transform: translate(-5px, 5px); }
        }
        
        /* Infinite Absolute (1/2097152) - Dual infinity spirals */
        @keyframes infinite-absolute-spiral {
            0% { transform: scale(1) rotate(0deg); opacity: 0.8; }
            50% { transform: scale(3) rotate(1800deg); opacity: 1; }
            100% { transform: scale(1) rotate(3600deg); opacity: 0.8; }
        }
        
        /* Eternal (1/4194304) - Time ripples */
        @keyframes eternal-ripple {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(2); opacity: 0.8; }
            100% { transform: scale(4); opacity: 0; }
        }
        
        /* Immortal (1/8388608) - Phoenix rebirth */
        @keyframes immortal-rebirth {
            0% { transform: scale(0) rotate(0deg); filter: hue-rotate(0deg); }
            50% { transform: scale(2) rotate(180deg); filter: hue-rotate(180deg); }
            100% { transform: scale(0) rotate(360deg); filter: hue-rotate(360deg); }
        }
        
        /* Ascended (1/16777216) - Heavenly ascension */
        @keyframes ascended-rise {
            0% { transform: translateY(100vh) scale(0.5); opacity: 0; }
            50% { transform: translateY(0) scale(2); opacity: 1; }
            100% { transform: translateY(-100vh) scale(0.5); opacity: 0; }
        }
        
        /* Transcendental (1/33554432) - Reality layers */
        @keyframes transcendental-layers {
            0% { transform: translateZ(0) scale(1); opacity: 0.5; }
            50% { transform: translateZ(100px) scale(3); opacity: 1; }
            100% { transform: translateZ(0) scale(1); opacity: 0.5; }
        }
        
        /* Boundless (1/67108864) - Expanding boundaries */
        @keyframes boundless-expand {
            0% { transform: scale(0.1); border-radius: 50%; }
            50% { transform: scale(5); border-radius: 0%; }
            100% { transform: scale(0.1); border-radius: 50%; }
        }
        
        /* Limitless (1/134217728) - Breaking limits */
        @keyframes limitless-break {
            0% { transform: scale(1); filter: brightness(1); }
            25% { transform: scale(0.1); filter: brightness(5); }
            50% { transform: scale(10); filter: brightness(10); }
            75% { transform: scale(0.1); filter: brightness(5); }
            100% { transform: scale(1); filter: brightness(1); }
        }
        
        /* Absolute (1/268435456) - Universe explosion */
        @keyframes absolute-big-bang {
            0% { transform: scale(0); opacity: 1; filter: brightness(10); }
            50% { transform: scale(20); opacity: 1; filter: brightness(5); }
            100% { transform: scale(50); opacity: 0; filter: brightness(1); }
        }
        
        /* Beyond (1/536870912) - Dimension tear */
        @keyframes beyond-tear {
            0%, 100% { clip-path: inset(0 0 0 0); }
            25% { clip-path: inset(25% 0 25% 0); }
            50% { clip-path: inset(0 25% 0 25%); }
            75% { clip-path: inset(25% 25% 25% 25%); }
        }
        
        /* Incomprehensible (1/1073741824) - Reality distortion */
        @keyframes incomprehensible-distort {
            0% { filter: blur(0px) hue-rotate(0deg); transform: scale(1); }
            25% { filter: blur(20px) hue-rotate(90deg); transform: scale(1.5); }
            50% { filter: blur(40px) hue-rotate(180deg); transform: scale(0.5); }
            75% { filter: blur(20px) hue-rotate(270deg); transform: scale(1.5); }
            100% { filter: blur(0px) hue-rotate(360deg); transform: scale(1); }
        }
        
        /* Unimaginable (1/2147483648) - Kaleidoscope */
        @keyframes unimaginable-kaleidoscope {
            0% { transform: rotate(0deg) scale(1); filter: saturate(1); }
            50% { transform: rotate(1800deg) scale(10); filter: saturate(10); }
            100% { transform: rotate(3600deg) scale(1); filter: saturate(1); }
        }
        
        /* Impossible (1/4294967296) - THE ULTIMATE */
        @keyframes impossible-ultimate {
            0% { transform: scale(1) rotate(0deg); opacity: 1; filter: brightness(1) contrast(1); }
            10% { transform: scale(0); opacity: 0; }
            20% { transform: scale(100) rotate(3600deg); opacity: 1; filter: brightness(100) contrast(10); }
            40% { transform: scale(0.1); opacity: 0.5; }
            60% { transform: scale(50); opacity: 1; }
            80% { transform: scale(0.01); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 0; filter: brightness(1) contrast(1); }
        }
        
        /* Paradox (1/8589934592) - Reality breaks */
        @keyframes paradox-break {
            0% { transform: scale(1); filter: invert(0); }
            20% { transform: scale(3) scaleX(-1); filter: invert(1); }
            40% { transform: scale(0.5) scaleY(-1); filter: invert(0); }
            60% { transform: scale(5) scaleX(-1) scaleY(-1); filter: invert(1); }
            80% { transform: scale(0.1); filter: invert(0); }
            100% { transform: scale(1); filter: invert(0); }
        }
        
        /* Singularity (1/17179869184) - Black hole collapse */
        @keyframes singularity-collapse {
            0% { transform: scale(10); opacity: 1; }
            50% { transform: scale(0.001) rotate(7200deg); opacity: 1; filter: brightness(100); }
            51% { transform: scale(100); opacity: 1; filter: brightness(0.1); }
            100% { transform: scale(0); opacity: 0; }
        }
        
        /* Void (1/34359738368) - Consume everything */
        @keyframes void-consume {
            0% { background: transparent; }
            50% { background: rgba(0,0,0,1); }
            100% { background: transparent; }
        }
        
        /* Nothingness (1/68719476736) - Erase reality */
        @keyframes nothingness-erase {
            0% { opacity: 1; filter: blur(0px); }
            50% { opacity: 0; filter: blur(100px); }
            100% { opacity: 1; filter: blur(0px); }
        }
        
        /* Everything (1/137438953472) - Create universe */
        @keyframes everything-create {
            0% { transform: scale(0); filter: brightness(0); }
            50% { transform: scale(1000); filter: brightness(100); }
            100% { transform: scale(0); filter: brightness(0); }
        }
        
        /* The End (1/274877906944) - Time stops */
        @keyframes end-timestop {
            0%, 30%, 60%, 90% { filter: grayscale(0); }
            15%, 45%, 75% { filter: grayscale(1); }
        }
        
        /* The Beginning (1/549755813888) - Big Bang */
        @keyframes beginning-bigbang {
            0% { transform: scale(0.001); filter: brightness(1000); }
            50% { transform: scale(500); filter: brightness(100); }
            100% { transform: scale(0); filter: brightness(0); }
        }
        
        /* Alpha Omega (1/1099511627776) - Start and End merge */
        @keyframes alphaomega-merge {
            0% { clip-path: circle(0% at 0% 0%); }
            25% { clip-path: circle(100% at 0% 0%); }
            50% { clip-path: circle(0% at 100% 100%); }
            75% { clip-path: circle(100% at 100% 100%); }
            100% { clip-path: circle(0% at 50% 50%); }
        }
        
        /* True Infinity (1/2199023255552) - Endless recursion */
        @keyframes infinity-recursion {
            0% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(100) rotate(1800deg); }
            50% { transform: scale(0.01) rotate(3600deg); }
            75% { transform: scale(100) rotate(5400deg); }
            100% { transform: scale(1) rotate(7200deg); }
        }
        
        /* The One (1/4398046511104) - EXISTENCE ITSELF - OPTIMIZED */
        @keyframes theone-existence {
            0% { transform: scale(0); opacity: 0; filter: brightness(0) saturate(0); }
            25% { transform: scale(50); opacity: 1; filter: brightness(20) saturate(5); }
            50% { transform: scale(0); opacity: 0; filter: brightness(0) saturate(0); }
            75% { transform: scale(50); opacity: 1; filter: brightness(20) saturate(5); }
            100% { transform: scale(0); opacity: 0; filter: brightness(0) saturate(0); }
        }
        
        /* Primeval - Ancient swirling energy */
        @keyframes primeval-swirl {
            0% { transform: rotate(0deg) scale(1); filter: sepia(0); }
            50% { transform: rotate(360deg) scale(3); filter: sepia(1); }
            100% { transform: rotate(720deg) scale(1); filter: sepia(0); }
        }
        
        /* Celestial Prime - Star burst */
        @keyframes celestial-burst {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(10); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }
        
        /* Quantum - Wave collapse */
        @keyframes quantum-wave {
            0%, 100% { transform: scale(1); opacity: 1; filter: blur(0px); }
            25% { transform: scale(0.1); opacity: 0.5; filter: blur(10px); }
            50% { transform: scale(5); opacity: 1; filter: blur(0px); }
            75% { transform: scale(0.1); opacity: 0.5; filter: blur(10px); }
        }
        
        /* Dimensional - Portal effect */
        @keyframes dimensional-portal {
            0% { clip-path: circle(0% at 50% 50%); }
            50% { clip-path: circle(75% at 50% 50%); }
            100% { clip-path: circle(0% at 50% 50%); }
        }
        
        /* Hyperversal - Reality layers */
        @keyframes hyperversal-layers {
            0% { transform: translateZ(0); opacity: 1; }
            50% { transform: translateZ(200px); opacity: 0.5; }
            100% { transform: translateZ(0); opacity: 1; }
        }
        
        /* Outerversal - Edge fade */
        @keyframes outerversal-edge {
            0% { opacity: 1; box-shadow: inset 0 0 100px rgba(0,255,0,1); }
            50% { opacity: 0.3; box-shadow: inset 0 0 200px rgba(0,255,0,0.3); }
            100% { opacity: 1; box-shadow: inset 0 0 100px rgba(0,255,0,1); }
        }
        
        /* Boundaryless - Expanding infinity */
        @keyframes boundaryless-expand {
            0% { transform: scale(0.5); border-radius: 50%; }
            50% { transform: scale(20); border-radius: 0%; }
            100% { transform: scale(0.5); border-radius: 50%; }
        }
        
        /* Formless - Dissolve */
        @keyframes formless-dissolve {
            0%, 100% { opacity: 1; filter: blur(0px); }
            50% { opacity: 0.2; filter: blur(50px); }
        }
        
        /* Abstract - Concept shift */
        @keyframes abstract-shift {
            0% { transform: skew(0deg); }
            25% { transform: skew(30deg, 30deg); }
            50% { transform: skew(-30deg, -30deg); }
            75% { transform: skew(30deg, -30deg); }
            100% { transform: skew(0deg); }
        }
        
        /* Conceptual - Thought pulse */
        @keyframes conceptual-pulse {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(3); filter: brightness(5); }
        }
        
        /* Metaphysical - Being flicker */
        @keyframes metaphysical-flicker {
            0%, 100% { opacity: 1; }
            10%, 30%, 50%, 70%, 90% { opacity: 0; }
            20%, 40%, 60%, 80% { opacity: 1; }
        }
        
        /* The Source - Origin explosion */
        @keyframes source-explosion {
            0% { transform: scale(0.01); filter: brightness(100); }
            50% { transform: scale(100); filter: brightness(10); }
            100% { transform: scale(0); filter: brightness(0); }
        }
        
        /* The Eternal - Time loop */
        @keyframes eternal-loop {
            0% { transform: rotate(0deg) scale(1); }
            100% { transform: rotate(3600deg) scale(1); }
        }
        
        /* The Absolute Infinity - Infinity symbol */
        @keyframes absolute-infinity {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(20) rotate(180deg); }
            100% { transform: scale(1) rotate(360deg); }
        }
        
        /* Beyond Infinity - Transcendence */
        @keyframes beyond-transcend {
            0% { transform: scale(0); opacity: 0; filter: brightness(0) hue-rotate(0deg); }
            25% { transform: scale(50); opacity: 1; filter: brightness(100) hue-rotate(90deg); }
            50% { transform: scale(0); opacity: 0; filter: brightness(0) hue-rotate(180deg); }
            75% { transform: scale(50); opacity: 1; filter: brightness(100) hue-rotate(270deg); }
            100% { transform: scale(0); opacity: 0; filter: brightness(0) hue-rotate(360deg); }
        }
        
        /* Animation result display */
        .animation-result {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px 60px;
            border-radius: 20px;
            border: 4px solid var(--accent-primary);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
            text-align: center;
            animation: resultFadeIn 1s ease-out, resultGlow 2s ease-in-out infinite;
            transition: transform 0.3s ease;
        }
        
        .animation-result:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 0 80px rgba(0, 255, 255, 0.8);
        }
        
        @keyframes resultFadeIn {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        @keyframes resultGlow {
            0%, 100% { box-shadow: 0 0 50px rgba(0, 255, 255, 0.5); }
            50% { box-shadow: 0 0 100px rgba(0, 255, 255, 1), 0 0 150px rgba(255, 0, 255, 0.5); }
        }
        
        .animation-result-title {
            font-size: 2rem;
            margin-bottom: 20px;
            color: var(--accent-gold);
            text-shadow: 0 0 10px var(--accent-gold);
        }
        
        .animation-result-item {
            font-size: 2.5rem;
            font-weight: bold;
            margin: 20px 0;
            text-shadow: 0 0 20px currentColor;
            animation: textPulse 1.5s ease-in-out infinite;
        }
        
        @keyframes textPulse {
            0%, 100% { text-shadow: 0 0 20px currentColor; }
            50% { text-shadow: 0 0 40px currentColor, 0 0 60px currentColor; }
        }
        
        .animation-result-rarity {
            font-size: 1.5rem;
            margin: 15px 0;
        }
        
        .animation-result-chance {
            font-size: 1.3rem;
            color: var(--text-secondary);
            margin-top: 10px;
        }
        
        /* ===== MOBILE SUPPORT ===== */
        
        /* Prevent text selection on interactive elements */
        button, .inventory-item, .tab-button, .trade-card {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Touch-friendly tap targets (minimum 44x44px) */
        @media (max-width: 768px) {
            /* Mobile navigation - hamburger menu */
            .mobile-menu-toggle {
                display: block;
                position: fixed;
                top: 15px;
                right: 15px;
                z-index: 1001;
                background: var(--accent-primary);
                border: none;
                padding: 12px 15px;
                border-radius: 8px;
                cursor: pointer;
                font-size: 1.5rem;
                color: var(--bg-dark);
                box-shadow: 0 4px 15px rgba(0, 255, 204, 0.3);
            }
            
            .mobile-menu-toggle:active {
                transform: scale(0.95);
            }
            
            /* Tab navigation responsive */
            .tab-nav {
                position: fixed;
                top: 0;
                right: -100%;
                width: 280px;
                height: 100vh;
                background: var(--bg-dark);
                border-left: 2px solid var(--accent-primary);
                z-index: 1000;
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
                transition: right 0.3s ease;
                padding: 70px 10px 60px 10px; /* Adjusted for scroll hint */
                display: flex;
                flex-direction: column;
                gap: 10px;
                overscroll-behavior: contain; /* Prevent scroll chaining */
                box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5);
            }
            
            /* Scroll indicator gradient at bottom */
            .tab-nav::after {
                content: 'â¬‡ï¸ Scroll for more â¬‡ï¸';
                position: sticky;
                bottom: 0;
                left: 0;
                right: 0;
                height: 50px;
                background: linear-gradient(to top, var(--bg-dark) 0%, var(--bg-dark) 60%, transparent 100%);
                pointer-events: none;
                margin-top: auto;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 0.7rem;
                color: var(--text-secondary);
                text-align: center;
            }
            
            .tab-nav.mobile-open {
                right: 0;
            }
            
            .tab-button {
                width: 100%;
                margin: 0;
                padding: 15px;
                font-size: 1rem;
                min-height: 50px;
                border-radius: 8px;
                flex-shrink: 0; /* Prevent buttons from shrinking */
            }
            
            /* Container adjustments */
            .container {
                padding: 10px;
                margin: 0;
                max-width: 100%;
            }
            
            header {
                font-size: 1.5rem;
                padding: 15px;
                margin-bottom: 15px;
            }
            
            /* Stats bar - stack on mobile */
            .stats-bar {
                flex-direction: column;
                gap: 10px;
                margin-bottom: 15px;
            }
            
            .stat-card {
                width: 100%;
                padding: 12px;
            }
            
            .stat-label {
                font-size: 0.8rem;
            }
            
            .stat-value {
                font-size: 1.1rem;
            }
            
            /* Buttons */
            .btn, .spin-button {
                padding: 15px 20px;
                font-size: 1rem;
                min-height: 50px;
                touch-action: manipulation;
            }
            
            .spin-button {
                font-size: 1.2rem;
                padding: 20px 30px;
            }
            
            /* Inventory grid - 2 columns on mobile */
            .inventory-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                padding: 10px;
            }
            
            .inventory-item {
                padding: 12px;
                min-height: 120px;
            }
            
            .item-name {
                font-size: 0.8rem;
            }
            
            .item-value {
                font-size: 0.75rem;
            }
            
            /* Crafting/recipe grids - 1 column on mobile */
            .crafting-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .recipe-card, .stat-card {
                padding: 15px;
            }
            
            /* Trade cards */
            .trade-card {
                padding: 15px;
            }
            
            /* Tabs content */
            .tab-content {
                padding: 15px 10px;
            }
            
            /* Result display */
            .result-display {
                padding: 15px;
                margin: 15px 0;
            }
            
            .item-display {
                font-size: 1rem;
                padding: 15px;
            }
            
            /* Lucky Spin buttons - stack on mobile */
            .tab-content > div > div[style*="grid-template-columns: repeat(3"] {
                grid-template-columns: 1fr !important;
                gap: 10px !important;
            }
            
            /* Progress bars */
            .progress-bar {
                height: 25px;
            }
            
            .progress-fill {
                font-size: 0.85rem;
            }
            
            /* Pity counter */
            #pityCounterDisplay {
                font-size: 0.9rem;
            }
            
            /* Notifications */
            .notification {
                width: 90%;
                max-width: 350px;
                font-size: 0.9rem;
                padding: 12px;
            }
            
            /* Quest container */
            #questContainer {
                padding: 10px;
            }
            
            /* Battle Pass */
            #bpTiers {
                grid-template-columns: 1fr;
            }
            
            /* Fusion grid */
            #fusionItemsContainer {
                grid-template-columns: 1fr !important;
            }
            
            #fusionInventoryGrid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            /* Collections grid */
            #collectionBonusesGrid,
            #rarityMilestonesGrid {
                grid-template-columns: 1fr;
            }
            
            /* Admin panel */
            .admin-controls {
                grid-template-columns: 1fr;
            }
            
            /* Font size adjustments */
            h2 {
                font-size: 1.3rem;
            }
            
            h3 {
                font-size: 1.1rem;
            }
            
            p {
                font-size: 0.9rem;
            }
            
            /* Save/Load buttons */
            .container > div[style*="display: flex; justify-content: center"] {
                flex-direction: column;
                gap: 10px !important;
                padding: 0 10px;
            }
            
            .container > div[style*="display: flex; justify-content: center"] button {
                width: 100%;
            }
            
            /* Ultra rare overlay text */
            .animation-result-item {
                font-size: 1.8rem;
            }
            
            .animation-result-rarity {
                font-size: 1.2rem;
            }
            
            .animation-result-chance {
                font-size: 1rem;
            }
        }
        
        /* Small phones (max 480px) */
        @media (max-width: 480px) {
            header {
                font-size: 1.2rem;
                padding: 12px;
            }
            
            .inventory-grid {
                grid-template-columns: 1fr;
            }
            
            .stat-value {
                font-size: 1rem;
            }
            
            .btn {
                font-size: 0.9rem;
                padding: 12px 15px;
            }
            
            .spin-button {
                font-size: 1.1rem;
                padding: 18px 25px;
            }
            
            .tab-button {
                font-size: 0.9rem;
                padding: 12px;
            }
            
            h2 {
                font-size: 1.1rem;
            }
            
            h3 {
                font-size: 1rem;
            }
        }
        
        /* Landscape phones */
        @media (max-width: 768px) and (orientation: landscape) {
            .stats-bar {
                flex-direction: row;
                flex-wrap: wrap;
            }
            
            .stat-card {
                width: calc(50% - 5px);
            }
            
            .inventory-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        /* Tablet adjustments */
        @media (min-width: 769px) and (max-width: 1024px) {
            .inventory-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .crafting-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .stats-bar {
                flex-wrap: wrap;
            }
            
            .stat-card {
                flex: 1 1 calc(33.333% - 10px);
                min-width: 150px;
            }
        }
        
        /* Hide mobile menu toggle on desktop */
        @media (min-width: 769px) {
            .mobile-menu-toggle {
                display: none;
            }
            
            /* Reset tab-nav for desktop */
            .tab-nav {
                position: static;
                width: auto;
                height: auto;
                overflow-y: visible;
                padding: 0;
                flex-direction: row;
                flex-wrap: wrap;
                background: transparent;
                border: none;
                box-shadow: none;
            }
            
            /* Hide scroll indicators on desktop */
            .tab-nav::after {
                display: none;
            }
            
            .tab-nav > div:first-child {
                display: none;
            }
        }
        
        /* Prevent zoom on double-tap */
        * {
            touch-action: manipulation;
        }
        
        /* Smooth scrolling */
        html {
            scroll-behavior: smooth;
        }
        
        /* Better touch feedback */
        button:active, .inventory-item:active, .tab-button:active {
            transform: scale(0.98);
            transition: transform 0.1s;
        }
        
        @keyframes boss-float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }
        
        @keyframes screen-shake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-10px, 0); }
            20%, 40%, 60%, 80% { transform: translate(10px, 0); }
        }
        
        @keyframes fire-particle {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(calc(random() * 200px - 100px), calc(random() * 200px - 100px)) scale(0);
                opacity: 0;
            }
        }
        
        @keyframes primordial-explosion {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0.8;
            }
            100% {
                transform: translate(-50%, -50%) scale(4);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Mobile Menu Toggle -->
        <button class="mobile-menu-toggle" onclick="toggleMobileMenu()" id="mobileMenuBtn">â˜°</button>
        
        <header>
            âš¡ RNG TRADER âš¡
        </header>
        
        <div style="display: flex; justify-content: center; gap: 15px; margin-bottom: 20px;">
            <button class="btn btn-accept" onclick="saveGame()" style="padding: 10px 25px;">ðŸ’¾ Save Game</button>
            <button class="btn btn-accept" onclick="loadGame()" style="padding: 10px 25px;">ðŸ“‚ Load Game</button>
        </div>
        
        <div class="stats-bar">
            <div class="stat-card">
                <div class="stat-label">Money</div>
                <div class="stat-value" id="money">$0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Total Value</div>
                <div class="stat-value" id="totalValue">$0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Spins</div>
                <div class="stat-value" id="totalSpins">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Luck</div>
                <div class="stat-value" id="luckMultiplier">1.0x</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Trade Wins</div>
                <div class="stat-value" id="tradeWins">0</div>
            </div>
        </div>
        
        <div class="tabs tab-nav" id="tabNav">
            <div style="position: sticky; top: 0; background: var(--bg-dark); padding: 10px; margin: -10px -10px 10px -10px; border-bottom: 1px solid var(--accent-primary); z-index: 1; text-align: center; font-size: 0.7rem; color: var(--text-secondary);">
                ðŸ“± Swipe to scroll â¬‡ï¸
            </div>
            <button class="tab-button active" onclick="switchTab('spin')">ðŸŽ° Spin</button>
            <button class="tab-button" onclick="switchTab('inventory')">ðŸŽ’ Inventory</button>
            <button class="tab-button" onclick="switchTab('shop')">ðŸª Shop</button>
            <button class="tab-button" onclick="switchTab('upgrades')">â¬†ï¸ Upgrades</button>
            <button class="tab-button" onclick="switchTab('trading')">ðŸ¤ Trading</button>
            <button class="tab-button" onclick="switchTab('crafting')">ðŸ”¨ Crafting</button>
            <button class="tab-button" onclick="switchTab('enchanting')">âœ¨ Enchanting</button>
            <button class="tab-button" onclick="switchTab('achievements')">ðŸ† Achievements</button>
            <button class="tab-button" onclick="switchTab('quests')">ðŸ“‹ Quests</button>
            <button class="tab-button" onclick="switchTab('fusion')">ðŸ”® Fusion</button>
            <button class="tab-button" onclick="switchTab('statistics')">ðŸ“Š Statistics</button>
            <button class="tab-button" onclick="switchTab('collections')">ðŸ† Collections</button>
            <button class="tab-button" onclick="switchTab('battlepass')">ðŸŽ« Battle Pass</button>
            <button class="tab-button" onclick="switchTab('rebirth')">â™»ï¸ Rebirth</button>
            <button class="tab-button" onclick="switchTab('events')">ðŸŽ„ Events</button>
            <button class="tab-button" onclick="switchTab('bosses')">ðŸ‘¹ Bosses</button>
            <button class="tab-button" onclick="switchTab('artifacts')">ðŸ’Ž Artifacts</button>
            <button class="tab-button" onclick="switchTab('dailies')">ðŸ“… Daily</button>
            <button class="tab-button" onclick="switchTab('achievementshop')">ðŸª A-Shop</button>
            <button class="tab-button" onclick="switchTab('pets')">ðŸ‰ Pets</button>
            <button class="tab-button" onclick="switchTab('prestige')">â­ Prestige</button>
            <button class="tab-button" onclick="switchTab('settings')">âš™ï¸ Settings</button>
            <button class="tab-button" onclick="switchTab('admin')">ðŸ”’ Admin</button>
        </div>
        
        <!-- Spin Tab -->
        <div id="spin" class="tab-content active">
            <div class="spin-section">
                <h2 style="margin-bottom: 20px; color: var(--accent-primary);">ðŸŽ² Spin the Wheel of Fortune! ðŸŽ²</h2>
                
                <!-- Pity Counter Display -->
                <div class="stat-card" style="max-width: 600px; margin: 20px auto; background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-medium) 100%);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="color: var(--accent-gold); font-weight: bold;">ðŸ€ Pity System</span>
                        <span id="pityCounterDisplay" style="color: var(--warning); font-weight: bold;">0 / 100</span>
                    </div>
                    <div class="progress-bar" style="height: 20px;">
                        <div class="progress-fill" id="pityProgressBar" style="width: 0%; background: linear-gradient(90deg, var(--warning) 0%, var(--accent-gold) 100%);">
                            <span style="font-size: 0.85rem; font-weight: bold;">0%</span>
                        </div>
                    </div>
                    <p style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 8px; text-align: center;">
                        Guaranteed Legendary+ at 100!
                    </p>
                </div>
                
                <button class="spin-button" onclick="spinItem()" id="spinBtn">SPIN NOW!</button>
                
                <!-- Lucky Spin Mode -->
                <div style="margin-top: 30px; max-width: 800px; margin-left: auto; margin-right: auto;">
                    <h3 style="color: var(--accent-gold); text-align: center; margin-bottom: 15px;">â­ Lucky Spin Mode â­</h3>
                    <p style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Pay money for boosted odds!</p>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                        <button class="btn btn-accept" onclick="luckySpinItem(2)" style="background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); padding: 15px; font-size: 1rem;">
                            <div style="font-weight: bold; font-size: 1.1rem;">2x Luck</div>
                            <div style="font-size: 0.9rem; margin-top: 5px;">$10,000</div>
                        </button>
                        <button class="btn btn-accept" onclick="luckySpinItem(5)" style="background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); padding: 15px; font-size: 1rem;">
                            <div style="font-weight: bold; font-size: 1.1rem;">5x Luck</div>
                            <div style="font-size: 0.9rem; margin-top: 5px;">$100,000</div>
                        </button>
                        <button class="btn btn-accept" onclick="luckySpinItem(10)" style="background: linear-gradient(135deg, #FF69B4 0%, #FF1493 100%); padding: 15px; font-size: 1rem;">
                            <div style="font-weight: bold; font-size: 1.1rem;">10x Luck</div>
                            <div style="font-size: 0.9rem; margin-top: 5px;">$1,000,000</div>
                        </button>
                    </div>
                </div>
                
                <div class="result-display" id="resultDisplay">
                    <p style="color: var(--text-secondary);">Click SPIN to get your first item!</p>
                </div>
            </div>
        </div>
        
        <!-- Inventory Tab -->
        <div id="inventory" class="tab-content">
            <h2>Your Inventory</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Tap/Click an item to flex it! Long-press/Right-click to sell it for money.</p>
            
            <!-- Sorting Options -->
            <div style="display: flex; flex-wrap: wrap; gap: 10px; margin: 15px 0; justify-content: center;">
                <button class="btn btn-accept" onclick="sortInventory('rarity')" style="padding: 10px 15px;">Sort by Rarity</button>
                <button class="btn btn-accept" onclick="sortInventory('value')" style="padding: 10px 15px;">Sort by Value</button>
                <button class="btn btn-accept" onclick="sortInventory('count')" style="padding: 10px 15px;">Sort by Count</button>
                <select id="filterType" onchange="filterInventory()" style="padding: 10px; background: var(--bg-medium); color: var(--text-primary); border: 2px solid var(--accent-primary); border-radius: 8px; cursor: pointer;">
                    <option value="all">All Items</option>
                    <optgroup label="By Rarity">
                        <option value="common">Common</option>
                        <option value="uncommon">Uncommon</option>
                        <option value="rare">Rare</option>
                        <option value="epic">Epic</option>
                        <option value="legendary">Legendary</option>
                        <option value="mythic">Mythic</option>
                        <option value="exotic">Exotic</option>
                        <option value="celestial">Celestial</option>
                        <option value="divine">Divine</option>
                        <option value="cosmic">Cosmic</option>
                        <option value="infinite">Infinite</option>
                        <option value="transcendent">Transcendent</option>
                        <option value="ethereal">Ethereal</option>
                        <option value="primordial">Primordial+</option>
                    </optgroup>
                    <optgroup label="By Type">
                        <option value="event">All Event Items</option>
                        <option value="christmas">Christmas Items</option>
                        <option value="disco">Disco Items</option>
                        <option value="galactic">Galactic Items</option>
                        <option value="glitch">Glitch Items</option>
                        <option value="fullmoon">Full Moon Items</option>
                        <option value="bloodmoon">Blood Moon Items</option>
                        <option value="weather">Weather Items</option>
                        <option value="battlepass">Battle Pass Items</option>
                    </optgroup>
                </select>
            </div>
            
            <!-- Bulk Actions -->
            <div style="display: flex; flex-wrap: wrap; gap: 10px; margin: 15px 0; justify-content: center;">
                <select id="bulkSellRarity" style="padding: 10px; background: var(--bg-medium); color: var(--text-primary); border: 2px solid var(--accent-primary); border-radius: 8px; cursor: pointer;">
                    <option value="">Select Rarity to Sell...</option>
                    <option value="Common">Common</option>
                    <option value="Uncommon">Uncommon</option>
                    <option value="Rare">Rare</option>
                    <option value="Epic">Epic</option>
                    <option value="Legendary">Legendary</option>
                    <option value="Mythic">Mythic</option>
                    <option value="Exotic">Exotic</option>
                    <option value="Celestial">Celestial</option>
                    <option value="Divine">Divine</option>
                    <option value="Cosmic">Cosmic</option>
                    <option value="Infinite">Infinite</option>
                    <option value="Transcendent">Transcendent</option>
                    <option value="Ethereal">Ethereal</option>
                </select>
                <button class="btn btn-decline" onclick="bulkSellByRarity()" style="padding: 10px 20px;">
                    ðŸ’° Sell Selected Rarity
                </button>
            </div>
            
            <div style="display: flex; flex-wrap: wrap; gap: 10px; margin: 15px 0; justify-content: center;">
                <button class="btn btn-decline" onclick="sellAllItems()" style="padding: 10px 20px;">ðŸ’° Sell All (70% value)</button>
                <button class="btn btn-decline" onclick="sellAllNonFavorited()" style="padding: 10px 20px;">ðŸ’° Sell Non-Favorited</button>
                <button class="btn btn-warning" onclick="favoriteAllByRarity()" style="padding: 10px 20px;">â­ Favorite by Rarity</button>
                <button class="btn btn-warning" onclick="unfavoriteAll()" style="padding: 10px 20px;">âœ–ï¸ Unfavorite All</button>
            </div>
            
            <div class="inventory-grid" id="inventoryGrid"></div>
        </div>
        
        <!-- Shop Tab -->
        <div id="shop" class="tab-content">
            <h2>Item Shop</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Buy items with your hard-earned money!</p>
            <div class="inventory-grid" id="shopGrid"></div>
        </div>
        
        <!-- Upgrades Tab -->
        <div id="upgrades" class="tab-content">
            <h2>Upgrades</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Spend money to improve your game permanently!</p>
            <div class="crafting-grid" id="upgradesGrid"></div>
        </div>
        
        <!-- Trading Tab -->
        <div id="trading" class="tab-content">
            <h2>NPC Trading Post</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">NPCs will randomly offer item trades. Values are hidden - trade at your own risk!</p>
            <p style="margin: 10px 0; color: var(--warning);">âš ï¸ The richer you are, the more NPCs will try to scam you! âš ï¸</p>
            <div id="npcContainer"></div>
        </div>
        
        <!-- Crafting Tab -->
        <div id="crafting" class="tab-content">
            <h2>Crafting Station</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Combine items to create more valuable ones!</p>
            <div class="crafting-grid" id="craftingGrid"></div>
        </div>
        
        <!-- Enchanting Tab -->
        <div id="enchanting" class="tab-content">
            <h2>âœ¨ Enchantment Altar âœ¨</h2>
            <p style="margin: 10px 0; color: var(--warning);">âš ï¸ Only items Divine rarity or higher can be enchanted!</p>
            <p style="margin: 10px 0; color: var(--text-secondary);">Get random enchantments with powerful effects - or risk losing your item!</p>
            
            <div style="margin: 20px 0;">
                <h3>Select Divine+ Item to Enchant:</h3>
                <div class="inventory-grid" id="enchantInventoryGrid"></div>
            </div>
            
            <div id="enchantmentInterface" style="display: none;">
                <div class="enchant-slots">
                    <div class="enchant-slot filled" id="selectedEnchantItem"></div>
                </div>
                <div style="margin: 20px 0; padding: 15px; background: var(--bg-light); border-radius: 12px;">
                    <h3 style="color: var(--accent-primary); margin-bottom: 10px;">Possible Enchantments:</h3>
                    <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
                        <div style="margin: 5px 0;">ðŸ’° <strong>Value Upgrade</strong> - Increases item value</div>
                        <div style="margin: 5px 0;">ðŸ¤ <strong>Traders Dream</strong> - NPCs want this item more</div>
                        <div style="margin: 5px 0;">ðŸ”¨ <strong>Crafting Merger</strong> - Chance to duplicate crafts</div>
                        <div style="margin: 5px 0;">âœ¨ <strong>Enchanters Tool</strong> - Better enchant chances</div>
                        <div style="margin: 5px 0;">ðŸ’µ <strong>Money Multi</strong> - Better sell value</div>
                        <div style="margin: 5px 0;">ðŸŽ² <strong>Lucky Item</strong> - Boosts spin luck</div>
                        <div style="margin: 10px 0; padding-top: 10px; border-top: 2px solid var(--accent-gold);">
                            <strong style="color: var(--accent-gold);">GODLY ENCHANTS:</strong>
                        </div>
                        <div style="margin: 5px 0; color: var(--accent-gold);">ðŸ‘‘ <strong>Admins Dreams</strong> - 2x value, 2x luck, trade boost</div>
                        <div style="margin: 5px 0; color: var(--accent-gold);">ðŸŽ­ <strong>Emperors Style</strong> - 4x luck, trade boost</div>
                        <div style="margin: 5px 0; color: var(--accent-gold);">ðŸŒ€ <strong>Endless Possibilities</strong> - Craft dupe + enchant luck</div>
                        <div style="margin: 5px 0; color: var(--accent-gold);">âš¡ <strong>Chaotics Thoughts</strong> - 2x spins, anti-scammer</div>
                        <div style="margin: 10px 0; padding-top: 10px; border-top: 2px solid #ff00ff;">
                            <strong style="color: #ff00ff;">ULTIMATE:</strong>
                        </div>
                        <div style="margin: 5px 0; color: #ff00ff;">ðŸŒŸ <strong>Ruler of the World</strong> - ALL ENCHANTS COMBINED!</div>
                        <div style="margin: 10px 0; padding-top: 10px; border-top: 2px solid var(--danger);">
                            <strong style="color: var(--danger);">BAD ENCHANTS:</strong>
                        </div>
                        <div style="margin: 5px 0; color: var(--danger);">âš ï¸ Ditto, Too Much/Little Energy (destroys item)</div>
                    </div>
                </div>
                <button class="btn btn-accept" onclick="enchantItem()" style="width: 100%; padding: 20px; font-size: 1.2rem;">
                    âš¡ ENCHANT ITEM âš¡
                </button>
            </div>
        </div>
        
        <!-- Achievements Tab -->
        <div id="achievements" class="tab-content">
            <h2>Achievements</h2>
            <div class="achievement-list" id="achievementList"></div>
        </div>
        
        <!-- Quests Tab -->
        <div id="quests" class="tab-content">
            <h2>ðŸ“‹ Daily & Weekly Quests</h2>
            <p style="color: var(--text-secondary); margin-bottom: 20px;">Complete quests to earn Battle Pass XP!</p>
            
            <div id="questContainer" style="max-width: 800px; margin: 0 auto;">
                <!-- Quests will be populated here -->
            </div>
        </div>
        
        <!-- Fusion Tab -->
        <div id="fusion" class="tab-content">
            <h2>ðŸ”® Item Fusion</h2>
            <p style="color: var(--text-secondary); margin-bottom: 20px;">Combine items of the same rarity to create a higher rarity item!</p>
            
            <div style="max-width: 1000px; margin: 0 auto;">
                <div class="stat-card" style="margin-bottom: 30px; background: linear-gradient(135deg, var(--bg-medium) 0%, var(--bg-dark) 100%);">
                    <h3 style="color: var(--accent-primary); margin-bottom: 15px;">How Fusion Works</h3>
                    <p style="margin: 10px 0;">â€¢ Select 3 items of the <strong>same rarity</strong></p>
                    <p style="margin: 10px 0;">â€¢ Items will be consumed in the fusion process</p>
                    <p style="margin: 10px 0;">â€¢ You'll receive 1 <strong>random item of the SAME rarity</strong></p>
                    <p style="margin: 10px 0; color: var(--accent-primary);">âœ¨ Great for re-rolling bad items!</p>
                    <p style="margin: 10px 0; color: var(--warning);">âš ï¸ This process cannot be undone!</p>
                </div>
                
                <div id="fusionItemsContainer" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 20px;">
                    <div class="stat-card" style="min-height: 150px; display: flex; align-items: center; justify-content: center; border: 2px dashed var(--accent-primary);">
                        <span style="color: var(--text-secondary);">Item Slot 1</span>
                    </div>
                    <div class="stat-card" style="min-height: 150px; display: flex; align-items: center; justify-content: center; border: 2px dashed var(--accent-primary);">
                        <span style="color: var(--text-secondary);">Item Slot 2</span>
                    </div>
                    <div class="stat-card" style="min-height: 150px; display: flex; align-items: center; justify-content: center; border: 2px dashed var(--accent-primary);">
                        <span style="color: var(--text-secondary);">Item Slot 3</span>
                    </div>
                </div>
                
                <div style="text-align: center; margin: 30px 0;">
                    <button class="btn btn-accept" onclick="performFusion()" id="fusionButton" disabled style="opacity: 0.5; font-size: 1.2rem; padding: 15px 40px;">
                        âš—ï¸ FUSE ITEMS
                    </button>
                    <button class="btn btn-decline" onclick="clearFusionSlots()" style="margin-left: 10px; padding: 15px 30px;">
                        Clear Slots
                    </button>
                </div>
                
                <h3 style="color: var(--accent-primary); margin: 40px 0 20px 0;">Available Items for Fusion</h3>
                <div id="fusionInventoryGrid" class="inventory-grid" style="margin-top: 20px;">
                    <!-- Fusion inventory will be populated here -->
                </div>
            </div>
        </div>
        
        <!-- Statistics Tab -->
        <div id="statistics" class="tab-content">
            <h2>ðŸ“Š Statistics & Records</h2>
            <p style="color: var(--text-secondary); margin-bottom: 30px;">Your complete game statistics and achievements</p>
            
            <div class="crafting-grid" style="max-width: 1200px; margin: 0 auto;">
                <!-- General Stats -->
                <div class="stat-card">
                    <h3 style="color: var(--accent-primary); margin-bottom: 15px;">ðŸŽ² General Stats</h3>
                    <div style="text-align: left;">
                        <p><strong>Total Spins:</strong> <span id="statTotalSpins">0</span></p>
                        <p><strong>Total Logins:</strong> <span id="statTotalLogins">0</span></p>
                        <p><strong>Current Login Streak:</strong> <span id="statLoginStreak">0</span> days</p>
                        <p><strong>Total Rebirths:</strong> <span id="statRebirths">0</span></p>
                        <p><strong>Quests Completed:</strong> <span id="statQuestsCompleted">0</span></p>
                    </div>
                </div>
                
                <!-- Money Stats -->
                <div class="stat-card">
                    <h3 style="color: var(--accent-gold); margin-bottom: 15px;">ðŸ’° Financial Stats</h3>
                    <div style="text-align: left;">
                        <p><strong>Current Money:</strong> $<span id="statCurrentMoney">0</span></p>
                        <p><strong>Total Value:</strong> $<span id="statTotalValue">0</span></p>
                        <p><strong>Lifetime Earned:</strong> $<span id="statLifetimeEarned">0</span></p>
                        <p><strong>Lifetime Spent:</strong> $<span id="statLifetimeSpent">0</span></p>
                        <p><strong>Net Profit:</strong> $<span id="statNetProfit">0</span></p>
                    </div>
                </div>
                
                <!-- Trading Stats -->
                <div class="stat-card">
                    <h3 style="color: var(--success); margin-bottom: 15px;">ðŸ¤ Trading Stats</h3>
                    <div style="text-align: left;">
                        <p><strong>Trade Wins:</strong> <span id="statTradeWins">0</span></p>
                        <p><strong>Trade Losses:</strong> <span id="statTradeLosses">0</span></p>
                        <p><strong>Win Rate:</strong> <span id="statWinRate">0</span>%</p>
                        <p><strong>Biggest Win:</strong> $<span id="statBiggestWin">0</span></p>
                        <p><strong>Biggest Loss:</strong> $<span id="statBiggestLoss">0</span></p>
                    </div>
                </div>
                
                <!-- Crafting Stats -->
                <div class="stat-card">
                    <h3 style="color: var(--accent-primary); margin-bottom: 15px;">ðŸ”¨ Creation Stats</h3>
                    <div style="text-align: left;">
                        <p><strong>Items Crafted:</strong> <span id="statCrafted">0</span></p>
                        <p><strong>Enchant Success:</strong> <span id="statEnchantSuccess">0</span></p>
                        <p><strong>Enchant Fails:</strong> <span id="statEnchantFails">0</span></p>
                        <p><strong>Enchant Success Rate:</strong> <span id="statEnchantRate">0</span>%</p>
                        <p><strong>Shop Purchases:</strong> <span id="statShopPurchases">0</span></p>
                    </div>
                </div>
                
                <!-- Collection Stats -->
                <div class="stat-card">
                    <h3 style="color: var(--accent-purple); margin-bottom: 15px;">ðŸ“¦ Collection Stats</h3>
                    <div style="text-align: left;">
                        <p><strong>Unique Items:</strong> <span id="statUniqueItems">0</span></p>
                        <p><strong>Total Items:</strong> <span id="statTotalItems">0</span></p>
                        <p><strong>Event Items:</strong> <span id="statEventItems">0</span></p>
                        <p><strong>Achievements:</strong> <span id="statAchievements">0</span></p>
                        <p><strong>Battle Pass Tier:</strong> <span id="statBPTier">0</span></p>
                    </div>
                </div>
                
                <!-- Pity System Stats -->
                <div class="stat-card">
                    <h3 style="color: var(--warning); margin-bottom: 15px;">ðŸ€ Luck & Pity Stats</h3>
                    <div style="text-align: left;">
                        <p><strong>Current Luck:</strong> <span id="statCurrentLuck">1.0</span>x</p>
                        <p><strong>Pity Counter:</strong> <span id="statPityCounter">0</span> / <span id="statPityThreshold">100</span></p>
                        <p><strong>Pity Triggered:</strong> <span id="statPityTriggered">0</span> times</p>
                        <div class="progress-bar" style="margin-top: 10px;">
                            <div class="progress-fill" id="pityProgress" style="width: 0%; background: var(--warning);">0%</div>
                        </div>
                    </div>
                </div>
                
                <!-- Rarity Distribution -->
                <div class="stat-card" style="grid-column: span 2;">
                    <h3 style="color: var(--accent-primary); margin-bottom: 15px;">ðŸŽ¯ Rarity Distribution</h3>
                    <div id="rarityDistribution" style="max-height: 300px; overflow-y: auto;">
                        <!-- Rarity counts will be populated here -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Collections Tab -->
        <div id="collections" class="tab-content">
            <h2>ðŸ† Collection Bonuses & Milestones</h2>
            <p style="color: var(--text-secondary); margin-bottom: 30px;">Complete collections for permanent bonuses!</p>
            
            <div style="max-width: 1200px; margin: 0 auto;">
                <!-- Collection Bonuses -->
                <div style="margin-bottom: 40px;">
                    <h3 style="color: var(--accent-primary); margin-bottom: 20px;">ðŸŽ Event Collection Bonuses</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 15px;">Collect all items from an event to unlock permanent bonuses during that event!</p>
                    <div id="collectionBonusesGrid" class="crafting-grid">
                        <!-- Collection bonuses will be populated here -->
                    </div>
                </div>
                
                <!-- Rarity Milestones -->
                <div>
                    <h3 style="color: var(--accent-gold); margin-bottom: 20px;">â­ Rarity Milestones</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 15px;">Collect certain amounts of each rarity to unlock permanent luck boosts!</p>
                    <div id="rarityMilestonesGrid" class="crafting-grid">
                        <!-- Rarity milestones will be populated here -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Battle Pass Tab -->
        <div id="battlepass" class="tab-content">
            <h2>Battle Pass - Season 1</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="bpProgress" style="width: 0%;">Tier 0/10</div>
            </div>
            <div id="bpTiers"></div>
        </div>
        
        <!-- Events Tab -->
        <div id="events" class="tab-content">
            <div class="event-banner">
                ðŸŽ„ CHRISTMAS EVENT ðŸŽ…
            </div>
            <p style="margin: 20px 0;">The Christmas event happens automatically every hour (at XX:00) and lasts for 5 minutes! During this time, you have a 15% chance to spin special holiday items!</p>
            <div style="margin-top: 30px;">
                <h3>Active Bonuses:</h3>
                <div id="eventBonuses" style="margin-top: 15px;"></div>
            </div>
        </div>
        
        <!-- Rebirth Tab -->
        <div id="rebirth" class="tab-content">
            <h2>â™»ï¸ Rebirth System</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Rebirth to gain permanent bonuses, but lose all progress!</p>
            
            <div class="stat-card" style="margin: 20px 0;">
                <div class="stat-label">Total Rebirths</div>
                <div class="stat-value" style="color: var(--accent-primary);" id="rebirthCount">0</div>
            </div>
            
            <div class="stat-card" style="margin: 20px 0;">
                <div class="stat-label">Permanent Luck Boost</div>
                <div class="stat-value" style="color: var(--accent-gold);" id="permanentLuck">1.0x</div>
                <p style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 10px;">Each rebirth adds +2x permanent luck</p>
            </div>
            
            <div class="npc-container" style="margin-top: 30px;">
                <h3 style="color: var(--accent-primary); margin-bottom: 15px;">Rebirth Requirements:</h3>
                <div id="rebirthRequirements" style="background: var(--bg-light); padding: 20px; border-radius: 12px; border: 2px solid var(--accent-secondary);">
                    <p style="color: var(--accent-gold);">Next Rebirth Requirements:</p>
                    <p style="color: var(--text-secondary);">ðŸ’° Money: $1,000,000</p>
                    <p style="color: var(--rarity-mythic);">âœ¨ Item: Mythic+ rarity</p>
                    <p style="color: var(--success);">ðŸŽ Reward: +2.0x permanent luck</p>
                </div>
                <div style="margin: 20px 0; padding: 15px; background: var(--bg-medium); border-radius: 8px; border-left: 4px solid var(--danger);">
                    <p style="color: var(--danger); font-weight: bold; margin-bottom: 10px;">âš ï¸ WARNING âš ï¸</p>
                    <p style="color: var(--text-secondary); font-size: 0.9rem;">Rebirthing will reset:</p>
                    <ul style="color: var(--text-secondary); font-size: 0.9rem; margin: 10px 0 10px 20px;">
                        <li>All items in inventory</li>
                        <li>All money</li>
                        <li>All upgrades</li>
                        <li>Battle Pass progress</li>
                        <li>Total spins counter</li>
                    </ul>
                    <p style="color: var(--success); font-size: 0.9rem; margin-top: 10px;">âœ“ You keep: Achievements, Rebirths, Permanent Luck, Quest Stats</p>
                </div>
                    <button class="btn btn-decline" onclick="performRebirth()" style="width: 100%; padding: 15px; font-size: 1.1rem;">
                        â™»ï¸ REBIRTH NOW â™»ï¸
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Boss Battles Tab -->
        <div id="bosses" class="tab-content">
            <h2>ðŸ‘¹ Boss Battles</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Fight powerful bosses for legendary rewards!</p>
            
            <div style="max-width: 1200px; margin: 0 auto;">
                <!-- Boss Statistics -->
                <div class="stat-card" style="margin-bottom: 20px; background: linear-gradient(135deg, var(--bg-medium), var(--bg-dark));">
                    <h3 style="color: var(--accent-primary);">ðŸ“Š Your Boss Stats</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-top: 15px;">
                        <div>
                            <div style="color: var(--text-secondary); font-size: 0.9rem;">Bosses Defeated</div>
                            <div style="color: var(--accent-gold); font-size: 1.5rem; font-weight: bold;" id="totalBossesDefeated">0</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 0.9rem;">Total Damage Dealt</div>
                            <div style="color: var(--danger); font-size: 1.5rem; font-weight: bold;" id="totalBossDamage">0</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 0.9rem;">Best Rewards</div>
                            <div style="color: var(--success); font-size: 1.5rem; font-weight: bold;" id="bestBossReward">$0</div>
                        </div>
                    </div>
                </div>
                
                <!-- Boss List -->
                <div id="bossesContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 20px;">
                    <!-- Bosses will be rendered here -->
                </div>
            </div>
        </div>
        
        <!-- Artifacts Tab -->
        <div id="artifacts" class="tab-content">
            <h2>ðŸ’Ž Legendary Artifacts</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Collect powerful artifacts for permanent bonuses!</p>
            
            <div style="max-width: 1200px; margin: 0 auto;">
                <!-- Artifact Collection Stats -->
                <div class="stat-card" style="margin-bottom: 20px; background: linear-gradient(135deg, var(--bg-medium), var(--bg-dark));">
                    <h3 style="color: var(--accent-gold);">ðŸ† Collection Progress</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 15px;">
                        <div>
                            <div style="color: var(--text-secondary); font-size: 0.9rem;">Artifacts Owned</div>
                            <div style="color: var(--accent-gold); font-size: 1.8rem; font-weight: bold;"><span id="artifactsOwned">0</span> / 15</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 0.9rem;">Total Power</div>
                            <div style="color: var(--accent-primary); font-size: 1.8rem; font-weight: bold;" id="totalArtifactPower">0%</div>
                        </div>
                    </div>
                </div>
                
                <!-- Artifact List by Tier -->
                <div id="artifactsContainer">
                    <!-- Artifacts will be rendered here by tier -->
                </div>
            </div>
        </div>
        
        <!-- Daily Challenges Tab -->
        <div id="dailies" class="tab-content">
            <h2>ðŸ“… Daily Challenges</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Complete challenges for rewards! Resets daily at midnight.</p>
            
            <div style="text-align: center; margin: 20px 0;">
                <div style="font-size: 1.2rem; color: var(--accent-primary);">
                    ðŸ† Achievement Points: <span id="achievementPointsDisplay">0</span>
                </div>
            </div>
            
            <div id="dailyChallengesContainer" class="crafting-grid" style="margin-top: 20px;"></div>
        </div>
        
        <!-- Achievement Shop Tab -->
        <div id="achievementshop" class="tab-content">
            <h2>ðŸª Achievement Shop</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Spend Achievement Points on permanent upgrades!</p>
            
            <div style="text-align: center; margin: 20px 0;">
                <div style="font-size: 1.5rem; color: var(--accent-gold);">
                    ðŸ’° Points: <span id="achievementPointsShopDisplay">0</span>
                </div>
                <p style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 5px;">
                    Earn points by completing achievements!
                </p>
            </div>
            
            <div id="achievementShopContainer" class="crafting-grid" style="margin-top: 20px;"></div>
        </div>
        
        <!-- Pets Tab -->
        <div id="pets" class="tab-content">
            <h2>ðŸ‰ Pet Collection</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Collect and level up pets for permanent bonuses!</p>
            
            <div style="text-align: center; margin: 20px 0; padding: 20px; background: var(--bg-light); border-radius: 12px;">
                <h3 style="color: var(--accent-primary); margin-bottom: 15px;">Active Pet</h3>
                <div id="activePetDisplay" style="font-size: 3rem; margin: 10px 0;">â“</div>
                <div id="activePetName" style="font-size: 1.2rem; color: var(--accent-gold); margin: 10px 0;">No pet equipped</div>
                <div id="activePetBonus" style="color: var(--text-secondary); font-size: 0.9rem;">Equip a pet to get bonuses!</div>
                <div id="activePetLevel" style="color: var(--success); font-size: 0.9rem; margin-top: 5px;">Level: 0</div>
            </div>
            
            <h3 style="margin: 20px 0;">ðŸŒŸ Available Pets</h3>
            <div id="petsContainer" class="crafting-grid"></div>
        </div>
        
        <!-- Prestige Tab -->
        <div id="prestige" class="tab-content">
            <h2>â­ Prestige System</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Reset everything for powerful permanent bonuses!</p>
            
            <div style="max-width: 600px; margin: 30px auto;">
                <div style="text-align: center; padding: 30px; background: linear-gradient(135deg, var(--bg-medium) 0%, var(--bg-light) 100%); border-radius: 15px; border: 2px solid var(--accent-gold);">
                    <div style="font-size: 3rem; margin-bottom: 10px;">â­</div>
                    <h3 style="color: var(--accent-gold); margin-bottom: 10px;">Current Prestige Level</h3>
                    <div style="font-size: 3rem; color: var(--accent-gold); margin: 20px 0;" id="prestigeLevelDisplay">0</div>
                    <div style="font-size: 1.2rem; color: var(--success); margin: 10px 0;">
                        Prestige Points: <span id="prestigePointsDisplay">0</span>
                    </div>
                    
                    <div style="margin: 30px 0; padding: 20px; background: var(--bg-dark); border-radius: 10px; text-align: left;">
                        <h4 style="color: var(--accent-primary); margin-bottom: 15px;">Prestige Requirements:</h4>
                        <div style="margin: 10px 0;">
                            âœ… 10+ Rebirths: <span id="prestigeRebirthReq" style="color: var(--danger);">Not met</span>
                        </div>
                        <div style="margin: 10px 0;">
                            âœ… $1 Billion: <span id="prestigeMoneyReq" style="color: var(--danger);">Not met</span>
                        </div>
                        <div style="margin: 10px 0;">
                            âœ… 1 Primordial+ Item: <span id="prestigeItemReq" style="color: var(--danger);">Not met</span>
                        </div>
                    </div>
                    
                    <button class="btn btn-accept" onclick="performPrestige()" id="prestigeButton" disabled style="width: 100%; padding: 20px; font-size: 1.2rem; opacity: 0.5; cursor: not-allowed;">
                        â­ PRESTIGE NOW â­
                    </button>
                    
                    <div style="margin-top: 20px; color: var(--text-secondary); font-size: 0.9rem;">
                        <p style="margin: 5px 0;">ðŸ’Ž You keep: Prestige Points, Prestige Shop, Pets</p>
                        <p style="margin: 5px 0; color: var(--danger);">âŒ You lose: EVERYTHING ELSE</p>
                    </div>
                </div>
                
                <h3 style="margin: 30px 0; text-align: center;">ðŸª Prestige Shop</h3>
                <div id="prestigeShopContainer" class="crafting-grid"></div>
            </div>
        </div>
        
        <!-- Settings Tab -->
        <div id="settings" class="tab-content">
            <h2>âš™ï¸ Settings</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Customize your gameplay experience</p>
            
            <div class="crafting-grid" style="margin-top: 20px;">
                <div class="recipe-card">
                    <h3 style="color: var(--accent-primary);">Notifications</h3>
                    <div style="margin: 15px 0;">
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingSoundEffects" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>ðŸ”Š Sound Effects</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingTradeNotif" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Trade Notifications</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingExpiredNotif" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Expired Trade Notifications</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingSpinNotif" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Spin Result Notifications</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingAchievementNotif" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Achievement Notifications</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingEventNotif" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Random Event Notifications</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingAutoSaveNotif" onchange="updateSettings()" style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Auto-Save Notifications</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingPityNotif" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Pity System Notifications</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingFusionNotif" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Fusion Notifications</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingCollectionNotif" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Collection Completions</span>
                        </label>
                    </div>
                </div>
                
                <div class="recipe-card">
                    <h3 style="color: var(--accent-primary);">Gameplay</h3>
                    <div style="margin: 15px 0;">
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingConfirmSell" onchange="updateSettings()" style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Confirm Before Selling Items</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingAnimations" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Enable Ultra-Rare Animations</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingCompactMode" onchange="updateSettings()" style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Compact UI Mode</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingShowValue" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Item Values in Inventory</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingAutoClaimQuests" onchange="updateSettings()" style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Auto-Claim Completed Quests</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingConfirmRebirth" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Confirm Rebirth Action</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingConfirmPrestige" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Confirm Prestige Action</span>
                        </label>
                    </div>
                </div>
                
                <div class="recipe-card">
                    <h3 style="color: var(--accent-primary);">Auto-Save</h3>
                    <div style="margin: 15px 0;">
                        <label style="display: block; margin: 10px 0;">
                            <span style="color: var(--text-secondary); display: block; margin-bottom: 5px;">Auto-Save Interval</span>
                            <select id="settingAutoSaveInterval" onchange="updateSettings()" style="width: 100%; padding: 10px; background: var(--bg-medium); color: var(--text-primary); border: 2px solid var(--accent-primary); border-radius: 8px;">
                                <option value="30">30 seconds</option>
                                <option value="60" selected>1 minute</option>
                                <option value="120">2 minutes</option>
                                <option value="300">5 minutes</option>
                                <option value="0">Disabled</option>
                            </select>
                        </label>
                    </div>
                </div>
                
                <div class="recipe-card">
                    <h3 style="color: var(--accent-primary);">Visual Preferences</h3>
                    <div style="margin: 15px 0;">
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingShowRarityColors" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Colorful Rarity Names</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingShowItemCount" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Item Counts</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingReduceMotion" onchange="updateSettings()" style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Reduce Motion (Accessibility)</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingLargeText" onchange="updateSettings()" style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Large Text Mode</span>
                        </label>
                    </div>
                </div>
                
                <div class="recipe-card">
                    <h3 style="color: var(--accent-primary);">âŒ¨ï¸ Keyboard Shortcuts</h3>
                    <div style="margin: 15px 0; line-height: 2;">
                        <div style="display: grid; grid-template-columns: auto 1fr; gap: 10px; color: var(--text-secondary); font-size: 0.9rem;">
                            <span style="color: var(--accent-gold); font-weight: bold;">SPACE</span><span>Spin the wheel</span>
                            <span style="color: var(--accent-gold); font-weight: bold;">1-9</span><span>Switch tabs (1=Inventory, 2=Shop, etc.)</span>
                            <span style="color: var(--accent-gold); font-weight: bold;">S</span><span>Shop tab</span>
                            <span style="color: var(--accent-gold); font-weight: bold;">I</span><span>Inventory tab</span>
                            <span style="color: var(--accent-gold); font-weight: bold;">B</span><span>Bosses tab</span>
                            <span style="color: var(--accent-gold); font-weight: bold;">A</span><span>Artifacts tab</span>
                            <span style="color: var(--accent-gold); font-weight: bold;">P</span><span>Prestige tab</span>
                            <span style="color: var(--accent-gold); font-weight: bold;">R</span><span>Rebirth tab</span>
                            <span style="color: var(--accent-gold); font-weight: bold;">ESC</span><span>Close modals</span>
                        </div>
                    </div>
                </div>
                
                <div class="recipe-card">
                    <h3 style="color: var(--accent-primary);">ðŸ’¾ Save Management</h3>
                    <div style="margin: 15px 0;">
                        <button class="btn btn-accept" onclick="exportSaveData()" style="width: 100%; margin-bottom: 10px;">
                            ðŸ“¤ Export Save Code
                        </button>
                        <button class="btn btn-accept" onclick="resetTutorial()" style="width: 100%; margin-bottom: 10px; background: linear-gradient(135deg, var(--accent-primary), var(--success));">
                            ðŸ“š Restart Tutorial
                        </button>
                        <p style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 10px;">
                            Export to backup your progress or share with friends!<br>
                            <strong>Import is in Admin Panel for safety.</strong>
                        </p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Admin Panel -->
        <div id="admin" class="tab-content">
            <div id="adminLogin" style="display: block;">
                <h2>ðŸ”’ Admin Panel - Login Required</h2>
                <p style="margin: 20px 0; color: var(--text-secondary);">Enter the admin password to access cheat commands</p>
                <div style="max-width: 400px; margin: 0 auto;">
                    <input type="password" id="adminPasswordInput" placeholder="Enter password..." 
                           style="width: 100%; padding: 15px; margin: 20px 0; background: var(--bg-medium); color: var(--text-primary); border: 2px solid var(--accent-primary); border-radius: 8px; font-size: 1rem;">
                    <button class="btn btn-accept" onclick="unlockAdmin()" style="width: 100%;">Unlock Admin Panel</button>
                </div>
            </div>
            
            <div id="adminPanel" style="display: none;">
                <h2>âš™ï¸ Admin Panel</h2>
                <p style="margin: 10px 0; color: var(--warning);">âš ï¸ Warning: These are cheat commands for testing purposes!</p>
                
                <div class="crafting-grid" style="margin-top: 20px;">
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Money Cheats</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminAddMoney(1000)">+$1,000</button>
                            <button class="btn btn-accept" onclick="adminAddMoney(10000)" style="margin-top: 10px;">+$10,000</button>
                            <button class="btn btn-accept" onclick="adminAddMoney(100000)" style="margin-top: 10px;">+$100,000</button>
                            <button class="btn btn-accept" onclick="adminAddMoney(1000000)" style="margin-top: 10px;">+$1,000,000</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Item Spawner</h3>
                        <div style="margin: 15px 0;">
                            <select id="adminRaritySelect" style="width: 100%; padding: 10px; margin-bottom: 10px; background: var(--bg-medium); color: var(--text-primary); border: 2px solid var(--accent-primary); border-radius: 8px; max-height: 200px; overflow-y: auto;">
                                <option value="0">Common</option>
                                <option value="1">Uncommon</option>
                                <option value="2">Rare</option>
                                <option value="3">Epic</option>
                                <option value="4">Legendary</option>
                                <option value="5">Mythic</option>
                                <option value="6">Exotic</option>
                                <option value="7">Celestial</option>
                                <option value="8">Divine</option>
                                <option value="9">Cosmic</option>
                                <option value="10">Infinite</option>
                                <option value="11">Transcendent</option>
                                <option value="12">Ethereal</option>
                                <option value="13">Primordial</option>
                                <option value="14">Omega</option>
                                <option value="15">Supreme</option>
                                <option value="16">Godlike</option>
                                <option value="17">Universal</option>
                                <option value="18">Multiversal</option>
                                <option value="19">Omnipotent</option>
                                <option value="20">Infinite Absolute</option>
                                <option value="21">Eternal</option>
                                <option value="22">Immortal</option>
                                <option value="23">Ascended</option>
                                <option value="24">Transcendental</option>
                                <option value="25">Boundless</option>
                                <option value="26">Limitless</option>
                                <option value="27">Absolute</option>
                                <option value="28">Beyond</option>
                                <option value="29">Incomprehensible</option>
                                <option value="30">Unimaginable</option>
                                <option value="31">Impossible</option>
                                <option value="32">Paradox</option>
                                <option value="33">Singularity</option>
                                <option value="34">Void</option>
                                <option value="35">Nothingness</option>
                                <option value="36">Everything</option>
                                <option value="37">The End</option>
                                <option value="38">The Beginning</option>
                                <option value="39">Alpha Omega</option>
                                <option value="40">True Infinity</option>
                                <option value="41">The One</option>
                                <option value="42">Primeval</option>
                                <option value="43">Celestial Prime</option>
                                <option value="44">Quantum</option>
                                <option value="45">Dimensional</option>
                                <option value="46">Hyperversal</option>
                                <option value="47">Outerversal</option>
                                <option value="48">Boundaryless</option>
                                <option value="49">Formless</option>
                                <option value="50">Abstract</option>
                                <option value="51">Conceptual</option>
                                <option value="52">Metaphysical</option>
                                <option value="53">The Source</option>
                                <option value="54">The Eternal</option>
                                <option value="55">The Absolute Infinity</option>
                                <option value="56">Beyond Infinity</option>
                            </select>
                            <input type="number" id="adminItemCount" placeholder="Amount (1-100)" min="1" max="100" value="1" style="width: 100%; padding: 10px; margin-bottom: 10px; background: var(--bg-medium); color: var(--text-primary); border: 2px solid var(--accent-primary); border-radius: 8px;">
                            <button class="btn btn-accept" onclick="adminSpawnItem()">Spawn Item(s)</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Luck Manipulation</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminSetLuck(2)">Set Luck 2x</button>
                            <button class="btn btn-accept" onclick="adminSetLuck(5)" style="margin-top: 10px;">Set Luck 5x</button>
                            <button class="btn btn-accept" onclick="adminSetLuck(10)" style="margin-top: 10px;">Set Luck 10x</button>
                            <button class="btn btn-accept" onclick="adminSetLuck(100)" style="margin-top: 10px;">Set Luck 100x</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Max Upgrades</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminMaxUpgrades()">Max All Upgrades</button>
                            <p style="color: var(--text-secondary); margin-top: 10px; font-size: 0.9rem;">Sets all upgrades to max level</p>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Battle Pass</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminAddBPXP(1000)">+1,000 XP</button>
                            <button class="btn btn-accept" onclick="adminAddBPXP(10000)" style="margin-top: 10px;">+10,000 XP</button>
                            <button class="btn btn-accept" onclick="adminMaxBP()" style="margin-top: 10px;">Max Battle Pass</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Events</h3>
                        <div style="margin: 15px 0;">
                            <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 10px;">Weather Events:</p>
                            <button class="btn btn-accept" onclick="adminStartWeatherEvent('cloudy')">Start Cloudy Event</button>
                            <button class="btn btn-accept" onclick="adminStartWeatherEvent('rainy')" style="margin-top: 5px;">Start Rainy Event</button>
                            <button class="btn btn-accept" onclick="adminStartWeatherEvent('storming')" style="margin-top: 5px;">Start Storming Event</button>
                            
                            <p style="color: var(--text-secondary); font-size: 0.9rem; margin: 15px 0 10px 0;">Special Events:</p>
                            <button class="btn btn-accept" onclick="adminStartSpecialEvent('disco')" style="background: #ff00ff;">ðŸª© Disco Event</button>
                            <button class="btn btn-accept" onclick="adminStartSpecialEvent('galactic')" style="margin-top: 5px; background: #4B0082;">ðŸŒŒ Galactic Event</button>
                            <button class="btn btn-accept" onclick="adminStartSpecialEvent('glitch')" style="margin-top: 5px; background: #00ff00; color: black;">âš¡ Glitch Event</button>
                            <button class="btn btn-accept" onclick="adminStartSpecialEvent('fullmoon')" style="margin-top: 5px; background: #f0f0f0; color: black;">ðŸŒ• Full Moon Event</button>
                            <button class="btn btn-accept" onclick="adminStartSpecialEvent('bloodmoon')" style="margin-top: 5px; background: #8B0000;">ðŸ”´ Blood Moon Event</button>
                            
                            <p style="color: var(--text-secondary); font-size: 0.9rem; margin: 15px 0 10px 0;">Other Events:</p>
                            <button class="btn btn-accept" onclick="adminToggleChristmas()">Toggle Christmas Event</button>
                            <button class="btn btn-accept" onclick="adminSpawnTrade()" style="margin-top: 5px;">Spawn Trade Now</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Inventory</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-decline" onclick="adminClearInventory()">Clear Inventory</button>
                            <button class="btn btn-accept" onclick="adminDuplicateInventory()" style="margin-top: 10px;">Duplicate Inventory</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Achievements</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminUnlockAllAchievements()">Unlock All Achievements</button>
                            <button class="btn btn-decline" onclick="adminResetAchievements()" style="margin-top: 10px;">Reset Achievements</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Stats Manipulation</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminSetSpins(10000)">Set 10k Spins</button>
                            <button class="btn btn-accept" onclick="adminAddRebirths(1)" style="margin-top: 10px;">+1 Rebirth</button>
                            <button class="btn btn-accept" onclick="adminSetTradeWins(1000)" style="margin-top: 10px;">Set 1k Trade Wins</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Quick Actions</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminCompleteEverything()">Complete Everything</button>
                            <p style="color: var(--text-secondary); margin-top: 10px; font-size: 0.9rem;">Max upgrades, BP, money, achievements</p>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">ðŸ“¥ Import Save</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="showImportDialog()" style="width: 100%;">Import Save Code</button>
                            <p style="color: var(--warning); margin-top: 10px; font-size: 0.9rem;">âš ï¸ Will overwrite current progress!</p>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--danger);">Danger Zone</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-decline" onclick="adminResetGame()">Reset Everything</button>
                            <p style="color: var(--text-secondary); margin-top: 10px; font-size: 0.9rem;">âš ï¸ This will delete all progress!</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Game State
        const gameState = {
            inventory: {},
            totalValue: 0,
            money: 0,
            totalSpins: 0,
            luckMultiplier: 1.0,
            tradeWins: 0,
            tradeLosses: 0,
            flexedItem: null,
            christmasEvent: false,
            christmasEventEnd: null,
            battlePassTier: 0,
            battlePassXP: 0,
            achievements: {},
            enchantmentTarget: null,
            activeTrades: [],
            tradeTimer: null,
            upgrades: {
                spinSpeed: 0,
                popularity: 0,
                luckBoost: 0,
                autoSpin: 0,
                tradeInsight: 0,
                valueBoost: 0,
                craftingMastery: 0,
                enchantPower: 0,
                multiSpin: 0,
                shopDiscount: 0,
                rarityBoost: 0,
                eventLuck: 0,
                xpBoost: 0,
                sellPrice: 0,
                questSpeed: 0,
                mysteryBox: 0,
                autoFusion: 0
            },
            adminUnlocked: false,
            rebirths: 0,
            permanentLuckBoost: 1.0,
            // Collection Bonuses
            collectionBonuses: {
                discoComplete: false,
                galacticComplete: false,
                glitchComplete: false,
                fullmoonComplete: false,
                bloodmoonComplete: false,
                weatherComplete: false,
                christmasComplete: false
            },
            // Rarity Milestones
            rarityMilestones: {},
            weatherEvent: null, // 'cloudy', 'rainy', 'storming', or null
            weatherEventEnd: null,
            lastWeatherEvent: 0,
            specialEvent: null, // 'disco', 'galactic', 'glitch', 'fullmoon', 'bloodmoon', or null
            specialEventEnd: null,
            specialEventIsAdmin: false, // true if triggered by admin, false if scheduled
            questsCompleted: 0,
            dailyStreak: 0,
            weeklyQuestsCompleted: 0,
            shopPurchases: 0,
            activeQuests: [],
            completedQuests: [],
            lastQuestRefresh: 0,
            // Pity System
            pityCounter: 0,
            pityThreshold: 100,
            pityTriggered: 0,
            // Daily Login
            lastLoginDate: null,
            loginStreak: 0,
            totalLogins: 0,
            loginRewardsClaimed: [],
            // Stats Tracking
            lifetimeMoneyEarned: 0,
            lifetimeMoneySpent: 0,
            biggestTradeWin: 0,
            biggestTradeLoss: 0,
            rarityCounts: {},
            itemsFromEvents: 0,
            craftCount: 0,
            enchantSuccess: 0,
            enchantFails: 0,
            fusionCount: 0,
            // Notification Queue
            notificationQueue: [],
            isShowingNotification: false,
            settings: {
                soundEffects: true,
                showTradeNotifications: true,
                showExpiredNotifications: true,
                showSpinResults: true,
                showAchievementNotifications: true,
                showRandomEvents: true,
                showAutoSaveNotifications: false,
                showPityNotifications: true,
                showFusionNotifications: true,
                showCollectionNotifications: true,
                confirmSell: false,
                animations: true,
                compactMode: false,
                showValue: true,
                autoSaveInterval: 60
            },
            inventorySort: 'rarity',
            inventoryFilter: 'all',
            favoriteItems: [], // Protected from selling
            // Tutorial System
            tutorialStep: 0,
            tutorialComplete: false,
            tutorialSkipped: false,
            // Daily Challenges
            dailyChallenges: [],
            dailyChallengesCompleted: [],
            lastDailyChallengeReset: 0,
            // Achievement Shop
            achievementPoints: 0,
            achievementShopPurchases: {},
            // Pet System
            pets: [],
            activePet: null,
            petLevels: {},
            petXP: {},
            // Prestige System
            prestigeLevel: 0,
            prestigePoints: 0,
            prestigeShopPurchases: {}
        };
        
        const ADMIN_PASSWORD = "admin123"; // Change this to your desired password
        
        // Upgrade costs and effects
        const upgradeData = {
            spinSpeed: {
                name: 'Spin Speed',
                description: 'Reduce spin cooldown time',
                maxLevel: 25,
                baseCost: 50,
                costMultiplier: 2.5,
                effect: (level) => `${level * 10}% faster spins`
            },
            popularity: {
                name: 'Popularity',
                description: 'Increase trade frequency',
                maxLevel: 25,
                baseCost: 100,
                costMultiplier: 3,
                effect: (level) => `${level * 15}% more trades`
            },
            luckBoost: {
                name: 'Luck Boost',
                description: 'Permanently increase luck multiplier',
                maxLevel: 50,
                baseCost: 200,
                costMultiplier: 2,
                effect: (level) => `+${(level * 0.1).toFixed(1)}x luck`
            },
            autoSpin: {
                name: 'Auto Spin',
                description: 'Automatically spin every few seconds',
                maxLevel: 15,
                baseCost: 5000,
                costMultiplier: 5,
                effect: (level) => level > 0 ? `Auto-spin every ${Math.max(10 - level, 2)}s` : 'Not unlocked'
            },
            tradeInsight: {
                name: 'Trade Insight',
                description: 'See if trades are good or bad',
                maxLevel: 3,
                baseCost: 100000,
                costMultiplier: 20,
                effect: (level) => level === 0 ? 'Not unlocked' : level === 1 ? 'See trade quality' : level === 2 ? 'See exact difference' : 'See both item values'
            },
            valueBoost: {
                name: 'Value Boost',
                description: 'Increase value of all items you get',
                maxLevel: 50,
                baseCost: 1000,
                costMultiplier: 3,
                effect: (level) => `+${level * 5}% item value`
            },
            craftingMastery: {
                name: 'Crafting Mastery',
                description: 'Reduce crafting costs and increase output',
                maxLevel: 40,
                baseCost: 5000,
                costMultiplier: 4,
                effect: (level) => `${level * 5}% cheaper crafts, ${level * 2}% better results`
            },
            enchantPower: {
                name: 'Enchant Power',
                description: 'Increase chances of getting good enchantments',
                maxLevel: 50,
                baseCost: 10000,
                costMultiplier: 5,
                effect: (level) => `+${level * 10}% better enchant rolls`
            },
            multiSpin: {
                name: 'Multi Spin',
                description: 'Chance to spin multiple times at once',
                maxLevel: 20,
                baseCost: 50000,
                costMultiplier: 6,
                effect: (level) => `${level * 5}% chance for double spin`
            },
            shopDiscount: {
                name: 'Shop Discount',
                description: 'Reduce shop prices',
                maxLevel: 30,
                baseCost: 25000,
                costMultiplier: 4,
                effect: (level) => `${level * 3}% cheaper shop items`
            },
            rarityBoost: {
                name: 'Rarity Boost',
                description: 'Slightly increase chances for rarer items',
                maxLevel: 25,
                baseCost: 100000,
                costMultiplier: 8,
                effect: (level) => `${(level * 2).toFixed(1)}% better rarity rolls`
            },
            eventLuck: {
                name: 'Event Luck',
                description: 'Increase chance to get event items during events',
                maxLevel: 20,
                baseCost: 75000,
                costMultiplier: 5,
                effect: (level) => `+${level * 5}% event item chance`
            },
            xpBoost: {
                name: 'XP Boost',
                description: 'Gain more Battle Pass XP from all activities',
                maxLevel: 30,
                baseCost: 50000,
                costMultiplier: 4,
                effect: (level) => `+${level * 10}% XP gain`
            },
            sellPrice: {
                name: 'Sell Price',
                description: 'Get more money when selling items',
                maxLevel: 40,
                baseCost: 30000,
                costMultiplier: 4,
                effect: (level) => `+${level * 2}% sell price`
            },
            questSpeed: {
                name: 'Quest Master',
                description: 'Quests give more XP and progress faster',
                maxLevel: 25,
                baseCost: 60000,
                costMultiplier: 5,
                effect: (level) => `+${level * 5}% quest XP rewards`
            },
            mysteryBox: {
                name: 'Mystery Box',
                description: 'Small chance to get a random bonus item when spinning',
                maxLevel: 15,
                baseCost: 150000,
                costMultiplier: 7,
                effect: (level) => `${level * 2}% chance for bonus item`
            },
            autoFusion: {
                name: 'Auto-Fusion',
                description: 'Automatically fuse 3 items of same rarity',
                maxLevel: 1,
                baseCost: 500000,
                costMultiplier: 1,
                effect: (level) => level > 0 ? 'Auto-fuses items' : 'Not unlocked'
            }
        };
        
        // Item Rarities with 1 in 2^n progression
        const rarities = [
            { name: 'Common', chance: 1/2, color: 'var(--rarity-common)', minValue: 1, maxValue: 5 },
            { name: 'Uncommon', chance: 1/4, color: 'var(--rarity-uncommon)', minValue: 6, maxValue: 15 },
            { name: 'Rare', chance: 1/8, color: 'var(--rarity-rare)', minValue: 16, maxValue: 40 },
            { name: 'Epic', chance: 1/16, color: 'var(--rarity-epic)', minValue: 41, maxValue: 100 },
            { name: 'Legendary', chance: 1/32, color: 'var(--rarity-legendary)', minValue: 101, maxValue: 250 },
            { name: 'Mythic', chance: 1/64, color: 'var(--rarity-mythic)', minValue: 251, maxValue: 650 },
            { name: 'Exotic', chance: 1/128, color: 'var(--rarity-exotic)', minValue: 651, maxValue: 1500 },
            { name: 'Celestial', chance: 1/256, color: 'var(--rarity-celestial)', minValue: 1501, maxValue: 4000 },
            { name: 'Divine', chance: 1/512, color: '#ffd700', minValue: 4001, maxValue: 10000 },
            { name: 'Cosmic', chance: 1/1024, color: '#ff69b4', minValue: 10001, maxValue: 25000 },
            { name: 'Infinite', chance: 1/2048, color: '#ffffff', minValue: 25001, maxValue: 65000 },
            { name: 'Transcendent', chance: 1/4096, color: '#00fff2', minValue: 65001, maxValue: 150000 },
            { name: 'Ethereal', chance: 1/8192, color: '#b19cd9', minValue: 150001, maxValue: 350000 },
            { name: 'Primordial', chance: 1/65536, color: '#ff6b35', minValue: 350001, maxValue: 800000 }, // Made 4x rarer
            { name: 'Omega', chance: 1/262144, color: '#4ecdc4', minValue: 800001, maxValue: 2000000 }, // Made 8x rarer
            { name: 'Supreme', chance: 1/1048576, color: '#ffe66d', minValue: 2000001, maxValue: 5000000 }, // Made 16x rarer
            { name: 'Godlike', chance: 1/4194304, color: '#ff00ff', minValue: 5000001, maxValue: 12000000 }, // Made 32x rarer
            { name: 'Universal', chance: 1/16777216, color: '#00ffaa', minValue: 12000001, maxValue: 30000000 }, // Made 64x rarer
            { name: 'Multiversal', chance: 1/67108864, color: '#ff3399', minValue: 30000001, maxValue: 75000000 }, // Made 128x rarer
            { name: 'Omnipotent', chance: 1/1048576, color: '#ffcc00', minValue: 75000001, maxValue: 200000000 },
            { name: 'Infinite Absolute', chance: 1/2097152, color: '#ff99ff', minValue: 200000001, maxValue: 500000000 },
            { name: 'Eternal', chance: 1/4194304, color: '#66ffff', minValue: 500000001, maxValue: 1000000000 },
            { name: 'Immortal', chance: 1/8388608, color: '#ffff66', minValue: 1000000001, maxValue: 2500000000 },
            { name: 'Ascended', chance: 1/16777216, color: '#ff6666', minValue: 2500000001, maxValue: 5000000000 },
            { name: 'Transcendental', chance: 1/33554432, color: '#66ff66', minValue: 5000000001, maxValue: 10000000000 },
            { name: 'Boundless', chance: 1/67108864, color: '#6666ff', minValue: 10000000001, maxValue: 25000000000 },
            { name: 'Limitless', chance: 1/134217728, color: '#ff66ff', minValue: 25000000001, maxValue: 50000000000 },
            { name: 'Absolute', chance: 1/268435456, color: '#ffffff', minValue: 50000000001, maxValue: 100000000000 },
            { name: 'Beyond', chance: 1/536870912, color: '#ffaa00', minValue: 100000000001, maxValue: 250000000000 },
            { name: 'Incomprehensible', chance: 1/1073741824, color: '#aa00ff', minValue: 250000000001, maxValue: 500000000000 },
            { name: 'Unimaginable', chance: 1/2147483648, color: '#00aaff', minValue: 500000000001, maxValue: 1000000000000 },
            { name: 'Impossible', chance: 1/4294967296, color: '#ff0066', minValue: 1000000000001, maxValue: 10000000000000 },
            { name: 'Paradox', chance: 1/8589934592, color: '#00ff99', minValue: 10000000000001, maxValue: 50000000000000 },
            { name: 'Singularity', chance: 1/17179869184, color: '#9900ff', minValue: 50000000000001, maxValue: 100000000000000 },
            { name: 'Void', chance: 1/34359738368, color: '#000000', minValue: 100000000000001, maxValue: 500000000000000 },
            { name: 'Nothingness', chance: 1/68719476736, color: '#111111', minValue: 500000000000001, maxValue: 1000000000000000 },
            { name: 'Everything', chance: 1/137438953472, color: '#ffffff', minValue: 1000000000000001, maxValue: 5000000000000000 },
            { name: 'The End', chance: 1/274877906944, color: '#ff0000', minValue: 5000000000000001, maxValue: 10000000000000000 },
            { name: 'The Beginning', chance: 1/549755813888, color: '#00ff00', minValue: 10000000000000001, maxValue: 50000000000000000 },
            { name: 'Alpha Omega', chance: 1/1099511627776, color: '#ffff00', minValue: 50000000000000001, maxValue: 100000000000000000 },
            { name: 'True Infinity', chance: 1/2199023255552, color: '#ff00ff', minValue: 100000000000000001, maxValue: 500000000000000000 },
            { name: 'The One', chance: 1/4398046511104, color: '#ffffff', minValue: 500000000000000001, maxValue: 1000000000000000000 },
            { name: 'Primeval', chance: 1/8796093022208, color: '#8b4513', minValue: 1000000000000000001, maxValue: 5000000000000000000 },
            { name: 'Celestial Prime', chance: 1/17592186044416, color: '#4169e1', minValue: 5000000000000000001, maxValue: 10000000000000000000 },
            { name: 'Quantum', chance: 1/35184372088832, color: '#00ffff', minValue: 10000000000000000001, maxValue: 50000000000000000000 },
            { name: 'Dimensional', chance: 1/70368744177664, color: '#9370db', minValue: 50000000000000000001, maxValue: 100000000000000000000 },
            { name: 'Hyperversal', chance: 1/140737488355328, color: '#ff1493', minValue: 100000000000000000001, maxValue: 500000000000000000000 },
            { name: 'Outerversal', chance: 1/281474976710656, color: '#00ff00', minValue: 500000000000000000001, maxValue: 1000000000000000000000 },
            { name: 'Boundaryless', chance: 1/562949953421312, color: '#ff4500', minValue: 1000000000000000000001, maxValue: 5000000000000000000000 },
            { name: 'Formless', chance: 1/1125899906842624, color: '#a9a9a9', minValue: 5000000000000000000001, maxValue: 10000000000000000000000 },
            { name: 'Abstract', chance: 1/2251799813685248, color: '#dda0dd', minValue: 10000000000000000000001, maxValue: 50000000000000000000000 },
            { name: 'Conceptual', chance: 1/4503599627370496, color: '#7fffd4', minValue: 50000000000000000000001, maxValue: 100000000000000000000000 },
            { name: 'Metaphysical', chance: 1/9007199254740992, color: '#dc143c', minValue: 100000000000000000000001, maxValue: 500000000000000000000000 },
            { name: 'The Source', chance: 1/18014398509481984, color: '#ffd700', minValue: 500000000000000000000001, maxValue: 1000000000000000000000000 },
            { name: 'The Eternal', chance: 1/36028797018963968, color: '#00bfff', minValue: 1000000000000000000000001, maxValue: 5000000000000000000000000 },
            { name: 'The Absolute Infinity', chance: 1/72057594037927936, color: '#ff00ff', minValue: 5000000000000000000000001, maxValue: 10000000000000000000000000 },
            { name: 'Beyond Infinity', chance: 1/1000000000000000000000, color: '#ffffff', minValue: 10000000000000000000000001, maxValue: 100000000000000000000000000 }
        ];
        
        // Item name pools by rarity
        const itemNames = {
            'Common': {
                prefixes: ['Rusty', 'Broken', 'Dirty', 'Smelly', 'Bent', 'Cracked', 'Dull', 'Worn', 'Tattered', 'Moldy'],
                items: ['Stick', 'Rock', 'Pebble', 'Twig', 'Leaf', 'Dirt Clump', 'Old Shoe', 'Trash', 'Junk', 'Scrap']
            },
            'Uncommon': {
                prefixes: ['Basic', 'Simple', 'Plain', 'Ordinary', 'Standard', 'Regular', 'Common', 'Typical', 'Normal', 'Average'],
                items: ['Sword', 'Dagger', 'Shield', 'Helmet', 'Boots', 'Gloves', 'Ring', 'Necklace', 'Potion', 'Scroll']
            },
            'Rare': {
                prefixes: ['Polished', 'Sharp', 'Sturdy', 'Fine', 'Quality', 'Steel', 'Iron', 'Silver', 'Reinforced', 'Crafted'],
                items: ['Blade', 'Axe', 'Mace', 'Armor', 'Gauntlets', 'Amulet', 'Gem', 'Tome', 'Elixir', 'Pendant']
            },
            'Epic': {
                prefixes: ['Enchanted', 'Mystic', 'Magical', 'Powerful', 'Superior', 'Enhanced', 'Arcane', 'Blessed', 'Forged', 'Master'],
                items: ['Sword', 'Staff', 'Bow', 'Shield', 'Crown', 'Scepter', 'Orb', 'Crystal', 'Artifact', 'Relic']
            },
            'Legendary': {
                prefixes: ['Ancient', 'Legendary', 'Mythical', 'Blazing', 'Frozen', 'Thunder', 'Shadow', 'Light', 'Dragon', 'Phoenix'],
                items: ['Blade', 'Staff', 'Shield', 'Crown', 'Amulet', 'Ring', 'Orb', 'Gem', 'Rune', 'Sigil']
            },
            'Mythic': {
                prefixes: ['Divine', 'Godly', 'Celestial', 'Ethereal', 'Cosmic', 'Primordial', 'Eternal', 'Immortal', 'Supreme', 'Ultimate'],
                items: ['Sword', 'Staff', 'Crown', 'Throne', 'Scepter', 'Eye', 'Heart', 'Soul', 'Essence', 'Core']
            },
            'Exotic': {
                prefixes: ['Transcendent', 'Omnipotent', 'Infinite', 'Void', 'Astral', 'Quantum', 'Temporal', 'Reality', 'Dimensional', 'Universal'],
                items: ['Weapon', 'Armor', 'Crown', 'Throne', 'Gate', 'Key', 'Fragment', 'Shard', 'Crystal', 'Nexus']
            },
            'Celestial': {
                prefixes: ['Galaxy', 'Nebula', 'Stellar', 'Solar', 'Lunar', 'Supernova', 'Constellation', 'Comet', 'Meteor', 'Aurora'],
                items: ['Crown', 'Throne', 'Scepter', 'Orb', 'Ring', 'Blade', 'Shield', 'Aegis', 'Mantle', 'Regalia']
            },
            'Divine': {
                prefixes: ['Omni', 'Absolute', 'Perfect', 'Sacred', 'Holy', 'Sanctified', 'Consecrated', 'Hallowed', 'Blessed', 'Exalted'],
                items: ['Godhead', 'Divinity', 'Supremacy', 'Sovereignty', 'Dominion', 'Authority', 'Power', 'Glory', 'Majesty', 'Radiance']
            },
            'Cosmic': {
                prefixes: ['Multiverse', 'Omniverse', 'Hyperspace', 'Singularity', 'Infinity', 'Eternity', 'Genesis', 'Apocalypse', 'Alpha', 'Omega'],
                items: ['Construct', 'Entity', 'Phenomenon', 'Anomaly', 'Paradox', 'Singularity', 'Convergence', 'Divergence', 'Matrix', 'Nexus']
            },
            'Infinite': {
                prefixes: ['Boundless', 'Limitless', 'Endless', 'Timeless', 'Formless', 'Nameless', 'Unknowable', 'Incomprehensible', 'Ineffable', 'Absolute'],
                items: ['Existence', 'Concept', 'Idea', 'Dream', 'Truth', 'Reality', 'Universe', 'Everything', 'Nothing', 'All']
            },
            'Transcendent': {
                prefixes: ['Beyond', 'Meta', 'Hyper', 'Ultra', 'Supra', 'Trans', 'Extra', 'Over', 'Super', 'Mega'],
                items: ['Dimension', 'Plane', 'Realm', 'Sphere', 'Domain', 'Territory', 'Space', 'Void', 'Chaos', 'Order']
            },
            'Ethereal': {
                prefixes: ['Spectral', 'Phantom', 'Ghost', 'Spirit', 'Wraith', 'Shade', 'Apparition', 'Vision', 'Mirage', 'Illusion'],
                items: ['Essence', 'Soul', 'Being', 'Entity', 'Presence', 'Force', 'Energy', 'Power', 'Aura', 'Manifestation']
            },
            'Primordial': {
                prefixes: ['Primal', 'Original', 'First', 'Ancient', 'Elder', 'Prehistoric', 'Antediluvian', 'Archaic', 'Primeval', 'Primitive'],
                items: ['Chaos', 'Void', 'Creation', 'Beginning', 'Origin', 'Genesis', 'Source', 'Root', 'Foundation', 'Basis']
            },
            'Omega': {
                prefixes: ['Final', 'Last', 'Ultimate', 'Terminal', 'Conclusive', 'Ending', 'Closing', 'Finishing', 'Concluding', 'Completing'],
                items: ['Judgement', 'Verdict', 'Decree', 'Sentence', 'Destiny', 'Fate', 'End', 'Finale', 'Conclusion', 'Termination']
            },
            'Supreme': {
                prefixes: ['Paramount', 'Preeminent', 'Dominant', 'Sovereign', 'Imperial', 'Regal', 'Royal', 'Majestic', 'Grand', 'Noble'],
                items: ['Authority', 'Command', 'Control', 'Rule', 'Reign', 'Empire', 'Kingdom', 'Dynasty', 'Legacy', 'Heritage']
            },
            'Godlike': {
                prefixes: ['Deific', 'Theistic', 'Apotheosis', 'Ascended', 'Transcended', 'Enlightened', 'Awakened', 'Elevated', 'Exalted', 'Glorified'],
                items: ['Godhood', 'Divinity', 'Deity', 'Immortal', 'Eternal', 'Infinite', 'Perfect', 'Flawless', 'Pure', 'Holy']
            },
            'Universal': {
                prefixes: ['Cosmic', 'Galactic', 'Stellar', 'Planetary', 'Astronomical', 'Celestial', 'Heavenly', 'Astral', 'Spatial', 'Interstellar'],
                items: ['Cosmos', 'Universe', 'Galaxy', 'Nebula', 'Supernova', 'Quasar', 'Pulsar', 'Black Hole', 'Wormhole', 'Singularity']
            },
            'Multiversal': {
                prefixes: ['Parallel', 'Alternate', 'Divergent', 'Branching', 'Split', 'Multiple', 'Infinite', 'Countless', 'Endless', 'Limitless'],
                items: ['Timeline', 'Reality', 'Dimension', 'Universe', 'World', 'Existence', 'Possibility', 'Probability', 'Outcome', 'Future']
            },
            'Omnipotent': {
                prefixes: ['All-Powerful', 'Almighty', 'Supreme', 'Unlimited', 'Unbound', 'Unrestricted', 'Unconstrained', 'Absolute', 'Total', 'Complete'],
                items: ['Power', 'Might', 'Strength', 'Force', 'Energy', 'Potential', 'Capability', 'Capacity', 'Ability', 'Faculty']
            },
            'Absolute': {
                prefixes: ['Pure', 'True', 'Real', 'Genuine', 'Authentic', 'Perfect', 'Ideal', 'Ultimate', 'Final', 'Complete'],
                items: ['Zero', 'One', 'Everything', 'Nothing', 'All', 'None', 'Beginning', 'End', 'Alpha', 'Omega']
            },
            'Beyond': {
                prefixes: ['Post', 'After', 'Outside', 'Past', 'Exceeding', 'Surpassing', 'Transcending', 'Outstripping', 'Eclipsing', 'Outdoing'],
                items: ['Comprehension', 'Understanding', 'Logic', 'Reason', 'Thought', 'Concept', 'Idea', 'Perception', 'Cognition', 'Awareness']
            },
            'Incomprehensible': {
                prefixes: ['Unfathomable', 'Inexplicable', 'Inscrutable', 'Impenetrable', 'Mysterious', 'Cryptic', 'Enigmatic', 'Arcane', 'Esoteric', 'Obscure'],
                items: ['Mystery', 'Enigma', 'Riddle', 'Puzzle', 'Secret', 'Unknown', 'Hidden', 'Veiled', 'Shrouded', 'Occult']
            },
            'Unimaginable': {
                prefixes: ['Inconceivable', 'Unthinkable', 'Incredible', 'Fantastic', 'Miraculous', 'Supernatural', 'Otherworldly', 'Unearthly', 'Preternatural', 'Paranormal'],
                items: ['Wonder', 'Marvel', 'Miracle', 'Phenomenon', 'Spectacle', 'Vision', 'Apparition', 'Manifestation', 'Revelation', 'Epiphany']
            },
            'Impossible': {
                prefixes: ['Never', 'Cannot', 'Non', 'Un', 'Anti', 'Contra', 'Counter', 'Opposite', 'Reverse', 'Inverse'],
                items: ['Existence', 'Reality', 'Truth', 'Fact', 'Actuality', 'Certainty', 'Inevitability', 'Necessity', 'Destiny', 'Fate']
            },
            'Infinite Absolute': {
                prefixes: ['Endless', 'Eternal', 'Perpetual', 'Everlasting', 'Immortal', 'Undying', 'Deathless', 'Ageless', 'Timeless', 'Permanent'],
                items: ['Perfection', 'Flawlessness', 'Excellence', 'Superiority', 'Supremacy', 'Preeminence', 'Dominance', 'Ascendancy', 'Sovereignty', 'Mastery']
            },
            'Eternal': {
                prefixes: ['Forever', 'Always', 'Constantly', 'Continuously', 'Ceaselessly', 'Perpetually', 'Endlessly', 'Infinitely', 'Boundlessly', 'Limitlessly'],
                items: ['Moment', 'Instant', 'Second', 'Eternity', 'Infinity', 'Forever', 'Always', 'Evermore', 'Perpetuity', 'Timelessness']
            },
            'Immortal': {
                prefixes: ['Undead', 'Undying', 'Deathless', 'Imperishable', 'Indestructible', 'Invincible', 'Unconquerable', 'Invulnerable', 'Impregnable', 'Unassailable'],
                items: ['Life', 'Soul', 'Spirit', 'Essence', 'Being', 'Entity', 'Creature', 'Organism', 'Individual', 'Person']
            },
            'Ascended': {
                prefixes: ['Risen', 'Elevated', 'Uplifted', 'Exalted', 'Glorified', 'Ennobled', 'Dignified', 'Honored', 'Revered', 'Venerated'],
                items: ['Master', 'Lord', 'King', 'Emperor', 'Ruler', 'Sovereign', 'Monarch', 'Potentate', 'Overlord', 'Supreme']
            },
            'Transcendental': {
                prefixes: ['Sublime', 'Magnificent', 'Majestic', 'Grand', 'Glorious', 'Splendid', 'Resplendent', 'Radiant', 'Brilliant', 'Luminous'],
                items: ['Beauty', 'Grace', 'Elegance', 'Refinement', 'Sophistication', 'Poise', 'Dignity', 'Nobility', 'Majesty', 'Grandeur']
            },
            'Boundless': {
                prefixes: ['Infinite', 'Unlimited', 'Unrestricted', 'Unconfined', 'Unbounded', 'Unconstrained', 'Unfettered', 'Unhampered', 'Unhindered', 'Unimpeded'],
                items: ['Freedom', 'Liberty', 'Independence', 'Autonomy', 'Sovereignty', 'Self-rule', 'Self-governance', 'Self-determination', 'Free-will', 'Choice']
            },
            'Limitless': {
                prefixes: ['Measureless', 'Immeasurable', 'Incalculable', 'Innumerable', 'Countless', 'Numberless', 'Untold', 'Infinite', 'Endless', 'Boundless'],
                items: ['Potential', 'Possibility', 'Capability', 'Capacity', 'Power', 'Strength', 'Might', 'Force', 'Energy', 'Vigor']
            },
            'Paradox': {
                prefixes: ['Self-Contradicting', 'Illogical', 'Absurd', 'Contradictory', 'Inconsistent', 'Conflicting', 'Opposing', 'Clashing', 'Incompatible', 'Irreconcilable'],
                items: ['Statement', 'Truth', 'Lie', 'Question', 'Answer', 'Problem', 'Solution', 'Cause', 'Effect', 'Loop']
            },
            'Singularity': {
                prefixes: ['Unique', 'One', 'Sole', 'Single', 'Only', 'Lone', 'Solitary', 'Individual', 'Distinct', 'Separate'],
                items: ['Point', 'Moment', 'Event', 'Instance', 'Occurrence', 'Happening', 'Phenomenon', 'Incident', 'Episode', 'Case']
            },
            'Void': {
                prefixes: ['Empty', 'Vacant', 'Hollow', 'Bare', 'Blank', 'Barren', 'Desolate', 'Abandoned', 'Forsaken', 'Deserted'],
                items: ['Space', 'Abyss', 'Chasm', 'Pit', 'Hole', 'Gap', 'Cavity', 'Vacuum', 'Emptiness', 'Nothingness']
            },
            'Nothingness': {
                prefixes: ['Absent', 'Missing', 'Gone', 'Lost', 'Vanished', 'Disappeared', 'Dissolved', 'Evaporated', 'Faded', 'Erased'],
                items: ['Void', 'Nil', 'Naught', 'Zero', 'Cipher', 'Nobody', 'Nothing', 'None', 'Not', 'Never']
            },
            'Everything': {
                prefixes: ['All', 'Total', 'Whole', 'Complete', 'Entire', 'Full', 'Absolute', 'Perfect', 'Pure', 'True'],
                items: ['Universe', 'Cosmos', 'Reality', 'Existence', 'Creation', 'World', 'Life', 'Matter', 'Energy', 'Time']
            },
            'The End': {
                prefixes: ['Final', 'Last', 'Ultimate', 'Terminal', 'Concluding', 'Closing', 'Finishing', 'Ending', 'Culminating', 'Completing'],
                items: ['Moment', 'Second', 'Day', 'Hour', 'Year', 'Age', 'Era', 'Epoch', 'Period', 'Time']
            },
            'The Beginning': {
                prefixes: ['First', 'Initial', 'Original', 'Primary', 'Primal', 'Primeval', 'Primordial', 'Ancient', 'Archaic', 'Antique'],
                items: ['Spark', 'Flame', 'Light', 'Dawn', 'Sunrise', 'Genesis', 'Origin', 'Birth', 'Creation', 'Start']
            },
            'Alpha Omega': {
                prefixes: ['First-Last', 'Beginning-End', 'Start-Finish', 'Alpha-Beta', 'Top-Bottom', 'High-Low', 'Left-Right', 'Up-Down', 'In-Out', 'On-Off'],
                items: ['Duality', 'Unity', 'Pair', 'Duo', 'Couple', 'Twin', 'Double', 'Binary', 'Dichotomy', 'Contrast']
            },
            'True Infinity': {
                prefixes: ['Real', 'Genuine', 'Authentic', 'Actual', 'Veritable', 'Legitimate', 'Bona-fide', 'Honest', 'Pure', 'Absolute'],
                items: ['Endlessness', 'Eternity', 'Perpetuity', 'Everlastingness', 'Timelessness', 'Boundlessness', 'Limitlessness', 'Immensity', 'Vastness', 'Infinity']
            },
            'The One': {
                prefixes: ['Only', 'Sole', 'Single', 'Singular', 'Unique', 'Exclusive', 'Individual', 'Particular', 'Specific', 'Distinct'],
                items: ['God', 'Creator', 'Source', 'Origin', 'Beginning', 'Root', 'Foundation', 'Base', 'Core', 'Heart']
            },
            'Primeval': {
                prefixes: ['Ancient', 'Primal', 'Primordial', 'Original', 'First', 'Proto', 'Archaic', 'Prehistoric', 'Antediluvian', 'Ancestral'],
                items: ['Force', 'Power', 'Energy', 'Essence', 'Spirit', 'Will', 'Consciousness', 'Mind', 'Soul', 'Being']
            },
            'Celestial Prime': {
                prefixes: ['Supreme', 'Ultimate', 'Paramount', 'Preeminent', 'Sovereign', 'Principal', 'Chief', 'Foremost', 'Primary', 'Leading'],
                items: ['Star', 'Galaxy', 'Universe', 'Cosmos', 'Constellation', 'Nebula', 'Supernova', 'Quasar', 'Pulsar', 'Void']
            },
            'Quantum': {
                prefixes: ['Subatomic', 'Particle', 'Wave', 'Probability', 'Superposition', 'Entangled', 'Collapsed', 'Uncertain', 'Discrete', 'Planck'],
                items: ['Field', 'State', 'Foam', 'Fluctuation', 'Leap', 'Tunnel', 'Decoherence', 'Spin', 'Charge', 'String']
            },
            'Dimensional': {
                prefixes: ['Multi', 'Extra', 'Higher', 'Parallel', 'Alternate', 'Perpendicular', 'Orthogonal', 'Spatial', 'Temporal', 'Planar'],
                items: ['Dimension', 'Reality', 'Plane', 'Axis', 'Membrane', 'Brane', 'Manifold', 'Space', 'Continuum', 'Fabric']
            },
            'Hyperversal': {
                prefixes: ['Super', 'Meta', 'Ultra', 'Hyper', 'Trans', 'Beyond', 'Above', 'Transcendent', 'Superior', 'Greater'],
                items: ['Realm', 'Domain', 'Sphere', 'Zone', 'Region', 'Territory', 'Province', 'Kingdom', 'Empire', 'Cosmos']
            },
            'Outerversal': {
                prefixes: ['Outer', 'External', 'Outside', 'Beyond', 'Exterior', 'Peripheral', 'Remote', 'Distant', 'Far', 'Edge'],
                items: ['Boundary', 'Limit', 'Border', 'Frontier', 'Threshold', 'Horizon', 'Edge', 'Rim', 'Periphery', 'Margin']
            },
            'Boundaryless': {
                prefixes: ['Unlimited', 'Infinite', 'Endless', 'Limitless', 'Unbounded', 'Measureless', 'Immeasurable', 'Vast', 'Expansive', 'Infinite'],
                items: ['Expanse', 'Vastness', 'Infinity', 'Eternity', 'Forever', 'Always', 'Never-ending', 'Perpetual', 'Everlasting', 'Timeless']
            },
            'Formless': {
                prefixes: ['Shapeless', 'Amorphous', 'Undefined', 'Vague', 'Nebulous', 'Abstract', 'Intangible', 'Incorporeal', 'Immaterial', 'Ethereal'],
                items: ['Void', 'Emptiness', 'Nothingness', 'Absence', 'Negation', 'Non-being', 'Non-existence', 'Nihility', 'Vacuum', 'Null']
            },
            'Abstract': {
                prefixes: ['Conceptual', 'Theoretical', 'Ideal', 'Pure', 'Platonic', 'Universal', 'General', 'Non-concrete', 'Mental', 'Intellectual'],
                items: ['Concept', 'Idea', 'Notion', 'Thought', 'Theory', 'Principle', 'Law', 'Truth', 'Form', 'Essence']
            },
            'Conceptual': {
                prefixes: ['Fundamental', 'Essential', 'Basic', 'Elementary', 'Primary', 'Core', 'Central', 'Key', 'Crucial', 'Vital'],
                items: ['Framework', 'Structure', 'System', 'Model', 'Pattern', 'Design', 'Scheme', 'Plan', 'Blueprint', 'Template']
            },
            'Metaphysical': {
                prefixes: ['Ontological', 'Existential', 'Phenomenal', 'Noumenal', 'Transcendental', 'A-priori', 'Absolute', 'Necessary', 'Contingent', 'Essential'],
                items: ['Being', 'Existence', 'Reality', 'Actuality', 'Substance', 'Essence', 'Nature', 'Property', 'Quality', 'Attribute']
            },
            'The Source': {
                prefixes: ['Originating', 'Generative', 'Creative', 'Productive', 'Fertile', 'Fruitful', 'Prolific', 'Causative', 'Formative', 'Constitutive'],
                items: ['Wellspring', 'Fountain', 'Spring', 'Origin', 'Genesis', 'Beginning', 'Start', 'Commencement', 'Inception', 'Birth']
            },
            'The Eternal': {
                prefixes: ['Everlasting', 'Immortal', 'Undying', 'Deathless', 'Imperishable', 'Indestructible', 'Permanent', 'Lasting', 'Enduring', 'Perpetual'],
                items: ['Cycle', 'Return', 'Recurrence', 'Repetition', 'Loop', 'Circle', 'Wheel', 'Spiral', 'Helix', 'Vortex']
            },
            'The Absolute Infinity': {
                prefixes: ['Total', 'Complete', 'Whole', 'Entire', 'Full', 'Perfect', 'Pure', 'Sheer', 'Utter', 'Absolute'],
                items: ['Aleph', 'Omega-plus', 'Cardinality', 'Ordinal', 'Transfinite', 'Inaccessible', 'Mahlo', 'Measurable', 'Worldly', 'Ineffable']
            },
            'Beyond Infinity': {
                prefixes: ['Post', 'After', 'Past', 'Over', 'Above', 'Supra', 'Super', 'Hyper', 'Ultra', 'Transcending'],
                items: ['Limit', 'Bound', 'End', 'Terminus', 'Finality', 'Conclusion', 'Completion', 'Culmination', 'Apex', 'Zenith']
            }
        };
        
        // Weather Event Items
        const weatherItems = {
            cloudy: [
                { name: 'â˜ï¸ Cloud Fragment', rarity: 'Rare' },
                { name: 'â˜ï¸ Misty Essence', rarity: 'Epic' },
                { name: 'â˜ï¸ Sky Vapor', rarity: 'Legendary' },
                { name: 'â˜ï¸ Cumulus Crown', rarity: 'Mythic' },
                { name: 'â˜ï¸ Nimbus Core', rarity: 'Exotic' },
                { name: 'â˜ï¸ Stratosphere Soul', rarity: 'Celestial' }
            ],
            rainy: [
                { name: 'ðŸŒ§ï¸ Raindrop Crystal', rarity: 'Rare' },
                { name: 'ðŸŒ§ï¸ Storm Tear', rarity: 'Epic' },
                { name: 'ðŸŒ§ï¸ Aqua Prism', rarity: 'Legendary' },
                { name: 'ðŸŒ§ï¸ Deluge Diamond', rarity: 'Mythic' },
                { name: 'ðŸŒ§ï¸ Monsoon Heart', rarity: 'Exotic' },
                { name: 'ðŸŒ§ï¸ Typhoon Spirit', rarity: 'Celestial' }
            ],
            storming: [
                { name: 'â›ˆï¸ Lightning Shard', rarity: 'Epic' },
                { name: 'â›ˆï¸ Thunder Stone', rarity: 'Legendary' },
                { name: 'â›ˆï¸ Storm Bolt', rarity: 'Mythic' },
                { name: 'â›ˆï¸ Tempest Core', rarity: 'Exotic' },
                { name: 'â›ˆï¸ Hurricane Eye', rarity: 'Celestial' },
                { name: 'â›ˆï¸ Cataclysm Crown', rarity: 'Divine' }
            ]
        };
        
        // Christmas Items
        const christmasItems = [
            { name: 'ðŸŽ… Santa Hat', rarity: 'Legendary' },
            { name: 'ðŸŽ„ Christmas Tree', rarity: 'Epic' },
            { name: 'â›„ Snowman', rarity: 'Rare' },
            { name: 'ðŸŽ Gift Box', rarity: 'Uncommon' },
            { name: 'â„ï¸ Snowflake', rarity: 'Common' },
            { name: 'ðŸ”” Jingle Bell', rarity: 'Rare' },
            { name: 'ðŸ¦Œ Reindeer', rarity: 'Mythic' }
        ];
        
        // Disco Event Items (Every hour at :15-:19)
        const discoItems = [
            { name: 'ðŸª© Disco Ball', rarity: 'Epic' },
            { name: 'ðŸ•º Groove Shoes', rarity: 'Legendary' },
            { name: 'ðŸ’ƒ Dance Floor Tile', rarity: 'Rare' },
            { name: 'ðŸŽµ Funky Beat', rarity: 'Mythic' },
            { name: 'âœ¨ Glitter Bomb', rarity: 'Exotic' },
            { name: 'ðŸŽ¶ Rhythm Soul', rarity: 'Celestial' }
        ];
        
        // Galactic Event Items (Every hour at :30-:34)
        const galacticItems = [
            { name: 'ðŸŒŒ Nebula Fragment', rarity: 'Legendary' },
            { name: 'â­ Star Dust', rarity: 'Mythic' },
            { name: 'ðŸŒ  Comet Tail', rarity: 'Exotic' },
            { name: 'ðŸª Planet Core', rarity: 'Celestial' },
            { name: 'ðŸŒŸ Supernova Spark', rarity: 'Divine' },
            { name: 'ðŸ”­ Galaxy Eye', rarity: 'Cosmic' }
        ];
        
        // Glitch Event Items (Every hour at :45-:49)
        const glitchItems = [
            { name: 'âš¡ Error Code', rarity: 'Epic' },
            { name: 'ðŸ”² Corrupted Pixel', rarity: 'Legendary' },
            { name: 'ðŸ“Ÿ Digital Anomaly', rarity: 'Mythic' },
            { name: 'ðŸ’¾ Data Fragment', rarity: 'Exotic' },
            { name: 'ðŸ–¥ï¸ System Break', rarity: 'Celestial' },
            { name: 'âŒ¨ï¸ Reality Bug', rarity: 'Divine' }
        ];
        
        // Full Moon Event Items (Every 2 hours at :20-:24)
        const fullMoonItems = [
            { name: 'ðŸŒ• Moonstone', rarity: 'Legendary' },
            { name: 'ðŸº Lunar Howl', rarity: 'Mythic' },
            { name: 'ðŸŒ™ Silver Beam', rarity: 'Exotic' },
            { name: 'âœ¨ Moon Dust', rarity: 'Celestial' },
            { name: 'ðŸŒ› Crescent Blade', rarity: 'Divine' },
            { name: 'ðŸ”® Lunar Oracle', rarity: 'Cosmic' }
        ];
        
        // Blood Moon Event Items (Every 3 hours at :50-:54)
        const bloodMoonItems = [
            { name: 'ðŸ”´ Crimson Orb', rarity: 'Mythic' },
            { name: 'ðŸ©¸ Blood Crystal', rarity: 'Exotic' },
            { name: 'ðŸŒ‘ Eclipse Shard', rarity: 'Celestial' },
            { name: 'âš”ï¸ Scarlet Blade', rarity: 'Divine' },
            { name: 'ðŸ’€ Cursed Relic', rarity: 'Cosmic' },
            { name: 'ðŸ‘ï¸ Crimson Eye', rarity: 'Infinite' }
        ];
        
        // NPC Types
        const npcTypes = ['honest', 'fair', 'scammer'];
        const npcNames = ['Bob', 'Alice', 'Charlie', 'Diana', 'Eve', 'Frank', 'Grace', 'Henry', 'Ivy', 'Jack', 
                          'Karma', 'Luna', 'Max', 'Nova', 'Oscar', 'Penny', 'Quinn', 'Ruby', 'Sam', 'Tina'];
        
        // Crafting Recipes
        const recipes = [
            { name: 'Steel Sword', requires: { 'Common': 10 }, result: 'Uncommon', value: 12 },
            { name: 'Magic Staff', requires: { 'Uncommon': 8 }, result: 'Rare', value: 30 },
            { name: 'Dragon Scale', requires: { 'Rare': 7 }, result: 'Epic', value: 80 },
            { name: 'Phoenix Feather', requires: { 'Epic': 6 }, result: 'Legendary', value: 200 },
            { name: 'Void Crystal', requires: { 'Legendary': 5 }, result: 'Mythic', value: 500 },
            { name: 'Stardust Shard', requires: { 'Mythic': 5 }, result: 'Exotic', value: 1200 },
            { name: 'Celestial Fragment', requires: { 'Exotic': 4 }, result: 'Celestial', value: 3000 },
            { name: 'Divine Essence', requires: { 'Celestial': 4 }, result: 'Divine', value: 8000 },
            { name: 'Cosmic Dust', requires: { 'Divine': 4 }, result: 'Cosmic', value: 20000 },
            { name: 'Infinite Loop', requires: { 'Cosmic': 3 }, result: 'Infinite', value: 50000 },
            { name: 'Transcendence Core', requires: { 'Infinite': 3 }, result: 'Transcendent', value: 120000 },
            { name: 'Ethereal Wisp', requires: { 'Transcendent': 3 }, result: 'Ethereal', value: 280000 },
            { name: 'Primordial Spark', requires: { 'Ethereal': 3 }, result: 'Primordial', value: 650000 },
            { name: 'Omega Sigil', requires: { 'Primordial': 3 }, result: 'Omega', value: 1500000 },
            { name: 'Supreme Authority', requires: { 'Omega': 3 }, result: 'Supreme', value: 3800000 },
            { name: 'Godly Pinnacle', requires: { 'Supreme': 3 }, result: 'Godlike', value: 9500000 },
            { name: 'Universal Key', requires: { 'Godlike': 3 }, result: 'Universal', value: 23000000 },
            { name: 'Multiversal Gate', requires: { 'Universal': 3 }, result: 'Multiversal', value: 55000000 },
            { name: 'Omnipotent Crown', requires: { 'Multiversal': 4 }, result: 'Omnipotent', value: 135000000 },
            { name: 'Absolute Perfection', requires: { 'Omnipotent': 5 }, result: 'Absolute', value: 75000000000 },
            { name: 'Beyond Comprehension', requires: { 'Absolute': 4 }, result: 'Beyond', value: 180000000000 },
            { name: 'Incomprehensible Core', requires: { 'Beyond': 4 }, result: 'Incomprehensible', value: 400000000000 },
            { name: 'Unimaginable Essence', requires: { 'Incomprehensible': 4 }, result: 'Unimaginable', value: 800000000000 },
            { name: 'Impossible Artifact', requires: { 'Unimaginable': 5 }, result: 'Impossible', value: 8000000000000 }
        ];
        
        // Achievements
        const achievements = [
            { id: 'first_spin', name: 'First Spin', desc: 'Spin your first item', reward: 'Lucky Charm (+0.1 Luck)', check: () => gameState.totalSpins >= 1 },
            { id: 'spin_master', name: 'Spin Master', desc: 'Spin 100 items', reward: 'Spin Token (+0.2 Luck)', check: () => gameState.totalSpins >= 100 },
            { id: 'spin_legend', name: 'Spin Legend', desc: 'Spin 1,000 items', reward: 'Legendary Spinner (+0.5 Luck)', check: () => gameState.totalSpins >= 1000 },
            { id: 'spin_god', name: 'Spin God', desc: 'Spin 10,000 items', reward: 'Divine Spinner (+1.0 Luck)', check: () => gameState.totalSpins >= 10000 },
            { id: 'spin_master_100k', name: 'Spin Mastery', desc: 'Spin 100,000 items', reward: 'Ultimate Spinner (+2.0 Luck)', check: () => gameState.totalSpins >= 100000 },
            { id: 'millionaire', name: 'Millionaire', desc: 'Reach $1,000,000 total value', reward: 'Golden Crown', check: () => gameState.totalValue >= 1000000 },
            { id: 'multi_millionaire', name: 'Multi-Millionaire', desc: 'Reach $10,000,000 total value', reward: 'Diamond Crown', check: () => gameState.totalValue >= 10000000 },
            { id: 'mega_rich', name: 'Mega Rich', desc: 'Reach $100,000,000 total value', reward: 'Cosmic Crown', check: () => gameState.totalValue >= 100000000 },
            { id: 'ultra_rich', name: 'Ultra Rich', desc: 'Reach $1,000,000,000 total value', reward: 'Absolute Crown', check: () => gameState.totalValue >= 1000000000 },
            { id: 'legendary_pull', name: 'Legendary Pull', desc: 'Get a Legendary item', reward: 'Rare Spin Boost', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'Legendary') },
            { id: 'mythic_pull', name: 'Mythic Hunter', desc: 'Get a Mythic item', reward: 'Mythic Aura', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'Mythic') },
            { id: 'exotic_pull', name: 'Exotic Collector', desc: 'Get an Exotic item', reward: 'Exotic Badge', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'Exotic') },
            { id: 'divine_pull', name: 'Divine Blessing', desc: 'Get a Divine item', reward: 'Divine Halo', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'Divine') },
            { id: 'infinite_pull', name: 'Infinite Luck', desc: 'Get an Infinite item', reward: 'Infinite Power', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'Infinite') },
            { id: 'absolute_pull', name: 'Absolute Master', desc: 'Get an Absolute item', reward: 'Absolute Authority', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'Absolute') },
            { id: 'trade_king', name: 'Trade King', desc: 'Win 50 trades', reward: 'Trader Badge', check: () => gameState.tradeWins >= 50 },
            { id: 'trade_emperor', name: 'Trade Emperor', desc: 'Win 500 trades', reward: 'Emperor Medal', check: () => gameState.tradeWins >= 500 },
            { id: 'trade_god', name: 'Trade God', desc: 'Win 5,000 trades', reward: 'Trade Master', check: () => gameState.tradeWins >= 5000 },
            { id: 'scammed', name: 'Getting Scammed', desc: 'Lose 100 trades', reward: 'Cautious Trader', check: () => gameState.tradeLosses >= 100 },
            { id: 'crafter', name: 'Master Crafter', desc: 'Craft 10 items', reward: 'Crafting Kit', check: () => gameState.craftCount >= 10 },
            { id: 'crafter_expert', name: 'Crafting Expert', desc: 'Craft 100 items', reward: 'Expert Kit', check: () => gameState.craftCount >= 100 },
            { id: 'enchanter', name: 'Enchantment Expert', desc: 'Successfully enchant 20 items', reward: 'Enchanter Robe', check: () => gameState.enchantSuccess >= 20 },
            { id: 'enchanter_master', name: 'Enchantment Master', desc: 'Successfully enchant 100 items', reward: 'Master Robe', check: () => gameState.enchantSuccess >= 100 },
            { id: 'failed_enchants', name: 'Destruction Expert', desc: 'Fail 50 enchantments', reward: 'Phoenix Charm', check: () => gameState.enchantFails >= 50 },
            { id: 'collector', name: 'Item Collector', desc: 'Have 50 different items', reward: 'Collector Badge', check: () => Object.keys(gameState.inventory).filter(k => gameState.inventory[k].count > 0).length >= 50 },
            { id: 'collector_master', name: 'Master Collector', desc: 'Have 100 different items', reward: 'Master Badge', check: () => Object.keys(gameState.inventory).filter(k => gameState.inventory[k].count > 0).length >= 100 },
            { id: 'hoarder', name: 'Hoarder', desc: 'Have 1,000 total items', reward: 'Storage Expansion', check: () => Object.values(gameState.inventory).reduce((sum, item) => sum + item.count, 0) >= 1000 },
            { id: 'rich_trader', name: 'Rich Trader', desc: 'Have $100,000 in cash', reward: 'Cash King Title', check: () => gameState.money >= 100000 },
            { id: 'cash_king', name: 'Cash King', desc: 'Have $1,000,000 in cash', reward: 'Golden Wallet', check: () => gameState.money >= 1000000 },
            { id: 'battle_pass_hero', name: 'Battle Pass Hero', desc: 'Reach Battle Pass Tier 15', reward: 'Hero Badge', check: () => gameState.battlePassTier >= 15 },
            { id: 'battle_pass_master', name: 'Battle Pass Master', desc: 'Complete Battle Pass (Tier 25)', reward: 'Master Crown', check: () => gameState.battlePassTier >= 25 },
            { id: 'christmas_spirit', name: 'Christmas Spirit', desc: 'Get 10 Christmas items', reward: 'Santa Hat', check: () => Object.keys(gameState.inventory).filter(k => k.includes('ðŸŽ…') || k.includes('ðŸŽ„') || k.includes('â›„') || k.includes('ðŸŽ')).length >= 10 },
            { id: 'upgraded', name: 'Upgraded', desc: 'Buy any upgrade', reward: 'Upgrade Token', check: () => Object.values(gameState.upgrades).some(v => v > 0) },
            { id: 'fully_upgraded', name: 'Fully Upgraded', desc: 'Max out any upgrade', reward: 'Max Token', check: () => Object.entries(gameState.upgrades).some(([key, val]) => val >= upgradeData[key].maxLevel) },
            { id: 'first_rebirth', name: 'Reborn', desc: 'Complete your first rebirth', reward: 'Rebirth Crown', check: () => gameState.rebirths >= 1 },
            { id: 'rebirth_5', name: 'Serial Rebirther', desc: 'Complete 5 rebirths', reward: 'Eternal Crown', check: () => gameState.rebirths >= 5 },
            { id: 'rebirth_10', name: 'Rebirth Master', desc: 'Complete 10 rebirths', reward: 'Infinite Rebirth', check: () => gameState.rebirths >= 10 },
            { id: 'paradox_pull', name: 'Paradoxical', desc: 'Get a Paradox item', reward: 'Reality Breaker', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'Paradox') },
            { id: 'singularity_pull', name: 'Singularity Hunter', desc: 'Get a Singularity item', reward: 'Black Hole Core', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'Singularity') },
            { id: 'void_pull', name: 'Void Walker', desc: 'Get a Void item', reward: 'Void Cloak', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'Void') },
            { id: 'everything_pull', name: 'Universe Creator', desc: 'Get an Everything item', reward: 'Creation Power', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'Everything') },
            { id: 'theone_pull', name: 'THE ONE', desc: 'Get The One item', reward: 'EXISTENCE ITSELF', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'The One') },
            { id: 'quantum_pull', name: 'Quantum Collector', desc: 'Get a Quantum item', reward: 'Quantum Mastery', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'Quantum') },
            { id: 'hyperversal_pull', name: 'Hyperversal Explorer', desc: 'Get a Hyperversal item', reward: 'Reality Shifter', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'Hyperversal') },
            { id: 'abstract_pull', name: 'Conceptual Being', desc: 'Get an Abstract or Conceptual item', reward: 'Pure Thought', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && (item.rarity === 'Abstract' || item.rarity === 'Conceptual')) },
            { id: 'source_pull', name: 'Source Finder', desc: 'Get The Source item', reward: 'Origin Power', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'The Source') },
            { id: 'beyond_infinity_pull', name: 'BEYOND ALL', desc: 'Get Beyond Infinity item', reward: 'TRANSCENDENCE', check: () => Object.values(gameState.inventory).some(item => item.count > 0 && item.rarity === 'Beyond Infinity') },
            { id: 'ultra_rich', name: 'Quadrillionaire', desc: 'Reach $1 Quadrillion total value', reward: 'Ultimate Wealth', check: () => gameState.totalValue >= 1000000000000000 },
            { id: 'quest_master', name: 'Quest Master', desc: 'Complete 10 quests', reward: 'Quest Master Badge', check: () => gameState.questsCompleted >= 10 },
            { id: 'quest_legend', name: 'Quest Legend', desc: 'Complete 50 quests', reward: 'Quest Legend Crown', check: () => gameState.questsCompleted >= 50 },
            { id: 'daily_grinder', name: 'Daily Grinder', desc: 'Complete 5 daily quests in a row', reward: 'Dedication Medal', check: () => gameState.dailyStreak >= 5 },
            { id: 'weekly_warrior', name: 'Weekly Warrior', desc: 'Complete 10 weekly quests', reward: 'Warrior Badge', check: () => gameState.weeklyQuestsCompleted >= 10 },
            { id: 'enchant_god', name: 'Enchantment God', desc: 'Successfully enchant 500 items', reward: 'God Robe', check: () => gameState.enchantSuccess >= 500 },
            { id: 'shop_addict', name: 'Shop Addict', desc: 'Buy 100 items from shop', reward: 'VIP Card', check: () => gameState.shopPurchases >= 100 },
            { id: 'weather_chaser', name: 'Weather Chaser', desc: 'Collect 25 weather event items', reward: 'Storm Chaser Badge', check: () => Object.keys(gameState.inventory).filter(k => k.includes('â˜ï¸') || k.includes('ðŸŒ§ï¸') || k.includes('â›ˆï¸')).length >= 25 },
            { id: 'lucky_devil', name: 'Lucky Devil', desc: 'Reach 10x luck multiplier', reward: 'Devil Horns', check: () => (gameState.luckMultiplier * gameState.permanentLuckBoost) >= 10 },
            { id: 'spin_addict', name: 'Spin Addict', desc: 'Spin 1,000,000 items', reward: 'Addiction Crown', check: () => gameState.totalSpins >= 1000000 },
            { id: 'trade_tycoon', name: 'Trade Tycoon', desc: 'Win 10,000 trades', reward: 'Tycoon Medal', check: () => gameState.tradeWins >= 10000 },
            { id: 'mega_crafter', name: 'Mega Crafter', desc: 'Craft 1,000 items', reward: 'Mega Kit', check: () => gameState.craftCount >= 1000 },
            { id: 'rebirth_legend', name: 'Rebirth Legend', desc: 'Complete 25 rebirths', reward: 'Legend Status', check: () => gameState.rebirths >= 25 },
            { id: 'rebirth_god', name: 'Rebirth God', desc: 'Complete 50 rebirths', reward: 'God Status', check: () => gameState.rebirths >= 50 },
            { id: 'ultimate_collector', name: 'Ultimate Collector', desc: 'Have 250 different items', reward: 'Ultimate Badge', check: () => Object.keys(gameState.inventory).filter(k => gameState.inventory[k].count > 0).length >= 250 },
            { id: 'disco_fever', name: 'Disco Fever', desc: 'Collect 10 Disco items', reward: 'Disco King', check: () => Object.keys(gameState.inventory).filter(k => k.includes('ðŸª©') || k.includes('ðŸ•º') || k.includes('ðŸ’ƒ')).length >= 10 },
            { id: 'galactic_explorer', name: 'Galactic Explorer', desc: 'Collect 10 Galactic items', reward: 'Space Badge', check: () => Object.keys(gameState.inventory).filter(k => k.includes('ðŸŒŒ') || k.includes('â­') || k.includes('ðŸŒ ')).length >= 10 },
            { id: 'glitch_master', name: 'Glitch Master', desc: 'Collect 10 Glitch items', reward: 'Digital Crown', check: () => Object.keys(gameState.inventory).filter(k => k.includes('âš¡') || k.includes('ðŸ”²') || k.includes('ðŸ“Ÿ')).length >= 10 },
            { id: 'lunar_collector', name: 'Lunar Collector', desc: 'Collect 10 Full Moon items', reward: 'Moon Crown', check: () => Object.keys(gameState.inventory).filter(k => k.includes('ðŸŒ•') || k.includes('ðŸº') || k.includes('ðŸŒ™')).length >= 10 },
            { id: 'blood_hunter', name: 'Blood Hunter', desc: 'Collect 10 Blood Moon items', reward: 'Crimson Crown', check: () => Object.keys(gameState.inventory).filter(k => k.includes('ðŸ”´') || k.includes('ðŸ©¸') || k.includes('ðŸŒ‘')).length >= 10 },
            { id: 'event_master', name: 'Event Master', desc: 'Collect items from all 5 special events', reward: 'Event King', check: () => {
                const hasDisco = Object.keys(gameState.inventory).some(k => k.includes('ðŸª©'));
                const hasGalactic = Object.keys(gameState.inventory).some(k => k.includes('ðŸŒŒ'));
                const hasGlitch = Object.keys(gameState.inventory).some(k => k.includes('âš¡') && (k.includes('Error') || k.includes('Pixel')));
                const hasMoon = Object.keys(gameState.inventory).some(k => k.includes('ðŸŒ•'));
                const hasBlood = Object.keys(gameState.inventory).some(k => k.includes('ðŸ”´') && (k.includes('Crimson') || k.includes('Blood')));
                return hasDisco && hasGalactic && hasGlitch && hasMoon && hasBlood;
            } },
            { id: 'upgrade_addict', name: 'Upgrade Addict', desc: 'Max out 5 different upgrades', reward: 'Master Upgrader', check: () => Object.entries(gameState.upgrades).filter(([key, val]) => upgradeData[key] && val >= upgradeData[key].maxLevel).length >= 5 },
            { id: 'upgrade_legend', name: 'Upgrade Legend', desc: 'Max out 10 different upgrades', reward: 'Legendary Upgrader', check: () => Object.entries(gameState.upgrades).filter(([key, val]) => upgradeData[key] && val >= upgradeData[key].maxLevel).length >= 10 },
            { id: 'billionaire', name: 'Billionaire', desc: 'Have $1,000,000,000 in cash', reward: 'Billion Badge', check: () => gameState.money >= 1000000000 },
            { id: 'trillionaire', name: 'Trillionaire', desc: 'Have $1,000,000,000,000 in cash', reward: 'Trillion Badge', check: () => gameState.money >= 1000000000000 },
            { id: 'quest_god', name: 'Quest God', desc: 'Complete 100 quests', reward: 'Quest Deity', check: () => gameState.questsCompleted >= 100 },
            { id: 'perfect_streak', name: 'Perfect Streak', desc: 'Maintain 10 day daily quest streak', reward: 'Streak Master', check: () => gameState.dailyStreak >= 10 },
            { id: 'shop_whale', name: 'Shop Whale', desc: 'Buy 500 items from shop', reward: 'Platinum Card', check: () => gameState.shopPurchases >= 500 },
            { id: 'mega_hoarder', name: 'Mega Hoarder', desc: 'Have 10,000 total items', reward: 'Warehouse King', check: () => Object.values(gameState.inventory).reduce((sum, item) => sum + item.count, 0) >= 10000 },
            { id: 'trade_master_ultimate', name: 'Ultimate Trade Master', desc: 'Win 25,000 trades', reward: 'Trade Deity', check: () => gameState.tradeWins >= 25000 },
            { id: 'craft_deity', name: 'Crafting Deity', desc: 'Craft 5,000 items', reward: 'Divine Crafting Kit', check: () => gameState.craftCount >= 5000 },
            { id: 'enchant_deity', name: 'Enchantment Deity', desc: 'Successfully enchant 1,000 items', reward: 'Divine Robe', check: () => gameState.enchantSuccess >= 1000 },
            { id: 'super_lucky', name: 'Super Lucky', desc: 'Reach 25x luck multiplier', reward: 'Luck God', check: () => (gameState.luckMultiplier * gameState.permanentLuckBoost) >= 25 },
            { id: 'mega_spinner', name: 'Mega Spinner', desc: 'Spin 10,000,000 items', reward: 'Spinner Deity', check: () => gameState.totalSpins >= 10000000 },
            { id: 'quintillionaire', name: 'Quintillionaire', desc: 'Reach $1 Quintillion total value', reward: 'Ultimate Fortune', check: () => gameState.totalValue >= 1000000000000000000 },
            { id: 'collection_master', name: 'Collection Master', desc: 'Have 500 different items', reward: 'Master Collection Badge', check: () => Object.keys(gameState.inventory).filter(k => gameState.inventory[k].count > 0).length >= 500 },
            // Fusion Achievements
            { id: 'first_fusion', name: 'First Fusion', desc: 'Fuse your first item', reward: 'Alchemist Badge', check: () => gameState.fusionCount >= 1 },
            { id: 'fusion_adept', name: 'Fusion Adept', desc: 'Fuse 25 items', reward: 'Fusion Master', check: () => gameState.fusionCount >= 25 },
            { id: 'fusion_master', name: 'Fusion Master', desc: 'Fuse 100 items', reward: 'Grand Alchemist', check: () => gameState.fusionCount >= 100 },
            { id: 'fusion_legend', name: 'Fusion Legend', desc: 'Fuse 500 items', reward: 'Legendary Alchemist', check: () => gameState.fusionCount >= 500 },
            // Pity System Achievements
            { id: 'pity_triggered', name: 'Pity Party', desc: 'Trigger pity system for the first time', reward: 'Lucky Charm', check: () => gameState.pityTriggered >= 1 },
            { id: 'pity_master', name: 'Pity Master', desc: 'Trigger pity system 10 times', reward: 'Pity Crown', check: () => gameState.pityTriggered >= 10 },
            { id: 'pity_god', name: 'Pity God', desc: 'Trigger pity system 50 times', reward: 'Divine Pity', check: () => gameState.pityTriggered >= 50 },
            // Daily Login Achievements
            { id: 'first_login', name: 'Welcome Back', desc: 'Login for the first time', reward: 'Greeting Card', check: () => gameState.totalLogins >= 1 },
            { id: 'faithful', name: 'Faithful', desc: 'Login 30 days in a row', reward: 'Dedication Medal', check: () => gameState.loginStreak >= 30 },
            { id: 'daily_legend', name: 'Daily Legend', desc: 'Login 100 days in a row', reward: 'Legend Badge', check: () => gameState.loginStreak >= 100 },
            { id: 'lucky_seven', name: 'Lucky Seven', desc: 'Reach day 7 login reward', reward: 'Jackpot', check: () => gameState.loginStreak >= 7 },
            { id: 'login_veteran', name: 'Login Veteran', desc: 'Login 365 total times', reward: 'Veteran Badge', check: () => gameState.totalLogins >= 365 },
            // Statistics Achievements
            { id: 'statistics_nerd', name: 'Statistics Nerd', desc: 'Open the statistics tab', reward: 'Nerd Glasses', check: () => gameState.statisticsViewed === true },
            { id: 'profit_king', name: 'Profit King', desc: 'Earn $1 Billion net profit', reward: 'Business Tycoon', check: () => {
                const netProfit = (gameState.lifetimeMoneyEarned || 0) - (gameState.lifetimeMoneySpent || 0);
                return netProfit >= 1000000000;
            } },
            { id: 'big_spender', name: 'Big Spender', desc: 'Spend $100 Million total', reward: 'Spender Badge', check: () => gameState.lifetimeMoneySpent >= 100000000 },
            // Collection Achievements
            { id: 'disco_collector', name: 'Disco Collector', desc: 'Complete the Disco collection', reward: 'Disco King', check: () => gameState.collectionBonuses.discoComplete === true },
            { id: 'galactic_collector', name: 'Galactic Collector', desc: 'Complete the Galactic collection', reward: 'Space Explorer', check: () => gameState.collectionBonuses.galacticComplete === true },
            { id: 'glitch_collector', name: 'Glitch Collector', desc: 'Complete the Glitch collection', reward: 'Bug Hunter', check: () => gameState.collectionBonuses.glitchComplete === true },
            { id: 'lunar_collector', name: 'Lunar Collector', desc: 'Complete the Full Moon collection', reward: 'Moon Master', check: () => gameState.collectionBonuses.fullmoonComplete === true },
            { id: 'blood_collector', name: 'Blood Moon Collector', desc: 'Complete the Blood Moon collection', reward: 'Eclipse Lord', check: () => gameState.collectionBonuses.bloodmoonComplete === true },
            { id: 'weather_collector', name: 'Weather Collector', desc: 'Complete the Weather collection', reward: 'Storm Caller', check: () => gameState.collectionBonuses.weatherComplete === true },
            { id: 'christmas_collector', name: 'Christmas Collector', desc: 'Complete the Christmas collection', reward: 'Santa\'s Helper', check: () => gameState.collectionBonuses.christmasComplete === true },
            { id: 'master_collector', name: 'Master Collector', desc: 'Complete all 7 collections', reward: 'Grand Collector', check: () => {
                return gameState.collectionBonuses.discoComplete &&
                       gameState.collectionBonuses.galacticComplete &&
                       gameState.collectionBonuses.glitchComplete &&
                       gameState.collectionBonuses.fullmoonComplete &&
                       gameState.collectionBonuses.bloodmoonComplete &&
                       gameState.collectionBonuses.weatherComplete &&
                       gameState.collectionBonuses.christmasComplete;
            }},
            // Rarity Milestone Achievements
            { id: 'milestone_hunter', name: 'Milestone Hunter', desc: 'Unlock 10 rarity milestones', reward: 'Milestone Badge', check: () => Object.keys(gameState.rarityMilestones).length >= 10 },
            { id: 'milestone_master', name: 'Milestone Master', desc: 'Unlock 25 rarity milestones', reward: 'Master Badge', check: () => Object.keys(gameState.rarityMilestones).length >= 25 }
        ];
        
        // Battle Pass Tiers
        const battlePassTiers = [
            { tier: 1, xpRequired: 100, reward: 'Common Crate' },
            { tier: 2, xpRequired: 250, reward: 'Uncommon Crate' },
            { tier: 3, xpRequired: 500, reward: 'Rare Crate' },
            { tier: 4, xpRequired: 1000, reward: 'Epic Crate' },
            { tier: 5, xpRequired: 2000, reward: 'Legendary Crate' },
            { tier: 6, xpRequired: 3500, reward: 'Mythic Crate' },
            { tier: 7, xpRequired: 5000, reward: 'Exotic Crate' },
            { tier: 8, xpRequired: 7500, reward: 'Celestial Crate' },
            { tier: 9, xpRequired: 10000, reward: 'Divine Crate' },
            { tier: 10, xpRequired: 13000, reward: 'Cosmic Crate' },
            { tier: 11, xpRequired: 16500, reward: 'Infinite Crate' },
            { tier: 12, xpRequired: 20000, reward: 'Transcendent Crate' },
            { tier: 13, xpRequired: 25000, reward: 'Ethereal Crate' },
            { tier: 14, xpRequired: 30000, reward: 'Primordial Crate' },
            { tier: 15, xpRequired: 35000, reward: 'Omega Badge' },
            { tier: 16, xpRequired: 40000, reward: 'Supreme Crown' },
            { tier: 17, xpRequired: 45000, reward: 'Godlike Aura' },
            { tier: 18, xpRequired: 50000, reward: 'Universal Key' },
            { tier: 19, xpRequired: 55000, reward: 'Multiversal Token' },
            { tier: 20, xpRequired: 60000, reward: 'Omnipotent Seal' },
            { tier: 21, xpRequired: 70000, reward: 'Absolute Fragment' },
            { tier: 22, xpRequired: 80000, reward: 'Ultimate Power' },
            { tier: 23, xpRequired: 90000, reward: 'Perfect Essence' },
            { tier: 24, xpRequired: 100000, reward: 'True Divinity' },
            { tier: 25, xpRequired: 125000, reward: 'Eternal Glory' },
            { tier: 26, xpRequired: 150000, reward: 'Immortal Spark' },
            { tier: 27, xpRequired: 175000, reward: 'Ascended Flame' },
            { tier: 28, xpRequired: 200000, reward: 'Boundless Power' },
            { tier: 29, xpRequired: 225000, reward: 'Limitless Crate' },
            { tier: 30, xpRequired: 250000, reward: 'Zenith Crown' },
            { tier: 31, xpRequired: 275000, reward: 'Apex Medallion' },
            { tier: 32, xpRequired: 300000, reward: 'Peak Fragment' },
            { tier: 33, xpRequired: 330000, reward: 'Summit Crate' },
            { tier: 34, xpRequired: 360000, reward: 'Pinnacle Orb' },
            { tier: 35, xpRequired: 390000, reward: 'Utmost Relic' },
            { tier: 36, xpRequired: 420000, reward: 'Maximum Core' },
            { tier: 37, xpRequired: 450000, reward: 'Superlative Shard' },
            { tier: 38, xpRequired: 480000, reward: 'Paramount Essence' },
            { tier: 39, xpRequired: 510000, reward: 'Sovereign Crate' },
            { tier: 40, xpRequired: 550000, reward: 'Emperor Crown' },
            { tier: 41, xpRequired: 590000, reward: 'Tyrant Seal' },
            { tier: 42, xpRequired: 630000, reward: 'Overlord Token' },
            { tier: 43, xpRequired: 670000, reward: 'Monarch Fragment' },
            { tier: 44, xpRequired: 710000, reward: 'Ruler Crate' },
            { tier: 45, xpRequired: 750000, reward: 'Dominator Badge' },
            { tier: 46, xpRequired: 800000, reward: 'Master Key' },
            { tier: 47, xpRequired: 850000, reward: 'Champion Relic' },
            { tier: 48, xpRequired: 900000, reward: 'Victor Essence' },
            { tier: 49, xpRequired: 950000, reward: 'Conqueror Crate' },
            { tier: 50, xpRequired: 1000000, reward: 'Legend Incarnate' }
        ];
        
        // Quest System
        const questTemplates = {
            daily: [
                { id: 'spin_25', name: 'Spin 25 Items', desc: 'Spin 25 items today', target: 25, xpReward: 100, check: (progress) => progress >= 25, track: 'spins' },
                { id: 'win_5_trades', name: 'Win 5 Trades', desc: 'Win 5 trades today', target: 5, xpReward: 150, check: (progress) => progress >= 5, track: 'tradeWins' },
                { id: 'craft_3', name: 'Craft 3 Items', desc: 'Craft 3 items today', target: 3, xpReward: 120, check: (progress) => progress >= 3, track: 'crafts' },
                { id: 'earn_10k', name: 'Earn $10K', desc: 'Earn $10,000 today', target: 10000, xpReward: 100, check: (progress) => progress >= 10000, track: 'moneyEarned' },
                { id: 'enchant_2', name: 'Enchant 2 Items', desc: 'Enchant 2 items today', target: 2, xpReward: 200, check: (progress) => progress >= 2, track: 'enchants' },
                { id: 'shop_buy_5', name: 'Shop Spree', desc: 'Buy 5 items from shop', target: 5, xpReward: 150, check: (progress) => progress >= 5, track: 'shopBuys' }
            ],
            weekly: [
                { id: 'spin_500', name: 'Spin Master', desc: 'Spin 500 items this week', target: 500, xpReward: 1000, check: (progress) => progress >= 500, track: 'spins' },
                { id: 'win_50_trades', name: 'Trade Master', desc: 'Win 50 trades this week', target: 50, xpReward: 1500, check: (progress) => progress >= 50, track: 'tradeWins' },
                { id: 'craft_30', name: 'Crafting Master', desc: 'Craft 30 items this week', target: 30, xpReward: 1200, check: (progress) => progress >= 30, track: 'crafts' },
                { id: 'rare_pull', name: 'Lucky Week', desc: 'Get 10 Legendary+ items', target: 10, xpReward: 2000, check: (progress) => progress >= 10, track: 'rarePulls' },
                { id: 'enchant_15', name: 'Enchanting Week', desc: 'Enchant 15 items this week', target: 15, xpReward: 1800, check: (progress) => progress >= 15, track: 'enchants' }
            ]
        };
        
        // Initialize
        gameState.craftCount = 0;
        gameState.enchantSuccess = 0;
        gameState.enchantFails = 0;
        
        // Enchantment System
        const enchantments = {
            // Regular Enchants
            'Value Upgrade I': { tier: 1, type: 'regular', chance: 0.15, effect: { valueMultiplier: 1.25 } },
            'Value Upgrade II': { tier: 2, type: 'regular', chance: 0.12, effect: { valueMultiplier: 1.5 } },
            'Value Upgrade III': { tier: 3, type: 'regular', chance: 0.09, effect: { valueMultiplier: 2.0 } },
            'Value Upgrade IV': { tier: 4, type: 'regular', chance: 0.06, effect: { valueMultiplier: 3.0 } },
            'Value Upgrade V': { tier: 5, type: 'regular', chance: 0.03, effect: { valueMultiplier: 5.0 } },
            
            'Traders Dream I': { tier: 1, type: 'regular', chance: 0.15, effect: { tradeAttraction: 1.25 } },
            'Traders Dream II': { tier: 2, type: 'regular', chance: 0.12, effect: { tradeAttraction: 1.5 } },
            'Traders Dream III': { tier: 3, type: 'regular', chance: 0.09, effect: { tradeAttraction: 2.0 } },
            'Traders Dream IV': { tier: 4, type: 'regular', chance: 0.06, effect: { tradeAttraction: 3.0 } },
            'Traders Dream V': { tier: 5, type: 'regular', chance: 0.03, effect: { tradeAttraction: 5.0 } },
            
            'Crafting Merger I': { tier: 1, type: 'regular', chance: 0.15, effect: { craftDupeChance: 0.1 } },
            'Crafting Merger II': { tier: 2, type: 'regular', chance: 0.12, effect: { craftDupeChance: 0.15 } },
            'Crafting Merger III': { tier: 3, type: 'regular', chance: 0.09, effect: { craftDupeChance: 0.25 } },
            'Crafting Merger IV': { tier: 4, type: 'regular', chance: 0.06, effect: { craftDupeChance: 0.35 } },
            'Crafting Merger V': { tier: 5, type: 'regular', chance: 0.03, effect: { craftDupeChance: 0.5 } },
            
            'Enchanters Tool I': { tier: 1, type: 'regular', chance: 0.15, effect: { enchantLuckBoost: 1.1 } },
            'Enchanters Tool II': { tier: 2, type: 'regular', chance: 0.12, effect: { enchantLuckBoost: 1.2 } },
            'Enchanters Tool III': { tier: 3, type: 'regular', chance: 0.09, effect: { enchantLuckBoost: 1.35 } },
            'Enchanters Tool IV': { tier: 4, type: 'regular', chance: 0.06, effect: { enchantLuckBoost: 1.5 } },
            'Enchanters Tool V': { tier: 5, type: 'regular', chance: 0.03, effect: { enchantLuckBoost: 2.0 } },
            
            'Money Multi I': { tier: 1, type: 'regular', chance: 0.15, effect: { sellMultiplier: 1.2 } },
            'Money Multi II': { tier: 2, type: 'regular', chance: 0.12, effect: { sellMultiplier: 1.4 } },
            'Money Multi III': { tier: 3, type: 'regular', chance: 0.09, effect: { sellMultiplier: 1.7 } },
            'Money Multi IV': { tier: 4, type: 'regular', chance: 0.06, effect: { sellMultiplier: 2.0 } },
            'Money Multi V': { tier: 5, type: 'regular', chance: 0.03, effect: { sellMultiplier: 2.5 } },
            
            'Event Starter III': { tier: 3, type: 'regular', chance: 0.08, effect: { eventStarter: true } },
            'Event Starter IV': { tier: 4, type: 'regular', chance: 0.05, effect: { eventStarter: true } },
            'Event Starter V': { tier: 5, type: 'regular', chance: 0.02, effect: { eventStarter: true } },
            
            'Lucky Item': { tier: 1, type: 'regular', chance: 0.15, effect: { luckBoost: 0.1 } },
            
            // Godly Enchants
            'Admins Dreams V': { tier: 5, type: 'godly', chance: 0.01, effect: { valueMultiplier: 2, luckBoost: 2, tradeAttraction: 2 } },
            'Emperors Style V': { tier: 5, type: 'godly', chance: 0.01, effect: { luckBoost: 4, tradeAttraction: 3 } },
            'Endless Possibilities V': { tier: 5, type: 'godly', chance: 0.01, effect: { craftDupeChance: 0.5, enchantLuckBoost: 2 } },
            'Chaotics Thoughts IV': { tier: 4, type: 'godly', chance: 0.015, effect: { spinMultiplier: 2, scammerBlock: true } },
            'Chaotics Thoughts V': { tier: 5, type: 'godly', chance: 0.01, effect: { spinMultiplier: 2, scammerBlock: true } },
            
            // Best Enchant
            'Ruler of the World VI': { tier: 6, type: 'ultimate', chance: 0.001, effect: { 
                valueMultiplier: 5, 
                luckBoost: 5, 
                tradeAttraction: 5,
                craftDupeChance: 0.75,
                enchantLuckBoost: 3,
                sellMultiplier: 3,
                spinMultiplier: 3
            }},
            
            // Bad Enchants
            'Ditto I': { tier: 1, type: 'bad', chance: 0.1, effect: { dittoCopy: 1.1 } },
            'Ditto II': { tier: 2, type: 'bad', chance: 0.08, effect: { dittoCopy: 1.15 } },
            'Ditto III': { tier: 3, type: 'bad', chance: 0.06, effect: { dittoCopy: 1.2 } },
            'Ditto IV': { tier: 4, type: 'bad', chance: 0.04, effect: { dittoCopy: 1.25 } },
            'Ditto V': { tier: 5, type: 'bad', chance: 0.02, effect: { dittoCopy: 1.3 } },
            'Too Much Energy': { tier: 0, type: 'bad', chance: 0.05, effect: { destroy: true } },
            'Too Little Energy': { tier: 0, type: 'bad', chance: 0.05, effect: { destroy: true } }
        };
        
        // Spin Function
        // Format large numbers (1000 -> 1K, 1000000 -> 1M, etc.)
        function formatNumber(num) {
            if (num === null || num === undefined || isNaN(num)) return '0';
            
            const absNum = Math.abs(num);
            const sign = num < 0 ? '-' : '';
            
            if (absNum >= 1e63) return sign + (absNum / 1e63).toFixed(2) + 'VG';
            if (absNum >= 1e60) return sign + (absNum / 1e60).toFixed(2) + 'NOD';
            if (absNum >= 1e57) return sign + (absNum / 1e57).toFixed(2) + 'OCD';
            if (absNum >= 1e54) return sign + (absNum / 1e54).toFixed(2) + 'SPD';
            if (absNum >= 1e51) return sign + (absNum / 1e51).toFixed(2) + 'SXD';
            if (absNum >= 1e48) return sign + (absNum / 1e48).toFixed(2) + 'QID';
            if (absNum >= 1e45) return sign + (absNum / 1e45).toFixed(2) + 'QAD';
            if (absNum >= 1e42) return sign + (absNum / 1e42).toFixed(2) + 'TD';
            if (absNum >= 1e39) return sign + (absNum / 1e39).toFixed(2) + 'DD';
            if (absNum >= 1e36) return sign + (absNum / 1e36).toFixed(2) + 'UD';
            if (absNum >= 1e33) return sign + (absNum / 1e33).toFixed(2) + 'DC';
            if (absNum >= 1e30) return sign + (absNum / 1e30).toFixed(2) + 'NO';
            if (absNum >= 1e27) return sign + (absNum / 1e27).toFixed(2) + 'OC';
            if (absNum >= 1e24) return sign + (absNum / 1e24).toFixed(2) + 'SP';
            if (absNum >= 1e21) return sign + (absNum / 1e21).toFixed(2) + 'SX';
            if (absNum >= 1e18) return sign + (absNum / 1e18).toFixed(2) + 'QI';
            if (absNum >= 1e15) return sign + (absNum / 1e15).toFixed(2) + 'QA';
            if (absNum >= 1e12) return sign + (absNum / 1e12).toFixed(2) + 'T';
            if (absNum >= 1e9) return sign + (absNum / 1e9).toFixed(2) + 'B';
            if (absNum >= 1e6) return sign + (absNum / 1e6).toFixed(2) + 'M';
            if (absNum >= 1e3) return sign + (absNum / 1e3).toFixed(2) + 'K';
            return sign + absNum.toFixed(0);
        }
        
        // ===== QUEST SYSTEM =====
        
        function generateDailyQuests() {
            const dailyQuests = [...questTemplates.daily];
            // Shuffle and pick 3 random daily quests
            for (let i = dailyQuests.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [dailyQuests[i], dailyQuests[j]] = [dailyQuests[j], dailyQuests[i]];
            }
            return dailyQuests.slice(0, 3).map(q => ({...q, progress: 0, type: 'daily', completed: false}));
        }
        
        function generateWeeklyQuests() {
            const weeklyQuests = [...questTemplates.weekly];
            // Shuffle and pick 2 random weekly quests
            for (let i = weeklyQuests.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [weeklyQuests[i], weeklyQuests[j]] = [weeklyQuests[j], weeklyQuests[i]];
            }
            return weeklyQuests.slice(0, 2).map(q => ({...q, progress: 0, type: 'weekly', completed: false}));
        }
        
        function refreshQuests() {
            const now = Date.now();
            const oneDay = 24 * 60 * 60 * 1000;
            const oneWeek = 7 * oneDay;
            
            if (!gameState.lastQuestRefresh || now - gameState.lastQuestRefresh >= oneDay) {
                // Refresh daily quests
                const dailyQuests = generateDailyQuests();
                const weeklyQuests = gameState.activeQuests.filter(q => q.type === 'weekly');
                
                // Check if weekly quests need refresh
                if (!gameState.lastQuestRefresh || now - gameState.lastQuestRefresh >= oneWeek) {
                    gameState.activeQuests = [...dailyQuests, ...generateWeeklyQuests()];
                } else {
                    gameState.activeQuests = [...dailyQuests, ...weeklyQuests];
                }
                
                gameState.lastQuestRefresh = now;
                saveGame(true);
            }
        }
        
        function updateQuestProgress(trackType, amount) {
            if (!gameState.activeQuests || gameState.activeQuests.length === 0) {
                refreshQuests();
            }
            
            if (!gameState.activeQuests) return; // Safety check
            
            for (const quest of gameState.activeQuests) {
                if (quest.track === trackType && !quest.completed) {
                    quest.progress += amount;
                    
                    if (quest.check(quest.progress)) {
                        completeQuest(quest);
                    }
                }
            }
            
            updateQuestDisplay();
        }
        
        function completeQuest(quest) {
            if (quest.completed) return;
            
            quest.completed = true;
            gameState.questsCompleted = (gameState.questsCompleted || 0) + 1;
            
            // Apply quest speed upgrade
            let questXP = quest.xpReward;
            if (gameState.upgrades.questSpeed > 0) {
                questXP = Math.floor(questXP * (1 + gameState.upgrades.questSpeed * 0.05)); // +5% per level
            }
            gameState.battlePassXP += questXP;
            
            if (quest.type === 'daily') {
                gameState.dailyStreak = (gameState.dailyStreak || 0) + 1;
            } else if (quest.type === 'weekly') {
                gameState.weeklyQuestsCompleted = (gameState.weeklyQuestsCompleted || 0) + 1;
            }
            
            showNotification(`âœ… Quest Complete: ${quest.name}! +${quest.xpReward} XP`, 'var(--success)');
            updateBattlePass();
            checkAchievements();
            saveGame(true);
        }
        
        function updateQuestDisplay() {
            const container = document.getElementById('questContainer');
            if (!container) return;
            
            if (!gameState.activeQuests || gameState.activeQuests.length === 0) {
                refreshQuests();
            }
            
            container.innerHTML = '';
            
            const dailyQuests = gameState.activeQuests.filter(q => q.type === 'daily');
            const weeklyQuests = gameState.activeQuests.filter(q => q.type === 'weekly');
            
            if (dailyQuests.length > 0) {
                const dailySection = document.createElement('div');
                dailySection.innerHTML = '<h3 style="color: var(--accent-gold); margin-bottom: 10px;">ðŸ“… Daily Quests</h3>';
                dailyQuests.forEach(quest => {
                    dailySection.innerHTML += createQuestCard(quest);
                });
                container.appendChild(dailySection);
            }
            
            if (weeklyQuests.length > 0) {
                const weeklySection = document.createElement('div');
                weeklySection.innerHTML = '<h3 style="color: var(--accent-primary); margin: 20px 0 10px 0;">ðŸ“† Weekly Quests</h3>';
                weeklyQuests.forEach(quest => {
                    weeklySection.innerHTML += createQuestCard(quest);
                });
                container.appendChild(weeklySection);
            }
        }
        
        function createQuestCard(quest) {
            const target = quest.target || 1;
            const progressPercent = Math.min(100, (quest.progress / target) * 100);
            const statusColor = quest.completed ? 'var(--success)' : 'var(--accent-primary)';
            const statusText = quest.completed ? 'âœ… COMPLETED' : `${Math.floor(quest.progress)}/${target}`;
            
            return `
                <div class="recipe-card" style="border-color: ${statusColor}; opacity: ${quest.completed ? 0.7 : 1};">
                    <h4 style="color: ${statusColor};">${quest.name}</h4>
                    <p style="color: var(--text-secondary); margin: 5px 0;">${quest.desc}</p>
                    <div style="background: var(--bg-dark); border-radius: 10px; overflow: hidden; margin: 10px 0;">
                        <div style="background: ${statusColor}; height: 8px; width: ${progressPercent}%; transition: width 0.3s;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: ${statusColor};">${statusText}</span>
                        <span style="color: var(--accent-gold);">ðŸŽ ${quest.xpReward} XP</span>
                    </div>
                </div>
            `;
        }
        
        let spinCooldown = false;
        
        function spinItem() {
            if (spinCooldown) return;
            
            const btn = document.getElementById('spinBtn');
            btn.classList.add('spinning');
            btn.textContent = 'SPINNING...';
            
            // Apply speed upgrade
            const speedMultiplier = 1 - (gameState.upgrades.spinSpeed * 0.1); // 10% faster per level
            const spinTime = Math.max(500, 1000 * speedMultiplier);
            
            setTimeout(() => {
                // Apply both regular luck multiplier AND permanent luck boost
                let totalLuck = gameState.luckMultiplier * gameState.permanentLuckBoost;
                
                // Apply collection bonuses during active events
                if (gameState.specialEvent) {
                    if (gameState.specialEvent === 'disco' && gameState.collectionBonuses.discoComplete) {
                        totalLuck *= 1.1;
                    } else if (gameState.specialEvent === 'galactic' && gameState.collectionBonuses.galacticComplete) {
                        totalLuck *= 1.1;
                    } else if (gameState.specialEvent === 'glitch' && gameState.collectionBonuses.glitchComplete) {
                        totalLuck *= 1.1;
                    } else if (gameState.specialEvent === 'fullmoon' && gameState.collectionBonuses.fullmoonComplete) {
                        totalLuck *= 1.1;
                    } else if (gameState.specialEvent === 'bloodmoon' && gameState.collectionBonuses.bloodmoonComplete) {
                        totalLuck *= 1.1;
                    }
                }
                if (gameState.weatherEvent && gameState.collectionBonuses.weatherComplete) {
                    totalLuck *= 1.15;
                }
                if (gameState.christmasEvent && gameState.collectionBonuses.christmasComplete) {
                    totalLuck *= 1.15;
                }
                
                const roll = Math.random() * totalLuck;
                let selectedRarity = rarities[0];
                
                // Check for Special Event items (40% base + eventLuck upgrade)
                let specialEventChance = 0.4;
                if (gameState.upgrades.eventLuck > 0) {
                    specialEventChance += gameState.upgrades.eventLuck * 0.05; // +5% per level
                }
                if (gameState.specialEvent && Math.random() < specialEventChance) {
                    const eventItems = {
                        disco: discoItems,
                        galactic: galacticItems,
                        glitch: glitchItems,
                        fullmoon: fullMoonItems,
                        bloodmoon: bloodMoonItems
                    };
                    const specialItem = eventItems[gameState.specialEvent][Math.floor(Math.random() * eventItems[gameState.specialEvent].length)];
                    const rarity = rarities.find(r => r.name === specialItem.rarity);
                    if (rarity) {
                        selectedRarity = rarity;
                        addItemToInventory(specialItem.name, selectedRarity);
                        gameState.itemsFromEvents++;
                    }
                }
                // Check for Weather Event items (30% base + eventLuck upgrade)
                else if (gameState.weatherEvent) {
                    let weatherEventChance = 0.3;
                    if (gameState.upgrades.eventLuck > 0) {
                        weatherEventChance += gameState.upgrades.eventLuck * 0.05; // +5% per level
                    }
                    if (Math.random() < weatherEventChance) {
                        const weatherItem = weatherItems[gameState.weatherEvent][Math.floor(Math.random() * weatherItems[gameState.weatherEvent].length)];
                        const rarity = rarities.find(r => r.name === weatherItem.rarity);
                        if (rarity) {
                            selectedRarity = rarity;
                            addItemToInventory(weatherItem.name, selectedRarity);
                            gameState.itemsFromEvents++;
                        }
                    }
                }
                // Check for Christmas item
                else if (gameState.christmasEvent && Math.random() < 0.15) {
                    const christmasItem = christmasItems[Math.floor(Math.random() * christmasItems.length)];
                    const rarity = rarities.find(r => r.name === christmasItem.rarity);
                    if (rarity) {
                        selectedRarity = rarity;
                        addItemToInventory(christmasItem.name, selectedRarity);
                        gameState.itemsFromEvents++;
                    }
                } else {
                    // Check Pity System first
                    if (gameState.pityCounter >= gameState.pityThreshold) {
                        // Pity activated! Give guaranteed Legendary+ item
                        const pityRarities = rarities.filter((r, i) => i >= 4); // Legendary and above
                        selectedRarity = pityRarities[Math.floor(Math.random() * Math.min(5, pityRarities.length))];
                        const itemName = generateItemName(selectedRarity);
                        addItemToInventory(itemName, selectedRarity);
                        
                        gameState.pityCounter = 0;
                        gameState.pityTriggered++;
                        showNotification(`ðŸ€ PITY SYSTEM ACTIVATED! Guaranteed ${selectedRarity.name} item!`, selectedRarity.color);
                    } else {
                        // Regular item generation
                        let cumulativeChance = 0;
                        for (let i = rarities.length - 1; i >= 0; i--) {
                            cumulativeChance += rarities[i].chance;
                            if (roll < cumulativeChance) {
                                selectedRarity = rarities[i];
                                break;
                            }
                        }
                        
                        const itemName = generateItemName(selectedRarity);
                        addItemToInventory(itemName, selectedRarity);
                        
                        // Update pity counter
                        const rarityIndex = rarities.findIndex(r => r.name === selectedRarity.name);
                        if (rarityIndex < 4) { // Common to Epic
                            gameState.pityCounter++;
                        } else { // Legendary or higher - reset pity
                            gameState.pityCounter = 0;
                        }
                    }
                }
                
                // Check for spin multiplier from Chaotics Thoughts enchant
                let spinMultiplier = 1;
                for (const [key, item] of Object.entries(gameState.inventory)) {
                    if (item.count > 0 && item.enchantments) {
                        for (const enchantName of item.enchantments) {
                            const enchantData = enchantments[enchantName];
                            if (enchantData && enchantData.effect.spinMultiplier) {
                                spinMultiplier = Math.max(spinMultiplier, enchantData.effect.spinMultiplier);
                            }
                        }
                    }
                }
                
                gameState.totalSpins += spinMultiplier;
                if (spinMultiplier > 1) {
                    showNotification(`âš¡ Chaotics Thoughts! ${spinMultiplier}x spin count!`, 'var(--accent-gold)');
                }
                
                // Update daily challenges
                updateDailyChallengeProgress('spins', spinMultiplier);
                
                // Apply XP boost upgrade
                let baseXP = 10;
                if (gameState.upgrades.xpBoost > 0) {
                    baseXP = Math.floor(baseXP * (1 + gameState.upgrades.xpBoost * 0.1));
                }
                gameState.battlePassXP += baseXP;
                
                // Mystery Box chance - give a bonus random item
                if (gameState.upgrades.mysteryBox > 0) {
                    const mysteryChance = gameState.upgrades.mysteryBox * 0.02; // 2% per level
                    if (Math.random() < mysteryChance) {
                        const bonusRarity = rarities[Math.floor(Math.random() * Math.min(15, rarities.length))];
                        const bonusItem = generateItemName(bonusRarity);
                        addItemToInventory(bonusItem, bonusRarity);
                        showNotification(`ðŸŽ MYSTERY BOX! Bonus: ${bonusItem}!`, bonusRarity.color);
                    }
                }
                
                // Update quests
                updateQuestProgress('spins', spinMultiplier);
                
                // Track rare pulls for quests and daily challenges
                const rarityIndex = rarities.findIndex(r => r.name === selectedRarity.name);
                if (rarityIndex >= 4) { // Legendary or higher
                    updateQuestProgress('rarePulls', 1);
                    updateDailyChallengeProgress('legendaryItems', 1);
                }
                if (rarityIndex >= 2) { // Rare+
                    updateDailyChallengeProgress('rareItems', 1);
                }
                
                updateStats();
                checkAchievements();
                updateBattlePass();
                
                btn.classList.remove('spinning');
                btn.textContent = 'SPIN AGAIN!';
                
                // Random event chance
                if (Math.random() < 0.05) {
                    triggerRandomEvent();
                }
                
                // Cooldown
                spinCooldown = true;
                setTimeout(() => {
                    spinCooldown = false;
                }, spinTime);
            }, spinTime);
        }
        
        // Auto-spin functionality
        function startAutoSpin() {
            if (gameState.upgrades.autoSpin > 0) {
                const interval = Math.max(3000, (11 - gameState.upgrades.autoSpin) * 1000);
                setInterval(() => {
                    if (gameState.upgrades.autoSpin > 0 && !spinCooldown) {
                        spinItem();
                    }
                }, interval);
            }
        }
        
        // Lucky Spin Mode
        function luckySpinItem(multiplier) {
            const costs = { 2: 10000, 5: 100000, 10: 1000000 };
            const cost = costs[multiplier];
            
            if (gameState.money < cost) {
                showNotification('Not enough money for Lucky Spin!', 'var(--danger)');
                return;
            }
            
            gameState.money -= cost;
            gameState.lifetimeMoneySpent = (gameState.lifetimeMoneySpent || 0) + cost;
            
            // Temporarily boost luck
            const originalLuck = gameState.luckMultiplier;
            gameState.luckMultiplier *= multiplier;
            
            showNotification(`â­ LUCKY SPIN! ${multiplier}x Luck Boost!`, 'var(--accent-gold)');
            
            // Spin with boosted luck
            spinItem();
            
            // Restore original luck after spin completes
            setTimeout(() => {
                gameState.luckMultiplier = originalLuck;
                updateStats();
            }, 1500);
        }
        
        // Auto-Fusion System
        function checkAutoFusion() {
            if (gameState.upgrades.autoFusion === 0) return;
            
            // Find items with 3+ count of same rarity
            const rarityCounts = {};
            
            for (const [key, item] of Object.entries(gameState.inventory)) {
                if (item.count >= 3) {
                    const rarityIndex = rarities.findIndex(r => r.name === item.rarity);
                    // Don't auto-fuse max rarity
                    if (rarityIndex < rarities.length - 1) {
                        if (!rarityCounts[item.rarity]) {
                            rarityCounts[item.rarity] = [];
                        }
                        rarityCounts[item.rarity].push(key);
                    }
                }
            }
            
            // Auto-fuse if we have 3+ of same rarity
            for (const [rarity, itemKeys] of Object.entries(rarityCounts)) {
                if (itemKeys.length >= 3) {
                    // Pick first 3 items
                    const fusionItems = itemKeys.slice(0, 3);
                    const rarityIndex = rarities.findIndex(r => r.name === rarity);
                    const nextRarity = rarities[rarityIndex + 1];
                    
                    // Remove 3 items
                    fusionItems.forEach(key => {
                        const item = gameState.inventory[key];
                        if (item && item.count > 0) {
                            item.count--;
                            gameState.totalValue -= item.value;
                        }
                    });
                    
                    // Create new item
                    const newItemName = generateItemName(nextRarity);
                    addItemToInventory(newItemName, nextRarity);
                    gameState.fusionCount++;
                    
                    showNotification(`ðŸ¤– AUTO-FUSION! Created ${newItemName}!`, nextRarity.color);
                    updateStats();
                    updateInventory();
                    checkAchievements();
                    return; // Only fuse one at a time
                }
            }
        }
        
        // Collection Bonus System
        const collectionData = {
            disco: {
                name: 'Disco Collection',
                items: ['ðŸª© Disco Ball', 'ðŸ•º Groove Shoes', 'ðŸ’ƒ Dance Floor Tile', 'ðŸŽµ Funky Beat', 'âœ¨ Glitter Bomb', 'ðŸŽ¶ Rhythm Soul'],
                bonus: 'event',
                bonusAmount: 0.1,
                description: '+10% luck during Disco events'
            },
            galactic: {
                name: 'Galactic Collection',
                items: ['ðŸŒŒ Nebula Fragment', 'â­ Star Dust', 'ðŸŒ  Comet Tail', 'ðŸª Planet Core', 'ðŸŒŸ Supernova Spark', 'ðŸ”­ Galaxy Eye'],
                bonus: 'event',
                bonusAmount: 0.1,
                description: '+10% luck during Galactic events'
            },
            glitch: {
                name: 'Glitch Collection',
                items: ['âš¡ Error Code', 'ðŸ”² Corrupted Pixel', 'ðŸ“Ÿ Digital Anomaly', 'ðŸ’¾ Data Fragment', 'ðŸ–¥ï¸ System Break', 'âŒ¨ï¸ Reality Bug'],
                bonus: 'event',
                bonusAmount: 0.1,
                description: '+10% luck during Glitch events'
            },
            fullmoon: {
                name: 'Full Moon Collection',
                items: ['ðŸŒ• Moonstone', 'ðŸº Lunar Howl', 'ðŸŒ™ Silver Beam', 'âœ¨ Moon Dust', 'ðŸŒ› Crescent Blade', 'ðŸ”® Lunar Oracle'],
                bonus: 'event',
                bonusAmount: 0.1,
                description: '+10% luck during Full Moon events'
            },
            bloodmoon: {
                name: 'Blood Moon Collection',
                items: ['ðŸ”´ Crimson Orb', 'ðŸ©¸ Blood Crystal', 'ðŸŒ‘ Eclipse Shard', 'âš”ï¸ Scarlet Blade', 'ðŸ’€ Cursed Relic', 'ðŸ‘ï¸ Crimson Eye'],
                bonus: 'event',
                bonusAmount: 0.1,
                description: '+10% luck during Blood Moon events'
            },
            weather: {
                name: 'Weather Collection',
                items: ['â˜ï¸ Cloud Fragment', 'ðŸŒ§ï¸ Raindrop', 'â›ˆï¸ Lightning Bolt'],
                bonus: 'event',
                bonusAmount: 0.15,
                description: '+15% luck during Weather events'
            },
            christmas: {
                name: 'Christmas Collection',
                items: ['ðŸŽ„ Christmas Tree', 'ðŸŽ… Santa Hat', 'ðŸŽ Gift Box', 'â›„ Snowman', 'ðŸ”” Jingle Bell', 'ðŸ•¯ï¸ Candle'],
                bonus: 'event',
                bonusAmount: 0.15,
                description: '+15% luck during Christmas events'
            }
        };
        
        function checkCollectionBonuses() {
            for (const [key, collection] of Object.entries(collectionData)) {
                const hasAllItems = collection.items.every(itemName => {
                    return Object.keys(gameState.inventory).some(invKey => 
                        invKey.startsWith(itemName) && gameState.inventory[invKey].count > 0
                    );
                });
                
                if (hasAllItems && !gameState.collectionBonuses[key + 'Complete']) {
                    gameState.collectionBonuses[key + 'Complete'] = true;
                    showNotification(`ðŸ† COLLECTION COMPLETE! ${collection.name} unlocked!`, 'var(--accent-gold)');
                    checkAchievements();
                }
            }
        }
        
        // Rarity Milestone System
        const rarityMilestoneData = [
            { rarity: 'Common', milestones: [1000, 5000, 25000], bonuses: [0.005, 0.01, 0.02] }, // 2x, 2x, 2.5x harder
            { rarity: 'Uncommon', milestones: [500, 2500, 10000], bonuses: [0.005, 0.015, 0.025] }, // 2x, 2.5x, 2x harder
            { rarity: 'Rare', milestones: [250, 1000, 5000], bonuses: [0.01, 0.02, 0.04] }, // 2.5x, 2x, 2.5x harder
            { rarity: 'Epic', milestones: [100, 500, 2500], bonuses: [0.015, 0.03, 0.06] }, // 2x, 2.5x, 2.5x harder
            { rarity: 'Legendary', milestones: [50, 250, 1000], bonuses: [0.02, 0.05, 0.10] }, // 2x, 2.5x, 2x harder
            { rarity: 'Mythic', milestones: [25, 100, 500], bonuses: [0.03, 0.07, 0.15] }, // 2.5x, 2x, 2x harder
            { rarity: 'Exotic', milestones: [10, 50, 250], bonuses: [0.05, 0.10, 0.20] }, // 2x, 2x, 2.5x harder
            { rarity: 'Celestial', milestones: [5, 25, 100], bonuses: [0.07, 0.15, 0.30] }, // 1.67x, 2.5x, 2x harder
            { rarity: 'Divine', milestones: [3, 10, 50], bonuses: [0.10, 0.20, 0.40] }, // 1.5x, 2x, 2x harder
            { rarity: 'Cosmic', milestones: [2, 5, 25], bonuses: [0.15, 0.30, 0.60] }, // NEW!
            { rarity: 'Infinite', milestones: [1, 3, 15], bonuses: [0.20, 0.40, 0.80] }, // NEW!
            { rarity: 'Transcendent', milestones: [1, 2, 10], bonuses: [0.25, 0.50, 1.00] }, // NEW!
            { rarity: 'Ethereal', milestones: [1, 2, 5], bonuses: [0.30, 0.60, 1.20] }, // NEW!
            { rarity: 'Primordial', milestones: [1, 2, 3], bonuses: [0.50, 1.00, 2.00] } // NEW! Massive bonuses
        ];
        
        function checkRarityMilestones() {
            let bonusApplied = false;
            
            rarityMilestoneData.forEach(data => {
                const count = gameState.rarityCounts[data.rarity] || 0;
                
                data.milestones.forEach((milestone, index) => {
                    const milestoneKey = `${data.rarity}_${milestone}`;
                    
                    if (count >= milestone && !gameState.rarityMilestones[milestoneKey]) {
                        gameState.rarityMilestones[milestoneKey] = true;
                        gameState.permanentLuckBoost += data.bonuses[index];
                        showNotification(`â­ MILESTONE! ${count} ${data.rarity} items! +${(data.bonuses[index] * 100).toFixed(0)}% permanent luck!`, 'var(--accent-gold)');
                        bonusApplied = true;
                    }
                });
            });
            
            if (bonusApplied) {
                updateStats();
                checkAchievements();
            }
        }
        
        function updateCollectionsDisplay() {
            const bonusesGrid = document.getElementById('collectionBonusesGrid');
            const milestonesGrid = document.getElementById('rarityMilestonesGrid');
            
            if (bonusesGrid) {
                bonusesGrid.innerHTML = '';
                
                for (const [key, collection] of Object.entries(collectionData)) {
                    const hasAllItems = collection.items.every(itemName => {
                        return Object.keys(gameState.inventory).some(invKey => 
                            invKey.startsWith(itemName) && gameState.inventory[invKey].count > 0
                        );
                    });
                    
                    const ownedCount = collection.items.filter(itemName => {
                        return Object.keys(gameState.inventory).some(invKey => 
                            invKey.startsWith(itemName) && gameState.inventory[invKey].count > 0
                        );
                    }).length;
                    
                    const isComplete = gameState.collectionBonuses[key + 'Complete'];
                    
                    const card = document.createElement('div');
                    card.className = 'stat-card';
                    card.style.borderColor = isComplete ? 'var(--accent-gold)' : 'var(--bg-medium)';
                    card.innerHTML = `
                        <h3 style="color: ${isComplete ? 'var(--accent-gold)' : 'var(--text-primary)'};">
                            ${isComplete ? 'âœ…' : 'â¬œ'} ${collection.name}
                        </h3>
                        <p style="color: var(--text-secondary); margin: 10px 0;">${collection.description}</p>
                        <div class="progress-bar" style="margin: 10px 0;">
                            <div class="progress-fill" style="width: ${(ownedCount / collection.items.length) * 100}%; background: ${isComplete ? 'var(--accent-gold)' : 'var(--accent-primary)'};">
                                ${ownedCount} / ${collection.items.length}
                            </div>
                        </div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">
                            ${collection.items.map(item => {
                                const owned = Object.keys(gameState.inventory).some(invKey => 
                                    invKey.startsWith(item) && gameState.inventory[invKey].count > 0
                                );
                                return `<span style="color: ${owned ? 'var(--success)' : 'var(--text-secondary)'}">${owned ? 'âœ“' : 'âœ—'} ${item}</span>`;
                            }).join('<br>')}
                        </div>
                    `;
                    bonusesGrid.appendChild(card);
                }
            }
            
            if (milestonesGrid) {
                milestonesGrid.innerHTML = '';
                
                rarityMilestoneData.forEach(data => {
                    const count = gameState.rarityCounts[data.rarity] || 0;
                    const rarity = rarities.find(r => r.name === data.rarity);
                    
                    const card = document.createElement('div');
                    card.className = 'stat-card';
                    card.style.borderColor = rarity.color;
                    
                    const milestoneHTML = data.milestones.map((milestone, index) => {
                        const milestoneKey = `${data.rarity}_${milestone}`;
                        const achieved = gameState.rarityMilestones[milestoneKey] === true;
                        const bonus = (data.bonuses[index] * 100).toFixed(0);
                        
                        return `
                            <div style="display: flex; justify-content: space-between; padding: 5px; background: ${achieved ? 'rgba(0,255,0,0.1)' : 'var(--bg-dark)'}; margin: 3px 0; border-radius: 5px;">
                                <span style="color: ${achieved ? 'var(--success)' : 'var(--text-secondary)'}">${achieved ? 'âœ…' : 'â¬œ'} ${milestone} items</span>
                                <span style="color: var(--accent-gold);">+${bonus}% luck</span>
                            </div>
                        `;
                    }).join('');
                    
                    card.innerHTML = `
                        <h3 style="color: ${rarity.color};">${data.rarity}</h3>
                        <p style="color: var(--text-primary); font-size: 1.2rem; margin: 10px 0;">Current: ${count}</p>
                        ${milestoneHTML}
                    `;
                    milestonesGrid.appendChild(card);
                });
            }
        }
        
        function triggerUltraRareAnimation(rarityName, rarityColor, itemName, itemValue) {
            const rarityIndex = rarities.findIndex(r => r.name === rarityName);
            
            // Only trigger for Cosmic (index 9) and beyond
            if (rarityIndex < 9) return;
            
            const overlay = document.createElement('div');
            overlay.className = 'ultra-rare-overlay';
            document.body.appendChild(overlay);
            
            // Different animations based on rarity
            if (rarityName === 'Cosmic') {
                // Purple sparkles
                for (let i = 0; i < 50; i++) {
                    const sparkle = document.createElement('div');
                    sparkle.style.position = 'absolute';
                    sparkle.style.width = '10px';
                    sparkle.style.height = '10px';
                    sparkle.style.background = '#ff69b4';
                    sparkle.style.borderRadius = '50%';
                    sparkle.style.left = Math.random() * 100 + '%';
                    sparkle.style.top = Math.random() * 100 + '%';
                    sparkle.style.animation = 'cosmic-sparkle 2s ease-out';
                    sparkle.style.animationDelay = (Math.random() * 0.5) + 's';
                    overlay.appendChild(sparkle);
                }
            } else if (rarityName === 'Infinite') {
                // Rainbow waves
                for (let i = 0; i < 5; i++) {
                    const wave = document.createElement('div');
                    wave.style.position = 'absolute';
                    wave.style.width = '200%';
                    wave.style.height = '100px';
                    wave.style.top = (i * 20) + '%';
                    wave.style.background = `linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent)`;
                    wave.style.animation = 'infinite-wave 2s ease-out';
                    wave.style.animationDelay = (i * 0.2) + 's';
                    overlay.appendChild(wave);
                }
            } else if (rarityName === 'Transcendent') {
                // Cyan lightning
                const lightning = document.createElement('div');
                lightning.style.position = 'absolute';
                lightning.style.width = '100%';
                lightning.style.height = '100%';
                lightning.style.background = '#00fff2';
                lightning.style.animation = 'transcendent-lightning 1.5s ease-out';
                overlay.appendChild(lightning);
            } else if (rarityName === 'Ethereal') {
                // Ghost wisps
                for (let i = 0; i < 20; i++) {
                    const wisp = document.createElement('div');
                    wisp.style.position = 'absolute';
                    wisp.style.width = '50px';
                    wisp.style.height = '50px';
                    wisp.style.background = 'radial-gradient(circle, rgba(177,156,217,0.8), transparent)';
                    wisp.style.left = Math.random() * 100 + '%';
                    wisp.style.animation = 'ethereal-wisp 3s ease-out';
                    wisp.style.animationDelay = (Math.random() * 0.5) + 's';
                    overlay.appendChild(wisp);
                }
            } else if (rarityName === 'Primordial') {
                // ENHANCED Fire explosion with screen shake
                const explosion = document.createElement('div');
                explosion.style.position = 'absolute';
                explosion.style.width = '200px';
                explosion.style.height = '200px';
                explosion.style.left = '50%';
                explosion.style.top = '50%';
                explosion.style.transform = 'translate(-50%, -50%)';
                explosion.style.background = 'radial-gradient(circle, rgba(255,200,0,1), rgba(255,107,53,0.9), rgba(255,0,0,0.6), transparent)';
                explosion.style.animation = 'primordial-explosion 3s ease-out';
                explosion.style.boxShadow = '0 0 100px 50px rgba(255,107,53,0.8)';
                overlay.appendChild(explosion);
                
                // Fire particles
                for (let i = 0; i < 80; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '8px';
                    particle.style.height = '8px';
                    particle.style.borderRadius = '50%';
                    particle.style.background = i % 2 === 0 ? '#ff6b35' : '#ff0000';
                    particle.style.left = '50%';
                    particle.style.top = '50%';
                    particle.style.animation = 'fire-particle 2s ease-out';
                    particle.style.animationDelay = (Math.random() * 0.3) + 's';
                    overlay.appendChild(particle);
                }
                
                // Screen shake
                document.body.style.animation = 'screen-shake 0.5s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 500);
            } else if (rarityName === 'Omega') {
                // Black hole vortex
                const vortex = document.createElement('div');
                vortex.style.position = 'absolute';
                vortex.style.width = '200px';
                vortex.style.height = '200px';
                vortex.style.left = '50%';
                vortex.style.top = '50%';
                vortex.style.transform = 'translate(-50%, -50%)';
                vortex.style.background = 'radial-gradient(circle, rgba(0,0,0,0.9), rgba(78,205,196,0.6), transparent)';
                vortex.style.animation = 'omega-vortex 3s ease-out';
                vortex.style.borderRadius = '50%';
                overlay.appendChild(vortex);
            } else if (rarityName === 'Supreme') {
                // Golden rays
                for (let i = 0; i < 12; i++) {
                    const ray = document.createElement('div');
                    ray.style.position = 'absolute';
                    ray.style.width = '5px';
                    ray.style.height = '100%';
                    ray.style.left = '50%';
                    ray.style.top = '0';
                    ray.style.background = 'linear-gradient(to bottom, transparent, rgba(255,230,109,0.8), transparent)';
                    ray.style.transformOrigin = 'center top';
                    ray.style.transform = `rotate(${i * 30}deg)`;
                    ray.style.animation = 'supreme-rays 2s ease-out';
                    overlay.appendChild(ray);
                }
            } else if (rarityName === 'Godlike') {
                // Divine pillars
                for (let i = 0; i < 8; i++) {
                    const pillar = document.createElement('div');
                    pillar.style.position = 'absolute';
                    pillar.style.width = '100px';
                    pillar.style.height = '100%';
                    pillar.style.left = (i * 12.5) + '%';
                    pillar.style.background = 'linear-gradient(to top, rgba(255,0,255,0.6), rgba(255,0,255,0))';
                    pillar.style.animation = 'godlike-pillar 2.5s ease-out';
                    pillar.style.animationDelay = (i * 0.1) + 's';
                    overlay.appendChild(pillar);
                }
            } else if (rarityName === 'Universal') {
                // Galaxy spiral
                const spiral = document.createElement('div');
                spiral.style.position = 'absolute';
                spiral.style.width = '300px';
                spiral.style.height = '300px';
                spiral.style.left = '50%';
                spiral.style.top = '50%';
                spiral.style.transform = 'translate(-50%, -50%)';
                spiral.style.background = 'radial-gradient(circle, rgba(0,255,170,0.4), rgba(0,255,170,0.2), transparent)';
                spiral.style.animation = 'universal-spiral 3s ease-out';
                spiral.style.borderRadius = '50%';
                overlay.appendChild(spiral);
            } else if (rarityName === 'Multiversal') {
                // Reality fracture
                const fracture = document.createElement('div');
                fracture.style.position = 'absolute';
                fracture.style.width = '100%';
                fracture.style.height = '100%';
                fracture.style.background = 'linear-gradient(45deg, rgba(255,51,153,0.5), rgba(0,255,255,0.5))';
                fracture.style.animation = 'multiversal-fracture 2s ease-out';
                overlay.appendChild(fracture);
            } else if (rarityName === 'Omnipotent') {
                // World shake
                document.body.style.animation = 'omnipotent-shake 2s ease-out';
                setTimeout(() => {
                    document.body.style.animation = '';
                }, 2000);
                
                // Add intense light flash
                const flash = document.createElement('div');
                flash.style.position = 'absolute';
                flash.style.width = '100%';
                flash.style.height = '100%';
                flash.style.background = 'rgba(255,204,0,0.8)';
                flash.style.animation = 'multiversal-fracture 2s ease-out';
                overlay.appendChild(flash);
            } else if (rarityName === 'Infinite Absolute') {
                // Dual infinity spirals
                for (let i = 0; i < 8; i++) {
                    const spiral = document.createElement('div');
                    spiral.style.position = 'absolute';
                    spiral.style.width = '100px';
                    spiral.style.height = '100px';
                    spiral.style.left = '50%';
                    spiral.style.top = '50%';
                    spiral.style.transform = 'translate(-50%, -50%)';
                    spiral.style.background = `radial-gradient(circle, rgba(255,153,255,0.6), transparent)`;
                    spiral.style.borderRadius = '50%';
                    spiral.style.animation = 'infinite-absolute-spiral 3s ease-out';
                    spiral.style.animationDelay = (i * 0.2) + 's';
                    overlay.appendChild(spiral);
                }
            } else if (rarityName === 'Eternal') {
                // Time ripples
                for (let i = 0; i < 10; i++) {
                    const ripple = document.createElement('div');
                    ripple.style.position = 'absolute';
                    ripple.style.width = '50px';
                    ripple.style.height = '50px';
                    ripple.style.left = '50%';
                    ripple.style.top = '50%';
                    ripple.style.transform = 'translate(-50%, -50%)';
                    ripple.style.border = '3px solid rgba(102,255,255,0.7)';
                    ripple.style.borderRadius = '50%';
                    ripple.style.animation = 'eternal-ripple 3s ease-out';
                    ripple.style.animationDelay = (i * 0.3) + 's';
                    overlay.appendChild(ripple);
                }
            } else if (rarityName === 'Immortal') {
                // Phoenix rebirth
                for (let i = 0; i < 12; i++) {
                    const feather = document.createElement('div');
                    feather.style.position = 'absolute';
                    feather.style.width = '80px';
                    feather.style.height = '80px';
                    feather.style.left = '50%';
                    feather.style.top = '50%';
                    feather.style.background = `radial-gradient(circle, rgba(255,255,102,0.8), rgba(255,102,102,0.6))`;
                    feather.style.borderRadius = '50%';
                    feather.style.animation = 'immortal-rebirth 3s ease-out';
                    feather.style.animationDelay = (i * 0.15) + 's';
                    overlay.appendChild(feather);
                }
            } else if (rarityName === 'Ascended') {
                // Heavenly ascension
                for (let i = 0; i < 10; i++) {
                    const beam = document.createElement('div');
                    beam.style.position = 'absolute';
                    beam.style.width = '50px';
                    beam.style.height = '100%';
                    beam.style.left = (i * 10) + '%';
                    beam.style.background = 'linear-gradient(to top, transparent, rgba(255,102,102,0.6))';
                    beam.style.animation = 'ascended-rise 3s ease-out';
                    beam.style.animationDelay = (i * 0.1) + 's';
                    overlay.appendChild(beam);
                }
            } else if (rarityName === 'Transcendental') {
                // Reality layers
                for (let i = 0; i < 8; i++) {
                    const layer = document.createElement('div');
                    layer.style.position = 'absolute';
                    layer.style.width = '100%';
                    layer.style.height = '100%';
                    layer.style.background = `rgba(102,255,102,${0.1 + i * 0.05})`;
                    layer.style.animation = 'transcendental-layers 3s ease-out';
                    layer.style.animationDelay = (i * 0.2) + 's';
                    overlay.appendChild(layer);
                }
            } else if (rarityName === 'Boundless') {
                // Expanding boundaries
                for (let i = 0; i < 6; i++) {
                    const boundary = document.createElement('div');
                    boundary.style.position = 'absolute';
                    boundary.style.width = '200px';
                    boundary.style.height = '200px';
                    boundary.style.left = '50%';
                    boundary.style.top = '50%';
                    boundary.style.transform = 'translate(-50%, -50%)';
                    boundary.style.border = '5px solid rgba(102,102,255,0.6)';
                    boundary.style.animation = 'boundless-expand 3s ease-out';
                    boundary.style.animationDelay = (i * 0.3) + 's';
                    overlay.appendChild(boundary);
                }
            } else if (rarityName === 'Limitless') {
                // Breaking limits
                const limitBreak = document.createElement('div');
                limitBreak.style.position = 'absolute';
                limitBreak.style.width = '300px';
                limitBreak.style.height = '300px';
                limitBreak.style.left = '50%';
                limitBreak.style.top = '50%';
                limitBreak.style.transform = 'translate(-50%, -50%)';
                limitBreak.style.background = 'radial-gradient(circle, rgba(255,102,255,0.8), transparent)';
                limitBreak.style.borderRadius = '50%';
                limitBreak.style.animation = 'limitless-break 3s ease-out';
                overlay.appendChild(limitBreak);
                
                // Add 15 breaking particles
                for (let i = 0; i < 15; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '20px';
                    particle.style.height = '20px';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.top = Math.random() * 100 + '%';
                    particle.style.background = 'rgba(255,102,255,0.8)';
                    particle.style.borderRadius = '50%';
                    particle.style.animation = 'limitless-break 3s ease-out';
                    particle.style.animationDelay = (Math.random() * 0.5) + 's';
                    overlay.appendChild(particle);
                }
            } else if (rarityName === 'Absolute') {
                // Universe explosion - THE BIG ONE!
                const bigBang = document.createElement('div');
                bigBang.style.position = 'absolute';
                bigBang.style.width = '50px';
                bigBang.style.height = '50px';
                bigBang.style.left = '50%';
                bigBang.style.top = '50%';
                bigBang.style.transform = 'translate(-50%, -50%)';
                bigBang.style.background = 'radial-gradient(circle, rgba(255,255,255,1), rgba(255,215,0,0.8), rgba(255,0,255,0.6), transparent)';
                bigBang.style.animation = 'absolute-big-bang 4s ease-out';
                bigBang.style.borderRadius = '50%';
                overlay.appendChild(bigBang);
                
                // Shake everything
                document.body.style.animation = 'omnipotent-shake 4s ease-out';
                setTimeout(() => {
                    document.body.style.animation = '';
                }, 4000);
            } else if (rarityName === 'Beyond') {
                // Dimension tear
                const tear = document.createElement('div');
                tear.style.position = 'absolute';
                tear.style.width = '100%';
                tear.style.height = '100%';
                tear.style.background = 'linear-gradient(45deg, rgba(255,170,0,0.8), rgba(255,0,170,0.8))';
                tear.style.animation = 'beyond-tear 5s ease-out';
                overlay.appendChild(tear);
                
                document.body.style.animation = 'omnipotent-shake 5s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 5000);
            } else if (rarityName === 'Incomprehensible') {
                // Reality distortion
                const distortion = document.createElement('div');
                distortion.style.position = 'absolute';
                distortion.style.width = '100%';
                distortion.style.height = '100%';
                distortion.style.background = 'radial-gradient(circle, rgba(170,0,255,0.7), rgba(0,255,255,0.7))';
                distortion.style.animation = 'incomprehensible-distort 6s ease-out';
                overlay.appendChild(distortion);
                
                document.body.style.animation = 'incomprehensible-distort 6s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 6000);
            } else if (rarityName === 'Unimaginable') {
                // Kaleidoscope explosion - OPTIMIZED
                for (let i = 0; i < 10; i++) {
                    const piece = document.createElement('div');
                    piece.style.position = 'absolute';
                    piece.style.width = '80px';
                    piece.style.height = '80px';
                    piece.style.left = '50%';
                    piece.style.top = '50%';
                    piece.style.background = `hsl(${i * 36}, 100%, 50%)`;
                    piece.style.animation = 'unimaginable-kaleidoscope 7s ease-out';
                    piece.style.animationDelay = (i * 0.2) + 's';
                    piece.style.borderRadius = '50%';
                    overlay.appendChild(piece);
                }
                
                document.body.style.animation = 'omnipotent-shake 7s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 7000);
            } else if (rarityName === 'Impossible') {
                // THE ULTIMATE IMPOSSIBLE ANIMATION - OPTIMIZED
                const ultimate = document.createElement('div');
                ultimate.style.position = 'absolute';
                ultimate.style.width = '100%';
                ultimate.style.height = '100%';
                ultimate.style.background = 'radial-gradient(circle, rgba(255,0,102,1), rgba(0,170,255,1), rgba(255,255,0,1))';
                ultimate.style.animation = 'impossible-ultimate 10s ease-out';
                overlay.appendChild(ultimate);
                
                // Add 30 particles instead of 100
                for (let i = 0; i < 30; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '20px';
                    particle.style.height = '20px';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.top = Math.random() * 100 + '%';
                    particle.style.background = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    particle.style.animation = 'impossible-ultimate 10s ease-out';
                    particle.style.animationDelay = (Math.random() * 2) + 's';
                    particle.style.borderRadius = '50%';
                    overlay.appendChild(particle);
                }
                
                document.body.style.animation = 'impossible-ultimate 10s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 10000);
            } else if (rarityName === 'Paradox') {
                // Reality breaks - impossible contradictions
                const paradox = document.createElement('div');
                paradox.style.position = 'absolute';
                paradox.style.width = '100%';
                paradox.style.height = '100%';
                paradox.style.background = 'linear-gradient(45deg, rgba(0,255,153,0.8), rgba(255,0,153,0.8))';
                paradox.style.animation = 'paradox-break 12s ease-out';
                overlay.appendChild(paradox);
                
                document.body.style.animation = 'paradox-break 12s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 12000);
            } else if (rarityName === 'Singularity') {
                // Black hole collapse - everything to a point
                const singularity = document.createElement('div');
                singularity.style.position = 'absolute';
                singularity.style.width = '500px';
                singularity.style.height = '500px';
                singularity.style.left = '50%';
                singularity.style.top = '50%';
                singularity.style.transform = 'translate(-50%, -50%)';
                singularity.style.background = 'radial-gradient(circle, rgba(153,0,255,1), rgba(0,0,0,0.9))';
                singularity.style.borderRadius = '50%';
                singularity.style.animation = 'singularity-collapse 14s ease-out';
                overlay.appendChild(singularity);
                
                document.body.style.animation = 'omnipotent-shake 14s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 14000);
            } else if (rarityName === 'Void') {
                // Consume everything into darkness
                const voidDiv = document.createElement('div');
                voidDiv.style.position = 'absolute';
                voidDiv.style.width = '100%';
                voidDiv.style.height = '100%';
                voidDiv.style.animation = 'void-consume 16s ease-out';
                overlay.appendChild(voidDiv);
                
                document.body.style.animation = 'void-consume 16s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 16000);
            } else if (rarityName === 'Nothingness') {
                // Erase reality itself
                const nothing = document.createElement('div');
                nothing.style.position = 'absolute';
                nothing.style.width = '100%';
                nothing.style.height = '100%';
                nothing.style.background = 'rgba(17,17,17,0.95)';
                nothing.style.animation = 'nothingness-erase 18s ease-out';
                overlay.appendChild(nothing);
                
                document.body.style.animation = 'nothingness-erase 18s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 18000);
            } else if (rarityName === 'Everything') {
                // Create an entire universe - OPTIMIZED
                const everything = document.createElement('div');
                everything.style.position = 'absolute';
                everything.style.width = '100px';
                everything.style.height = '100px';
                everything.style.left = '50%';
                everything.style.top = '50%';
                everything.style.transform = 'translate(-50%, -50%)';
                everything.style.background = 'radial-gradient(circle, rgba(255,255,255,1), rgba(255,255,0,0.8), rgba(0,255,255,0.6))';
                everything.style.borderRadius = '50%';
                everything.style.animation = 'everything-create 20s ease-out';
                overlay.appendChild(everything);
                
                // Add 50 creation particles instead of 200
                for (let i = 0; i < 50; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '15px';
                    particle.style.height = '15px';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.top = Math.random() * 100 + '%';
                    particle.style.background = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    particle.style.animation = 'everything-create 20s ease-out';
                    particle.style.animationDelay = (Math.random() * 5) + 's';
                    particle.style.borderRadius = '50%';
                    overlay.appendChild(particle);
                }
                
                document.body.style.animation = 'omnipotent-shake 20s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 20000);
            } else if (rarityName === 'The End') {
                // Time stops
                const end = document.createElement('div');
                end.style.position = 'absolute';
                end.style.width = '100%';
                end.style.height = '100%';
                end.style.background = 'rgba(255,0,0,0.3)';
                end.style.animation = 'end-timestop 25s ease-out';
                overlay.appendChild(end);
                
                document.body.style.animation = 'end-timestop 25s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 25000);
            } else if (rarityName === 'The Beginning') {
                // The Big Bang itself
                const beginning = document.createElement('div');
                beginning.style.position = 'absolute';
                beginning.style.width = '10px';
                beginning.style.height = '10px';
                beginning.style.left = '50%';
                beginning.style.top = '50%';
                beginning.style.transform = 'translate(-50%, -50%)';
                beginning.style.background = 'radial-gradient(circle, rgba(0,255,0,1), rgba(255,255,255,0.9))';
                beginning.style.borderRadius = '50%';
                beginning.style.animation = 'beginning-bigbang 30s ease-out';
                overlay.appendChild(beginning);
                
                document.body.style.animation = 'omnipotent-shake 30s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 30000);
            } else if (rarityName === 'Alpha Omega') {
                // Start and End merge
                const alphaomega = document.createElement('div');
                alphaomega.style.position = 'absolute';
                alphaomega.style.width = '100%';
                alphaomega.style.height = '100%';
                alphaomega.style.background = 'linear-gradient(90deg, rgba(255,255,0,0.8), rgba(0,0,0,0.8))';
                alphaomega.style.animation = 'alphaomega-merge 35s ease-out';
                overlay.appendChild(alphaomega);
                
                document.body.style.animation = 'alphaomega-merge 35s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 35000);
            } else if (rarityName === 'True Infinity') {
                // Endless recursion - OPTIMIZED
                const infinity = document.createElement('div');
                infinity.style.position = 'absolute';
                infinity.style.width = '200px';
                infinity.style.height = '200px';
                infinity.style.left = '50%';
                infinity.style.top = '50%';
                infinity.style.transform = 'translate(-50%, -50%)';
                infinity.style.background = 'radial-gradient(circle, rgba(255,0,255,1), transparent)';
                infinity.style.borderRadius = '50%';
                infinity.style.animation = 'infinity-recursion 40s ease-out';
                overlay.appendChild(infinity);
                
                // Add 20 recursive circles instead of 50
                for (let i = 0; i < 20; i++) {
                    const circle = document.createElement('div');
                    circle.style.position = 'absolute';
                    circle.style.width = (200 - i * 10) + 'px';
                    circle.style.height = (200 - i * 10) + 'px';
                    circle.style.left = '50%';
                    circle.style.top = '50%';
                    circle.style.transform = 'translate(-50%, -50%)';
                    circle.style.border = '2px solid rgba(255,0,255,0.5)';
                    circle.style.borderRadius = '50%';
                    circle.style.animation = 'infinity-recursion 40s ease-out';
                    circle.style.animationDelay = (i * 0.2) + 's';
                    overlay.appendChild(circle);
                }
                
                document.body.style.animation = 'infinity-recursion 40s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 40000);
            } else if (rarityName === 'The One') {
                // EXISTENCE ITSELF - THE ULTIMATE ULTIMATE - OPTIMIZED
                const theone = document.createElement('div');
                theone.style.position = 'absolute';
                theone.style.width = '100px';
                theone.style.height = '100px';
                theone.style.left = '50%';
                theone.style.top = '50%';
                theone.style.transform = 'translate(-50%, -50%)';
                theone.style.background = 'radial-gradient(circle, white, rgba(255,255,255,0))';
                theone.style.borderRadius = '50%';
                theone.style.boxShadow = '0 0 200px 100px white';
                theone.style.animation = 'theone-existence 30s ease-out';
                overlay.appendChild(theone);
                
                // Add 30 existence particles instead of 500
                for (let i = 0; i < 30; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '25px';
                    particle.style.height = '25px';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.top = Math.random() * 100 + '%';
                    particle.style.background = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    particle.style.animation = 'theone-existence 30s ease-out';
                    particle.style.animationDelay = (Math.random() * 5) + 's';
                    particle.style.borderRadius = '50%';
                    particle.style.boxShadow = `0 0 30px 15px hsl(${Math.random() * 360}, 100%, 50%)`;
                    overlay.appendChild(particle);
                }
                
                document.body.style.animation = 'theone-existence 30s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 30000);
            }
            
            // Remove overlay after animation
            const duration = rarityName === 'The One' ? 30000 :
                           rarityName === 'True Infinity' ? 40000 :
                           rarityName === 'Alpha Omega' ? 35000 :
                           rarityName === 'The Beginning' ? 30000 :
                           rarityName === 'The End' ? 25000 :
                           rarityName === 'Everything' ? 20000 :
                           rarityName === 'Nothingness' ? 18000 :
                           rarityName === 'Void' ? 16000 :
                           rarityName === 'Singularity' ? 14000 :
                           rarityName === 'Paradox' ? 12000 :
                           rarityName === 'Impossible' ? 10000 : 
                           rarityName === 'Unimaginable' ? 7000 : 
                           rarityName === 'Incomprehensible' ? 6000 : 
                           rarityName === 'Beyond' ? 5000 : 
                           rarityName === 'Absolute' ? 4000 : 
                           rarityName === 'Limitless' ? 3000 :
                           rarityName === 'Boundless' ? 3000 :
                           rarityName === 'Transcendental' ? 3000 :
                           rarityName === 'Ascended' ? 3000 :
                           rarityName === 'Immortal' ? 3000 :
                           rarityName === 'Eternal' ? 3000 :
                           rarityName === 'Infinite Absolute' ? 3000 :
                           rarityName === 'Ethereal' || rarityName === 'Omega' || rarityName === 'Universal' ? 3000 : 
                           rarityName === 'Godlike' ? 2500 : 2000;
            
            setTimeout(() => {
                overlay.remove();
                
                // Show result display
                const rarity = rarities.find(r => r.name === rarityName);
                const chance = Math.round(1 / rarity.chance);
                
                // Special titles for ultra-rare items
                let title = 'ðŸŽ‰ ULTRA RARE PULL! ðŸŽ‰';
                if (rarityName === 'The One') {
                    title = 'â­ EXISTENCE ITSELF â­';
                } else if (rarityName === 'True Infinity') {
                    title = 'â™¾ï¸ INFINITE POWER â™¾ï¸';
                } else if (rarityName === 'Alpha Omega') {
                    title = 'ðŸŒŒ BEGINNING AND END ðŸŒŒ';
                } else if (rarityName === 'The Beginning') {
                    title = 'ðŸŒ… THE FIRST LIGHT ðŸŒ…';
                } else if (rarityName === 'The End') {
                    title = 'ðŸŒ‘ FINAL MOMENT ðŸŒ‘';
                } else if (rarityName === 'Everything') {
                    title = 'ðŸŒŸ UNIVERSE CREATED ðŸŒŸ';
                } else if (rarityName === 'Void') {
                    title = 'ðŸ–¤ CONSUMED BY VOID ðŸ–¤';
                } else if (rarityName === 'Impossible') {
                    title = 'âŒ IMPOSSIBILITY ACHIEVED âŒ';
                } else if (chance >= 1000000000) {
                    title = 'ðŸ’Ž LEGENDARY JACKPOT ðŸ’Ž';
                }
                
                const resultDiv = document.createElement('div');
                resultDiv.className = 'animation-result';
                resultDiv.style.cursor = 'pointer';
                resultDiv.innerHTML = `
                    <div class="animation-result-title">${title}</div>
                    <div class="animation-result-item" style="color: ${rarityColor};">${itemName}</div>
                    <div class="animation-result-rarity" style="color: ${rarityColor};">${rarityName}</div>
                    <div class="animation-result-chance">1 in ${formatNumber(chance)} chance</div>
                    <div style="margin-top: 20px; color: var(--accent-gold); font-size: 1.2rem;">Value: $${formatNumber(itemValue)}</div>
                    <div style="margin-top: 15px; color: var(--text-secondary); font-size: 0.9rem;">(Click to dismiss)</div>
                `;
                document.body.appendChild(resultDiv);
                
                // Click to dismiss
                const dismissResult = () => {
                    resultDiv.style.animation = 'resultFadeIn 0.5s ease-out reverse';
                    setTimeout(() => resultDiv.remove(), 500);
                };
                resultDiv.onclick = dismissResult;
            }, duration);
        }
        
        function generateItemName(rarity) {
            const namePool = itemNames[rarity.name] || itemNames['Common'];
            const prefix = namePool.prefixes[Math.floor(Math.random() * namePool.prefixes.length)];
            const item = namePool.items[Math.floor(Math.random() * namePool.items.length)];
            return `${prefix} ${item}`;
        }
        
        function addItemToInventory(name, rarity) {
            let value = Math.floor(Math.random() * (rarity.maxValue - rarity.minValue + 1)) + rarity.minValue;
            
            // Apply valueBoost upgrade
            if (gameState.upgrades.valueBoost > 0) {
                const boostMultiplier = 1 + (gameState.upgrades.valueBoost * 0.05); // 5% per level
                value = Math.floor(value * boostMultiplier);
            }
            
            const fullName = `${name} (${rarity.name})`;
            
            if (gameState.inventory[fullName]) {
                gameState.inventory[fullName].count++;
            } else {
                gameState.inventory[fullName] = {
                    name: name,
                    rarity: rarity.name,
                    color: rarity.color,
                    value: value,
                    count: 1
                };
            }
            
            gameState.totalValue += value;
            
            // Check for auto-fusion
            checkAutoFusion();
            
            // Check collection bonuses and rarity milestones
            checkCollectionBonuses();
            checkRarityMilestones();
            
            // Trigger ultra-rare animation for Cosmic and beyond (1 in 1024+)
            const rarityIndex = rarities.findIndex(r => r.name === rarity.name);
            if (rarityIndex >= 9) { // Index 9 is Cosmic
                triggerUltraRareAnimation(rarity.name, rarity.color, name, value);
                playSound('ultra_rare');
            } else if (rarityIndex >= 4) { // Legendary+
                playSound('rare');
            } else {
                playSound('spin');
            }
            
            // Display result
            const resultDiv = document.getElementById('resultDisplay');
            resultDiv.innerHTML = `
                <div class="item-display" style="background: ${rarity.color}; color: ${rarity.name === 'Common' ? 'black' : 'white'};">
                    ${fullName}
                </div>
                <div style="color: var(--accent-gold); font-size: 1.2rem; margin-top: 10px;">
                    Value: $${formatNumber(value)}
                </div>
                <div style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 5px;">
                    Chance: 1 in ${formatNumber(Math.round(1/rarities.find(r => r.name === rarity.name).chance))}
                </div>
            `;
            
            showNotification(`You got: ${fullName}!`, rarity.color);
        }
        
        function updateStats() {
            document.getElementById('money').textContent = '$' + formatNumber(gameState.money);
            document.getElementById('totalValue').textContent = '$' + formatNumber(gameState.totalValue);
            document.getElementById('totalSpins').textContent = formatNumber(gameState.totalSpins);
            const combinedLuck = gameState.luckMultiplier * gameState.permanentLuckBoost;
            document.getElementById('luckMultiplier').textContent = combinedLuck.toFixed(1) + 'x';
            document.getElementById('tradeWins').textContent = formatNumber(gameState.tradeWins);
            updatePityDisplay();
            
            // Update boss display if on bosses tab (so buttons update when money changes)
            const bossesTab = document.getElementById('bosses');
            if (bossesTab && bossesTab.classList.contains('active')) {
                updateBossesDisplay();
            }
            
            // Update artifacts display if on artifacts tab
            const artifactsTab = document.getElementById('artifacts');
            if (artifactsTab && artifactsTab.classList.contains('active')) {
                updateArtifactsDisplay();
            }
        }
        
        function updatePityDisplay() {
            const counter = document.getElementById('pityCounterDisplay');
            const progressBar = document.getElementById('pityProgressBar');
            
            if (counter && progressBar) {
                const pityCount = gameState.pityCounter || 0;
                const pityThreshold = gameState.pityThreshold || 100;
                const pityPercent = Math.min(100, (pityCount / pityThreshold) * 100);
                
                counter.textContent = `${pityCount} / ${pityThreshold}`;
                progressBar.style.width = `${pityPercent}%`;
                progressBar.innerHTML = `<span style="font-size: 0.85rem; font-weight: bold;">${pityPercent.toFixed(0)}%</span>`;
                
                // Change color as it gets closer to pity
                if (pityPercent >= 90) {
                    progressBar.style.background = 'linear-gradient(90deg, #ff0000 0%, #ff6600 100%)';
                } else if (pityPercent >= 70) {
                    progressBar.style.background = 'linear-gradient(90deg, #ff6600 0%, var(--accent-gold) 100%)';
                } else {
                    progressBar.style.background = 'linear-gradient(90deg, var(--warning) 0%, var(--accent-gold) 100%)';
                }
            }
        }
        
        function updateInventory() {
            const grid = document.getElementById('inventoryGrid');
            grid.innerHTML = '';
            
            // Get and sort/filter inventory
            let items = Object.entries(gameState.inventory).filter(([key, item]) => item.count > 0);
            
            // Apply filter
            const filterType = gameState.inventoryFilter || 'all';
            if (filterType !== 'all') {
                items = items.filter(([key, item]) => {
                    // Rarity filters
                    if (filterType === 'common') return item.rarity === 'Common';
                    if (filterType === 'uncommon') return item.rarity === 'Uncommon';
                    if (filterType === 'rare') return item.rarity === 'Rare';
                    if (filterType === 'epic') return item.rarity === 'Epic';
                    if (filterType === 'legendary') return item.rarity === 'Legendary';
                    if (filterType === 'mythic') return item.rarity === 'Mythic';
                    if (filterType === 'exotic') return item.rarity === 'Exotic';
                    if (filterType === 'celestial') return item.rarity === 'Celestial';
                    if (filterType === 'divine') return item.rarity === 'Divine';
                    if (filterType === 'cosmic') return item.rarity === 'Cosmic';
                    if (filterType === 'infinite') return item.rarity === 'Infinite';
                    if (filterType === 'transcendent') return item.rarity === 'Transcendent';
                    if (filterType === 'ethereal') return item.rarity === 'Ethereal';
                    if (filterType === 'primordial') {
                        // Primordial+ includes Primordial and all higher rarities
                        const rarityIndex = rarities.findIndex(r => r.name === item.rarity);
                        return rarityIndex >= 13; // Primordial is index 13
                    }
                    
                    // Type filters
                    if (filterType === 'event') {
                        return key.includes('ðŸª©') || key.includes('ðŸŒŒ') || key.includes('âš¡') || 
                               key.includes('ðŸŒ•') || key.includes('ðŸ”´') || key.includes('â˜ï¸') || 
                               key.includes('ðŸŒ§ï¸') || key.includes('â›ˆï¸') || key.includes('ðŸŽ„');
                    } else if (filterType === 'christmas') {
                        return key.includes('ðŸŽ„') || key.includes('ðŸŽ…') || key.includes('â›„') || 
                               key.includes('ðŸŽ') || key.includes('ðŸ””') || key.includes('ðŸ•¯ï¸');
                    } else if (filterType === 'disco') {
                        return key.includes('ðŸª©') || key.includes('ðŸ•º') || key.includes('ðŸ’ƒ') || 
                               key.includes('ðŸŽµ') || key.includes('âœ¨') || key.includes('ðŸŽ¶');
                    } else if (filterType === 'galactic') {
                        return key.includes('ðŸŒŒ') || key.includes('â­') || key.includes('ðŸŒ ') || 
                               key.includes('ðŸª') || key.includes('ðŸŒŸ') || key.includes('ðŸ”­');
                    } else if (filterType === 'glitch') {
                        return key.includes('âš¡') || key.includes('ðŸ”²') || key.includes('ðŸ“Ÿ') || 
                               key.includes('ðŸ’¾') || key.includes('ðŸ–¥ï¸') || key.includes('âŒ¨ï¸');
                    } else if (filterType === 'fullmoon') {
                        return key.includes('ðŸŒ•') || key.includes('ðŸº') || key.includes('ðŸŒ™') || 
                               key.includes('ðŸŒ›') || key.includes('ðŸ”®');
                    } else if (filterType === 'bloodmoon') {
                        return key.includes('ðŸ”´') || key.includes('ðŸ©¸') || key.includes('ðŸŒ‘') || 
                               key.includes('âš”ï¸') || key.includes('ðŸ’€') || key.includes('ðŸ‘ï¸');
                    } else if (filterType === 'weather') {
                        return key.includes('â˜ï¸') || key.includes('ðŸŒ§ï¸') || key.includes('â›ˆï¸');
                    } else if (filterType === 'battlepass') {
                        // Battle pass items don't have specific markers, so this shows all for now
                        return true;
                    }
                    return true;
                });
            }
            
            // Apply sort
            const sortType = gameState.inventorySort || 'rarity';
            if (sortType === 'rarity') {
                items.sort((a, b) => {
                    const rarityA = rarities.findIndex(r => r.name === a[1].rarity);
                    const rarityB = rarities.findIndex(r => r.name === b[1].rarity);
                    return rarityB - rarityA; // Higher rarity first
                });
            } else if (sortType === 'value') {
                items.sort((a, b) => b[1].value - a[1].value); // Higher value first
            } else if (sortType === 'count') {
                items.sort((a, b) => b[1].count - a[1].count); // Higher count first
            }
            
            // Display items
            for (const [key, item] of items) {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'inventory-item' + (gameState.flexedItem === key ? ' flexed' : '');
                itemDiv.style.borderColor = item.color;
                itemDiv.onclick = () => flexItem(key);
                itemDiv.oncontextmenu = (e) => {
                    e.preventDefault();
                    sellItem(key);
                };
                
                // Mobile long-press to sell
                let pressTimer;
                itemDiv.ontouchstart = (e) => {
                    pressTimer = setTimeout(() => {
                        sellItem(key);
                        navigator.vibrate && navigator.vibrate(50); // Haptic feedback
                    }, 500); // 500ms long press
                };
                itemDiv.ontouchend = () => {
                    clearTimeout(pressTimer);
                };
                itemDiv.ontouchmove = () => {
                    clearTimeout(pressTimer);
                };
                
                // Build detailed tooltip for hover
                let tooltipText = `${item.name} (${item.rarity})\nCount: ${item.count}\nValue: $${formatNumber(item.value)} each`;
                if (item.enchantments && item.enchantments.length > 0) {
                    tooltipText += `\nEnchantments: ${item.enchantments.join(', ')}`;
                }
                tooltipText += `\nTotal Value: $${formatNumber(item.value * item.count)}`;
                tooltipText += `\n\nLeft-click: Flex | Right-click: Sell`;
                
                itemDiv.title = tooltipText;
                
                // Show enchantments if present
                let enchantDisplay = '';
                if (item.enchantments && item.enchantments.length > 0) {
                    const enchantList = item.enchantments.map(e => {
                        const enchantData = enchantments[e];
                        const color = enchantData.type === 'ultimate' ? '#ff00ff' : 
                                     enchantData.type === 'godly' ? 'var(--accent-gold)' : 
                                     enchantData.type === 'bad' ? 'var(--danger)' : 
                                     'var(--accent-primary)';
                        return `<span style="color: ${color};">âœ¨${e}</span>`;
                    }).join(' ');
                    enchantDisplay = `<div style="font-size: 0.65rem; margin-top: 3px;">${enchantList}</div>`;
                }
                
                const isFavorited = gameState.favoriteItems && gameState.favoriteItems.includes(key);
                
                itemDiv.innerHTML = `
                    ${item.count > 1 ? `<div class="item-count">${item.count}</div>` : ''}
                    <button onclick="event.stopPropagation(); toggleFavorite('${key}')" 
                            style="position: absolute; top: 5px; right: 5px; background: none; border: none; font-size: 1.3rem; cursor: pointer; padding: 5px; z-index: 10;"
                            title="${isFavorited ? 'Unfavorite' : 'Favorite (protect from selling)'}">
                        ${isFavorited ? 'â­' : 'â˜†'}
                    </button>
                    <div style="font-size: 2rem;">ðŸ’Ž</div>
                    <div class="item-name" style="color: ${item.color};">${item.name}</div>
                    <div style="font-size: 0.8rem; color: ${item.color};">${item.rarity}</div>
                    <div class="item-value">$${formatNumber(item.value)}</div>
                    ${enchantDisplay}
                    <div style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 5px;">Tap: Flex | Long-press/Right-click: Sell</div>
                `;
                grid.appendChild(itemDiv);
            }
        }
        
        function sellItem(itemKey) {
            const item = gameState.inventory[itemKey];
            if (!item || item.count === 0) return;
            
            // Check if favorited
            if (gameState.favoriteItems && gameState.favoriteItems.includes(itemKey)) {
                showNotification('â­ Item is favorited! Unfavorite to sell.', 'var(--warning)');
                return;
            }
            
            // Confirmation for high-rarity items (Mythic and above)
            const rarityIndex = rarities.findIndex(r => r.name === item.rarity);
            if (rarityIndex >= 5 && gameState.settings && gameState.settings.confirmSell !== false) { // Mythic is index 5
                if (!confirm(`Sell ${item.name} (${item.rarity}) for $${Math.floor(item.value * 0.7)}?`)) {
                    return;
                }
            }
            
            let sellMultiplier = 0.7; // Base 70% sell value
            let hasEventStarter = false;
            
            // Check for enchantments that affect selling
            if (item.enchantments && item.enchantments.length > 0) {
                for (const enchantName of item.enchantments) {
                    const enchantData = enchantments[enchantName];
                    if (enchantData && enchantData.effect.sellMultiplier) {
                        sellMultiplier *= enchantData.effect.sellMultiplier;
                    }
                    if (enchantData && enchantData.effect.eventStarter) {
                        hasEventStarter = true;
                    }
                }
            }
            
            // Apply sell price upgrade
            if (gameState.upgrades.sellPrice > 0) {
                sellMultiplier *= (1 + gameState.upgrades.sellPrice * 0.02); // +2% per level
            }
            
            const sellPrice = Math.floor(item.value * sellMultiplier);
            gameState.money += sellPrice;
            playSound('coin');
            gameState.lifetimeMoneyEarned = (gameState.lifetimeMoneyEarned || 0) + sellPrice;
            gameState.totalValue -= item.value;
            item.count--;
            
            // Track money earned for quests and challenges
            updateQuestProgress('moneyEarned', sellPrice);
            updateDailyChallengeProgress('moneyEarned', sellPrice);
            
            if (gameState.flexedItem === itemKey && item.count === 0) {
                gameState.flexedItem = null;
            }
            
            // Trigger Event Starter effect
            if (hasEventStarter && !gameState.weatherEvent) {
                const events = ['cloudy', 'rainy', 'storming'];
                const selectedEvent = events[Math.floor(Math.random() * events.length)];
                startWeatherEvent(selectedEvent);
                showNotification(`ðŸŒŸ Event Starter activated! ${selectedEvent.toUpperCase()} event started!`, '#00aaff');
            }
            
            showNotification(`Sold for $${formatNumber(sellPrice)}!`, 'var(--success)');
            updateStats();
            updateInventory();
        }
        
        function flexItem(itemKey) {
            if (gameState.flexedItem === itemKey) {
                gameState.flexedItem = null;
                showNotification('Stopped flexing item', 'var(--text-secondary)');
            } else {
                gameState.flexedItem = itemKey;
                showNotification(`Now flexing: ${itemKey}!`, gameState.inventory[itemKey].color);
            }
            updateInventory();
        }
        
        function sortInventory(sortType) {
            gameState.inventorySort = sortType;
            updateInventory();
            showNotification(`Sorted by ${sortType}`, 'var(--accent-primary)');
        }
        
        function filterInventory() {
            const filterSelect = document.getElementById('filterType');
            gameState.inventoryFilter = filterSelect.value;
            updateInventory();
            showNotification(`Filtered: ${filterSelect.options[filterSelect.selectedIndex].text}`, 'var(--accent-primary)');
        }
        
        function startAutoTrading() {
            if (gameState.tradeTimer) {
                clearInterval(gameState.tradeTimer);
            }
            
            // Generate initial trade
            setTimeout(generateNPCTrade, 5000);
            
            // Set up automatic trade generation
            gameState.tradeTimer = setInterval(() => {
                // More trades appear with higher wealth (adjusted thresholds)
                const baseInterval = 15000; // 15 seconds base
                const wealthFactor = Math.min(gameState.totalValue / 5000, 0.8); // Adjusted from 100000 to 5000, up to 80% faster
                const popularityBonus = gameState.upgrades.popularity * 0.15; // 15% more trades per level
                const actualInterval = baseInterval * (1 - wealthFactor);
                
                // Chance to spawn multiple trades for rich players and with popularity upgrade (adjusted threshold)
                const maxTrades = Math.min(Math.floor(gameState.totalValue / 2500) + 1 + Math.floor(popularityBonus * 3), 6); // Adjusted from 50000 to 2500
                const tradesToSpawn = Math.floor(Math.random() * maxTrades) + 1;
                
                for (let i = 0; i < tradesToSpawn; i++) {
                    setTimeout(() => generateNPCTrade(), i * 1000);
                }
            }, 20000); // Check every 20 seconds
        }
        
        function generateNPCTrade() {
            const inventoryKeys = Object.keys(gameState.inventory).filter(key => gameState.inventory[key].count > 0);
            if (inventoryKeys.length === 0) return;
            
            // Prioritize higher rarity items (weighted selection)
            const weightedItems = [];
            inventoryKeys.forEach(key => {
                const item = gameState.inventory[key];
                const rarityIndex = rarities.findIndex(r => r.name === item.rarity);
                // Higher rarity = more weight (multiply by rarity index + 1)
                let weight = Math.max(1, rarityIndex);
                
                // Check for Traders Dream enchant - increases trade attraction
                if (item.enchantments && item.enchantments.length > 0) {
                    for (const enchantName of item.enchantments) {
                        const enchantData = enchantments[enchantName];
                        if (enchantData && enchantData.effect.tradeAttraction) {
                            weight *= enchantData.effect.tradeAttraction;
                        }
                    }
                }
                
                for (let i = 0; i < Math.floor(weight); i++) {
                    weightedItems.push(key);
                }
            });
            
            const yourItemKey = weightedItems[Math.floor(Math.random() * weightedItems.length)];
            const yourItem = gameState.inventory[yourItemKey];
            
            // Check for Chaotics Thoughts enchant to block scammers
            let blockScammers = false;
            if (yourItem.enchantments && yourItem.enchantments.length > 0) {
                for (const enchantName of yourItem.enchantments) {
                    const enchantData = enchantments[enchantName];
                    if (enchantData && enchantData.effect.scammerBlock) {
                        blockScammers = true;
                        break;
                    }
                }
            }
            
            // Higher value items attract more scammers
            let npcType;
            if (blockScammers) {
                // Chaotics Thoughts blocks scammers
                npcType = Math.random() < 0.5 ? 'honest' : 'fair';
            } else if (yourItem.value > 500) { // Adjusted from 10000 to 500
                const roll = Math.random();
                if (roll < 0.5) npcType = 'scammer';
                else if (roll < 0.8) npcType = 'fair';
                else npcType = 'honest';
            } else {
                const roll = Math.random();
                if (roll < 0.2) npcType = 'scammer';
                else if (roll < 0.6) npcType = 'fair';
                else npcType = 'honest';
            }
            
            const npcName = npcNames[Math.floor(Math.random() * npcNames.length)];
            
            // Generate offer item
            let offerValue;
            if (npcType === 'honest') {
                offerValue = yourItem.value * (1.1 + Math.random() * 0.3); // 110-140% value
            } else if (npcType === 'fair') {
                offerValue = yourItem.value * (0.95 + Math.random() * 0.15); // 95-110% value
            } else {
                offerValue = yourItem.value * (0.3 + Math.random() * 0.5); // 30-80% value
            }
            
            // Find a rarity tier for the offer based on value
            let offerRarity = rarities[0];
            for (let i = rarities.length - 1; i >= 0; i--) {
                if (offerValue >= rarities[i].minValue && offerValue <= rarities[i].maxValue) {
                    offerRarity = rarities[i];
                    break;
                }
            }
            
            const offerItemName = generateItemName(offerRarity);
            offerValue = Math.floor(offerValue);
            
            // Create trade object
            const trade = {
                id: Date.now() + Math.random(),
                npcName,
                npcType,
                yourItemKey,
                yourItem: { ...yourItem },
                offerItem: {
                    name: offerItemName,
                    rarity: offerRarity.name,
                    color: offerRarity.color,
                    value: offerValue
                }
            };
            
            gameState.activeTrades.push(trade);
            displayTrade(trade);
        }
        
        function displayTrade(trade) {
            const container = document.getElementById('npcContainer');
            
            // Show popup notification for new trade
            showNotification(`ðŸ’¼ ${trade.npcName} wants to trade!`, 'var(--accent-primary)');
            
            const insightLevel = gameState.upgrades.tradeInsight;
            let yourValueDisplay = '<div style="color: var(--text-secondary); font-size: 0.8rem; margin-top: 5px;">â“ Unknown Value â“</div>';
            let offerValueDisplay = '<div style="color: var(--text-secondary); font-size: 0.8rem; margin-top: 5px;">â“ Unknown Value â“</div>';
            let tradeQualityDisplay = '';
            
            if (insightLevel >= 3) {
                // Show both values
                yourValueDisplay = `<div style="color: var(--accent-gold); font-size: 0.8rem; margin-top: 5px;">$${formatNumber(trade.yourItem.value)}</div>`;
                offerValueDisplay = `<div style="color: var(--accent-gold); font-size: 0.8rem; margin-top: 5px;">$${formatNumber(trade.offerItem.value)}</div>`;
            }
            
            if (insightLevel >= 1) {
                const diff = trade.offerItem.value - trade.yourItem.value;
                if (insightLevel === 1) {
                    // Show quality indicator
                    if (diff > 0) tradeQualityDisplay = '<div style="color: var(--success); margin-top: 10px;">âœ… Good Trade</div>';
                    else if (diff < 0) tradeQualityDisplay = '<div style="color: var(--danger); margin-top: 10px;">âš ï¸ Bad Trade</div>';
                    else tradeQualityDisplay = '<div style="color: var(--warning); margin-top: 10px;">âš–ï¸ Fair Trade</div>';
                } else if (insightLevel >= 2) {
                    // Show exact difference
                    if (diff > 0) tradeQualityDisplay = `<div style="color: var(--success); margin-top: 10px;">+$${formatNumber(diff)}</div>`;
                    else if (diff < 0) tradeQualityDisplay = `<div style="color: var(--danger); margin-top: 10px;">-$${formatNumber(Math.abs(diff))}</div>`;
                    else tradeQualityDisplay = '<div style="color: var(--warning); margin-top: 10px;">Â±$0</div>';
                }
            }
            
            const npcDiv = document.createElement('div');
            npcDiv.className = 'npc-card';
            npcDiv.setAttribute('data-trade-id', trade.id);
            npcDiv.innerHTML = `
                <div class="npc-header">
                    <div class="npc-name">${trade.npcName}</div>
                    <div style="color: var(--text-secondary); font-size: 0.8rem;">Expires in 30s</div>
                </div>
                <div class="trade-offer">
                    <div>
                        <div style="color: var(--text-secondary); margin-bottom: 5px;">You Give:</div>
                        <div style="color: ${trade.yourItem.color}; font-weight: bold; font-size: 1.1rem;">${trade.yourItem.name}</div>
                        <div style="color: ${trade.yourItem.color}; font-size: 0.9rem;">${trade.yourItem.rarity}</div>
                        ${yourValueDisplay}
                    </div>
                    <div style="font-size: 2rem;">â†”ï¸</div>
                    <div>
                        <div style="color: var(--text-secondary); margin-bottom: 5px;">You Get:</div>
                        <div style="color: ${trade.offerItem.color}; font-weight: bold; font-size: 1.1rem;">${trade.offerItem.name}</div>
                        <div style="color: ${trade.offerItem.color}; font-size: 0.9rem;">${trade.offerItem.rarity}</div>
                        ${offerValueDisplay}
                    </div>
                </div>
                ${tradeQualityDisplay}
                <div class="trade-buttons">
                    <button class="btn btn-accept" onclick="acceptTrade(${trade.id})">Accept Trade</button>
                    <button class="btn btn-decline" onclick="declineTrade(${trade.id})">Decline</button>
                </div>
            `;
            
            // Add to top of container
            container.insertBefore(npcDiv, container.firstChild);
            
            // Auto-remove after 30 seconds
            setTimeout(() => {
                const element = document.querySelector(`[data-trade-id="${trade.id}"]`);
                if (element) {
                    showNotification(`Trade with ${trade.npcName} expired!`, 'var(--text-secondary)');
                    element.style.animation = 'slideIn 0.5s ease-out reverse';
                    setTimeout(() => {
                        element.remove();
                        gameState.activeTrades = gameState.activeTrades.filter(t => t.id !== trade.id);
                    }, 500);
                }
            }, 30000);
        }
        
        function acceptTrade(tradeId) {
            const trade = gameState.activeTrades.find(t => t.id === tradeId);
            if (!trade) return;
            
            const item = gameState.inventory[trade.yourItemKey];
            if (!item || item.count === 0) {
                showNotification('Item no longer available!', 'var(--danger)');
                declineTrade(tradeId);
                return;
            }
            
            // Remove your item
            item.count--;
            gameState.totalValue -= trade.yourItem.value;
            
            // Add received item
            const receivedFullName = `${trade.offerItem.name} (${trade.offerItem.rarity})`;
            if (gameState.inventory[receivedFullName]) {
                gameState.inventory[receivedFullName].count++;
            } else {
                gameState.inventory[receivedFullName] = {
                    name: trade.offerItem.name,
                    rarity: trade.offerItem.rarity,
                    color: trade.offerItem.color,
                    value: trade.offerItem.value,
                    count: 1
                };
            }
            gameState.totalValue += trade.offerItem.value;
            
            // Determine if it was a good trade
            const valueDiff = trade.offerItem.value - trade.yourItem.value;
            if (valueDiff > 0) {
                gameState.tradeWins++;
                updateQuestProgress('tradeWins', 1);
                updateDailyChallengeProgress('tradeWins', 1);
                if (valueDiff > (gameState.biggestTradeWin || 0)) {
                    gameState.biggestTradeWin = valueDiff;
                }
                showNotification(`Great trade! Gained $${formatNumber(valueDiff)} value! ðŸ“ˆ`, 'var(--success)');
            } else if (valueDiff < 0) {
                gameState.tradeLosses++;
                const loss = Math.abs(valueDiff);
                if (loss > (gameState.biggestTradeLoss || 0)) {
                    gameState.biggestTradeLoss = loss;
                }
                showNotification(`Bad trade! Lost $${formatNumber(loss)} value! ðŸ“‰`, 'var(--danger)');
            } else {
                showNotification('Fair trade! Same value ðŸ“Š', 'var(--warning)');
            }
            
            gameState.battlePassXP += 5;
            updateStats();
            updateInventory();
            updateBattlePass();
            checkAchievements();
            
            declineTrade(tradeId);
        }
        
        function declineTrade(tradeId) {
            const element = document.querySelector(`[data-trade-id="${tradeId}"]`);
            if (element) {
                element.style.animation = 'slideIn 0.5s ease-out reverse';
                setTimeout(() => element.remove(), 500);
            }
            gameState.activeTrades = gameState.activeTrades.filter(t => t.id !== tradeId);
        }
        
        function initCrafting() {
            const grid = document.getElementById('craftingGrid');
            recipes.forEach(recipe => {
                const canCraft = Object.entries(recipe.requires).every(([rarity, count]) => {
                    return Object.values(gameState.inventory).filter(item => 
                        item.rarity === rarity && item.count > 0
                    ).length >= count;
                });
                
                const recipeDiv = document.createElement('div');
                recipeDiv.className = 'recipe-card';
                recipeDiv.innerHTML = `
                    <h3 style="color: var(--accent-primary);">${recipe.name}</h3>
                    <div class="recipe-requirements">
                        <div style="color: var(--text-secondary); margin-bottom: 10px;">Requires:</div>
                        ${Object.entries(recipe.requires).map(([rarity, count]) => 
                            `<div>${count}x ${rarity} items</div>`
                        ).join('')}
                    </div>
                    <div style="margin: 10px 0;">
                        <div style="color: var(--accent-gold);">Creates: ${recipe.result}</div>
                        <div style="color: var(--success);">Value: $${formatNumber(recipe.value)}</div>
                    </div>
                    <div style="display: flex; gap: 5px;">
                        <button class="btn btn-accept" ${!canCraft ? 'disabled' : ''} 
                                onclick="craftItem('${recipe.name}')" 
                                style="flex: 1; ${!canCraft ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
                            Craft 1x
                        </button>
                        <button class="btn btn-accept" ${!canCraft ? 'disabled' : ''} 
                                onclick="craftMax('${recipe.name}')" 
                                style="flex: 1; background: linear-gradient(135deg, var(--accent-gold), var(--warning)); ${!canCraft ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
                            Craft Max
                        </button>
                    </div>
                `;
                grid.appendChild(recipeDiv);
            });
        }
        
        function craftItem(recipeName, silent = false) {
            const recipe = recipes.find(r => r.name === recipeName);
            if (!recipe) return;
            
            // Remove required items
            for (const [rarity, count] of Object.entries(recipe.requires)) {
                let removed = 0;
                for (const [key, item] of Object.entries(gameState.inventory)) {
                    if (item.rarity === rarity && item.count > 0 && removed < count) {
                        const toRemove = Math.min(item.count, count - removed);
                        item.count -= toRemove;
                        gameState.totalValue -= item.value * toRemove;
                        removed += toRemove;
                    }
                }
            }
            
            // Check for Crafting Merger enchants in inventory
            let craftDupeChance = 0;
            for (const [key, item] of Object.entries(gameState.inventory)) {
                if (item.enchantments && item.count > 0) {
                    for (const enchantName of item.enchantments) {
                        const enchantData = enchantments[enchantName];
                        if (enchantData && enchantData.effect.craftDupeChance) {
                            craftDupeChance = Math.max(craftDupeChance, enchantData.effect.craftDupeChance);
                        }
                    }
                }
            }
            
            // Add crafted item
            const rarity = rarities.find(r => r.name === recipe.result);
            
            if (!rarity) {
                if (!silent) showNotification('Error: Invalid recipe rarity!', 'var(--danger)');
                return;
            }
            
            let craftValue = recipe.value;
            
            // Apply craftingMastery upgrade - increases craft output value
            if (gameState.upgrades.craftingMastery > 0) {
                const masteryBonus = 1 + (gameState.upgrades.craftingMastery * 0.02); // 2% per level
                craftValue = Math.floor(craftValue * masteryBonus);
            }
            
            addItemToInventory(recipe.name, { ...rarity, minValue: craftValue, maxValue: craftValue });
            
            // Try to duplicate with Crafting Merger
            if (craftDupeChance > 0 && Math.random() < craftDupeChance) {
                addItemToInventory(recipe.name, { ...rarity, minValue: craftValue, maxValue: craftValue });
                if (!silent) showNotification(`ðŸ”¨ Crafting Merger! Duplicated craft!`, 'var(--accent-gold)');
            }
            
            gameState.craftCount = (gameState.craftCount || 0) + 1;
            gameState.battlePassXP += 20;
            
            // Update quests
            updateQuestProgress('crafts', 1);
            
            // Update daily challenges
            updateDailyChallengeProgress('crafts', 1);
            
            if (!silent) {
                showNotification(`Crafted: ${recipe.name}!`, rarity.color);
                updateStats();
                updateInventory();
            }
            updateBattlePass();
            checkAchievements();
            
            // Refresh crafting UI
            document.getElementById('craftingGrid').innerHTML = '';
            initCrafting();
        }
        
        function initShop() {
            const grid = document.getElementById('shopGrid');
            grid.innerHTML = '';
            
            // Generate shop items for each rarity (expanded to 20)
            const shopRarities = rarities.slice(0, 20); // Common to Primordial
            
            shopRarities.forEach(rarity => {
                const itemName = generateItemName(rarity);
                const baseValue = (rarity.minValue + rarity.maxValue) / 2;
                const shopPrice = Math.floor(baseValue * 1.5); // 50% markup
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'inventory-item';
                itemDiv.style.borderColor = rarity.color;
                itemDiv.innerHTML = `
                    <div style="font-size: 2rem;">ðŸª</div>
                    <div class="item-name" style="color: ${rarity.color};">${itemName}</div>
                    <div style="font-size: 0.8rem; color: ${rarity.color};">${rarity.name}</div>
                    <div class="item-value">$${formatNumber(shopPrice)}</div>
                    <button class="btn btn-accept" style="margin-top: 10px; padding: 8px 15px; font-size: 0.8rem;" 
                            onclick="buyItem('${itemName}', '${rarity.name}', '${rarity.color}', ${Math.floor(baseValue)}, ${shopPrice})"
                            ${gameState.money < shopPrice ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
                        Buy
                    </button>
                `;
                grid.appendChild(itemDiv);
            });
        }
        
        function buyItem(name, rarityName, color, value, price) {
            if (gameState.money < price) {
                showNotification('Not enough money!', 'var(--danger)');
                return;
            }
            
            gameState.money -= price;
            gameState.lifetimeMoneySpent = (gameState.lifetimeMoneySpent || 0) + price;
            
            const fullName = `${name} (${rarityName})`;
            if (gameState.inventory[fullName]) {
                gameState.inventory[fullName].count++;
            } else {
                gameState.inventory[fullName] = {
                    name: name,
                    rarity: rarityName,
                    color: color,
                    value: value,
                    count: 1
                };
            }
            gameState.totalValue += value;
            gameState.shopPurchases = (gameState.shopPurchases || 0) + 1;
            
            // Update quests
            updateQuestProgress('shopBuys', 1);
            
            showNotification(`Purchased: ${name}!`, color);
            updateStats();
            updateInventory();
            initShop(); // Refresh shop to update buy buttons
            checkAchievements();
        }
        
        function updateEnchantInventory() {
            const grid = document.getElementById('enchantInventoryGrid');
            grid.innerHTML = '';
            
            // Only show Divine (index 8) and higher rarities
            const divineIndex = rarities.findIndex(r => r.name === 'Divine');
            
            let hasEligibleItems = false;
            for (const [key, item] of Object.entries(gameState.inventory)) {
                if (item.count > 0) {
                    const itemRarityIndex = rarities.findIndex(r => r.name === item.rarity);
                    if (itemRarityIndex >= divineIndex) {
                        hasEligibleItems = true;
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'inventory-item';
                        itemDiv.style.borderColor = item.color;
                        itemDiv.onclick = () => selectItemForEnchant(key);
                        
                        // Show existing enchantments
                        const enchantDisplay = item.enchantments && item.enchantments.length > 0 
                            ? `<div style="font-size: 0.7rem; color: var(--accent-gold); margin-top: 3px;">${item.enchantments.join(', ')}</div>` 
                            : '';
                        
                        itemDiv.innerHTML = `
                            ${item.count > 1 ? `<div class="item-count">${item.count}</div>` : ''}
                            <div style="font-size: 2rem;">âœ¨</div>
                            <div class="item-name" style="color: ${item.color};">${item.name}</div>
                            <div style="font-size: 0.8rem; color: ${item.color};">${item.rarity}</div>
                            <div class="item-value">$${formatNumber(item.value)}</div>
                            ${enchantDisplay}
                        `;
                        grid.appendChild(itemDiv);
                    }
                }
            }
            
            if (!hasEligibleItems) {
                grid.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">No Divine or higher rarity items available for enchanting.</p>';
            }
        }
        
        function initUpgrades() {
            const grid = document.getElementById('upgradesGrid');
            grid.innerHTML = '';
            
            for (const [key, data] of Object.entries(upgradeData)) {
                const currentLevel = gameState.upgrades[key];
                const cost = Math.floor(data.baseCost * Math.pow(data.costMultiplier, currentLevel));
                const canAfford = gameState.money >= cost;
                const isMaxed = currentLevel >= data.maxLevel;
                
                const upgradeDiv = document.createElement('div');
                upgradeDiv.className = 'recipe-card';
                upgradeDiv.innerHTML = `
                    <h3 style="color: var(--accent-primary);">${data.name}</h3>
                    <p style="color: var(--text-secondary); margin: 10px 0;">${data.description}</p>
                    <div class="recipe-requirements">
                        <div style="color: var(--accent-gold); font-weight: bold;">Level: ${currentLevel}/${data.maxLevel}</div>
                        <div style="color: var(--accent-primary); margin-top: 5px;">${data.effect(currentLevel)}</div>
                        ${!isMaxed ? `<div style="color: var(--warning); margin-top: 10px;">Next: ${data.effect(currentLevel + 1)}</div>` : ''}
                    </div>
                    <div style="margin: 10px 0;">
                        <div style="color: var(--accent-gold);">Cost: $${formatNumber(cost)}</div>
                    </div>
                    <button class="btn btn-accept" 
                            ${!canAfford || isMaxed ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}
                            onclick="purchaseUpgrade('${key}')">
                        ${isMaxed ? 'MAXED' : 'Upgrade'}
                    </button>
                `;
                grid.appendChild(upgradeDiv);
            }
        }
        
        function purchaseUpgrade(upgradeKey) {
            const data = upgradeData[upgradeKey];
            const currentLevel = gameState.upgrades[upgradeKey];
            
            if (currentLevel >= data.maxLevel) {
                showNotification('Already at max level!', 'var(--warning)');
                return;
            }
            
            const cost = Math.floor(data.baseCost * Math.pow(data.costMultiplier, currentLevel));
            
            if (gameState.money < cost) {
                showNotification('Not enough money!', 'var(--danger)');
                return;
            }
            
            gameState.money -= cost;
            gameState.lifetimeMoneySpent = (gameState.lifetimeMoneySpent || 0) + cost;
            gameState.upgrades[upgradeKey]++;
            
            // Apply upgrade effects
            if (upgradeKey === 'luckBoost') {
                gameState.luckMultiplier += 0.1;
            } else if (upgradeKey === 'autoSpin' && gameState.upgrades[upgradeKey] === 1) {
                startAutoSpin();
            }
            
            showNotification(`Upgraded ${data.name} to level ${gameState.upgrades[upgradeKey]}!`, 'var(--success)');
            updateStats();
            initUpgrades();
        }
        
        function selectItemForEnchant(itemKey) {
            const item = gameState.inventory[itemKey];
            if (!item || item.count === 0) {
                showNotification('Item no longer available!', 'var(--danger)');
                return;
            }
            
            gameState.enchantmentTarget = itemKey;
            
            const slot = document.getElementById('selectedEnchantItem');
            slot.innerHTML = `
                <strong style="color: ${item.color};">${item.name}</strong><br>
                <span style="color: ${item.color}; font-size: 0.9rem;">${item.rarity}</span><br>
                <span style="color: var(--accent-gold);">$${formatNumber(item.value)}</span>
            `;
            
            document.getElementById('enchantmentInterface').style.display = 'block';
        }
        
        function enchantItem() {
            if (!gameState.enchantmentTarget) {
                showNotification('Select an item first!', 'var(--danger)');
                return;
            }
            
            const item = gameState.inventory[gameState.enchantmentTarget];
            if (!item || item.count === 0) {
                showNotification('Item no longer available!', 'var(--danger)');
                gameState.enchantmentTarget = null;
                document.getElementById('enchantmentInterface').style.display = 'none';
                return;
            }
            
            // Check if item is Divine or higher
            const divineIndex = rarities.findIndex(r => r.name === 'Divine');
            const itemRarityIndex = rarities.findIndex(r => r.name === item.rarity);
            if (itemRarityIndex < divineIndex) {
                showNotification('Item must be Divine or higher rarity!', 'var(--danger)');
                return;
            }
            
            // Initialize enchantments array if it doesn't exist
            if (!item.enchantments) {
                item.enchantments = [];
            }
            
            // Check if item already has an enchantment (limit to 1)
            if (item.enchantments.length > 0) {
                showNotification('âš ï¸ Item already has an enchantment! Items can only have ONE enchantment.', 'var(--warning)');
                return;
            }
            
            // Roll for enchantment
            const roll = Math.random();
            let selectedEnchant = null;
            let cumulativeChance = 0;
            
            // Shuffle enchantments for fairness
            const enchantKeys = Object.keys(enchantments);
            for (let i = enchantKeys.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [enchantKeys[i], enchantKeys[j]] = [enchantKeys[j], enchantKeys[i]];
            }
            
            // Apply enchantPower upgrade boost
            let luckBoost = 1.0;
            
            // Apply enchantPower upgrade
            if (gameState.upgrades.enchantPower > 0) {
                const upgradeLuckBoost = 1 + (gameState.upgrades.enchantPower * 0.1); // 10% per level
                luckBoost *= upgradeLuckBoost;
            }
            
            for (const enchantName of enchantKeys) {
                const enchant = enchantments[enchantName];
                cumulativeChance += enchant.chance * luckBoost;
                if (roll < cumulativeChance) {
                    selectedEnchant = { name: enchantName, data: enchant };
                    break;
                }
            }
            
            if (!selectedEnchant) {
                showNotification('Enchantment failed - no effect!', 'var(--warning)');
                gameState.enchantmentTarget = null;
                document.getElementById('enchantmentInterface').style.display = 'none';
                updateEnchantInventory();
                saveGame(true); // Auto-save
                return;
            }
            
            const enchantName = selectedEnchant.name;
            const enchantData = selectedEnchant.data;
            const effect = enchantData.effect;
            
            // Handle bad enchants
            if (enchantName === 'Too Much Energy' || enchantName === 'Too Little Energy') {
                gameState.totalValue -= item.value;
                item.count--;
                gameState.enchantFails = (gameState.enchantFails || 0) + 1;
                showNotification(`ðŸ’€ ${enchantName}! Item DESTROYED! ðŸ’€`, 'var(--danger)');
                
                gameState.enchantmentTarget = null;
                document.getElementById('enchantmentInterface').style.display = 'none';
                updateStats();
                updateInventory();
                updateEnchantInventory();
                checkAchievements();
                saveGame(true); // Auto-save
                return;
            }
            
            // Handle Ditto enchant - copies random item
            if (enchantName.startsWith('Ditto')) {
                const inventoryKeys = Object.keys(gameState.inventory).filter(k => gameState.inventory[k].count > 0 && k !== gameState.enchantmentTarget);
                if (inventoryKeys.length > 0) {
                    const randomKey = inventoryKeys[Math.floor(Math.random() * inventoryKeys.length)];
                    const copiedItem = gameState.inventory[randomKey];
                    const newValue = Math.floor(copiedItem.value * effect.dittoCopy);
                    
                    // Add copied item to inventory
                    const newKey = `${copiedItem.name} (${copiedItem.rarity}) [Ditto Copy]`;
                    gameState.inventory[newKey] = {
                        name: `${copiedItem.name} [Ditto Copy]`,
                        rarity: copiedItem.rarity,
                        color: copiedItem.color,
                        value: newValue,
                        count: 1,
                        enchantments: []
                    };
                    gameState.totalValue += newValue;
                    
                    showNotification(`ðŸŽ­ ${enchantName}! Copied ${copiedItem.name} (+${((effect.dittoCopy - 1) * 100).toFixed(0)}% value)`, 'var(--warning)');
                } else {
                    showNotification(`ðŸŽ­ ${enchantName}! But no items to copy...`, 'var(--warning)');
                }
                
                gameState.enchantmentTarget = null;
                document.getElementById('enchantmentInterface').style.display = 'none';
                updateStats();
                updateInventory();
                updateEnchantInventory();
                saveGame(true); // Auto-save
                return;
            }
            
            // Apply good enchantments
            item.enchantments.push(enchantName);
            
            // Apply value multiplier if present
            if (effect.valueMultiplier) {
                const oldValue = item.value;
                item.value = Math.floor(item.value * effect.valueMultiplier);
                gameState.totalValue += (item.value - oldValue);
            }
            
            // Apply luck boost if present
            if (effect.luckBoost) {
                gameState.luckMultiplier += effect.luckBoost;
            }
            
            gameState.enchantSuccess = (gameState.enchantSuccess || 0) + 1;
            gameState.battlePassXP += 15;
            
            // Update quests
            updateQuestProgress('enchants', 1);
            
            const rarityColor = enchantData.type === 'ultimate' ? '#ff00ff' : 
                               enchantData.type === 'godly' ? 'var(--accent-gold)' : 
                               'var(--success)';
            
            showNotification(`âœ¨ ${enchantName} applied! âœ¨`, rarityColor);
            
            gameState.enchantmentTarget = null;
            document.getElementById('enchantmentInterface').style.display = 'none';
            
            updateStats();
            updateInventory();
            updateEnchantInventory();
            updateBattlePass();
            checkAchievements();
            saveGame(true); // Auto-save after enchant
        }
        
        function initAchievements() {
            const list = document.getElementById('achievementList');
            achievements.forEach(achievement => {
                const unlocked = gameState.achievements[achievement.id] || achievement.check();
                if (unlocked && !gameState.achievements[achievement.id]) {
                    gameState.achievements[achievement.id] = true;
                    
                    // Award achievement points
                    awardAchievementPoints(achievement.id);
                    
                    // Grant rewards
                    if (achievement.id === 'first_spin') {
                        gameState.luckMultiplier += 0.1;
                    } else if (achievement.id === 'spin_master') {
                        gameState.luckMultiplier += 0.2;
                    } else if (achievement.id === 'spin_legend') {
                        gameState.luckMultiplier += 0.5;
                    } else if (achievement.id === 'spin_god') {
                        gameState.luckMultiplier += 1.0;
                    } else if (achievement.id === 'spin_master_100k') {
                        gameState.luckMultiplier += 2.0;
                    }
                    
                    // Show achievement notification if enabled
                    if (gameState.settings.showAchievementNotifications) {
                        showNotification(`ðŸ† Achievement Unlocked: ${achievement.name}!`, 'var(--accent-gold)');
                        playSound('achievement');
                    }
                }
                
                const achDiv = document.createElement('div');
                achDiv.className = 'achievement-card' + (unlocked ? ' unlocked' : '');
                achDiv.innerHTML = `
                    <div class="achievement-icon">${unlocked ? 'ðŸ†' : 'ðŸ”’'}</div>
                    <h3 style="color: ${unlocked ? 'var(--accent-gold)' : 'var(--text-secondary)'};">${achievement.name}</h3>
                    <p style="color: var(--text-secondary); margin: 10px 0;">${achievement.desc}</p>
                    <div style="color: var(--accent-primary); font-weight: bold;">Reward: ${achievement.reward}</div>
                `;
                list.appendChild(achDiv);
            });
        }
        
        function checkAchievements() {
            const list = document.getElementById('achievementList');
            list.innerHTML = '';
            initAchievements();
        }
        
        
        function updateBattlePass() {
            const currentTier = battlePassTiers.findIndex(t => gameState.battlePassXP < t.xpRequired);
            const tierIndex = currentTier === -1 ? battlePassTiers.length : currentTier;
            
            // Initialize claimed tiers tracking
            if (!gameState.claimedBPTiers) {
                gameState.claimedBPTiers = [];
            }
            
            // Check for newly unlocked tiers and give rewards
            for (let i = 0; i < tierIndex; i++) {
                const tier = battlePassTiers[i];
                if (!gameState.claimedBPTiers.includes(tier.tier)) {
                    // Give reward
                    giveRewardFromTier(tier);
                    gameState.claimedBPTiers.push(tier.tier);
                }
            }
            
            // Calculate current tier properly
            let currentTierNum = 0;
            for (let i = 0; i < battlePassTiers.length; i++) {
                if (gameState.battlePassXP >= battlePassTiers[i].xpRequired) {
                    currentTierNum = battlePassTiers[i].tier;
                }
            }
            gameState.battlePassTier = currentTierNum;
            
            const progress = document.getElementById('bpProgress');
            const maxXP = battlePassTiers[battlePassTiers.length - 1].xpRequired;
            const percentage = Math.min((gameState.battlePassXP / maxXP) * 100, 100);
            progress.style.width = percentage + '%';
            progress.textContent = `Tier ${currentTierNum}/${battlePassTiers.length} (${formatNumber(gameState.battlePassXP)} XP)`;
            
            const tiersDiv = document.getElementById('bpTiers');
            tiersDiv.innerHTML = '';
            initBattlePass();
        }
        
        function giveRewardFromTier(tier) {
            const reward = tier.reward;
            
            // Rewards are crates - give items based on crate type
            if (reward.includes('Crate')) {
                const rarityName = reward.replace(' Crate', '');
                const rarity = rarities.find(r => r.name === rarityName);
                
                if (rarity) {
                    const itemName = generateItemName(rarity);
                    addItemToInventory(itemName, rarity);
                    showNotification(`ðŸŽ Battle Pass Tier ${tier.tier} Reward: ${itemName}!`, rarity.color);
                } else {
                    console.error(`Could not find rarity for: ${rarityName}`);
                    showNotification(`ðŸŽ Battle Pass Tier ${tier.tier} Unlocked: ${reward}!`, 'var(--accent-gold)');
                }
            } else {
                // Non-crate rewards (badges, titles, etc) - just notify
                showNotification(`ðŸŽ Battle Pass Tier ${tier.tier} Unlocked: ${reward}!`, 'var(--accent-gold)');
            }
            
            updateInventory();
            saveGame(true);
        }
        
        function checkChristmasEvent() {
            const now = new Date();
            const minutes = now.getMinutes();
            
            // Event happens at the hour mark (00-04 minutes)
            if (minutes < 5 && !gameState.christmasEvent) {
                gameState.christmasEvent = true;
                gameState.christmasEventEnd = new Date(now.getTime() + 5 * 60000); // 5 minutes
                showNotification('ðŸŽ„ CHRISTMAS EVENT STARTED! 5 minutes remaining! ðŸŽ…', '#ff0000');
                updateEventBonuses();
            } else if (gameState.christmasEvent && now >= gameState.christmasEventEnd) {
                gameState.christmasEvent = false;
                gameState.christmasEventEnd = null;
                showNotification('ðŸŽ„ Christmas Event Ended! See you next hour! â„ï¸', 'var(--text-secondary)');
                updateEventBonuses();
            }
        }
        
        function checkWeatherEvents() {
            const now = Date.now();
            
            // Initialize lastWeatherEvent to now if it's 0 (first load)
            if (gameState.lastWeatherEvent === 0) {
                gameState.lastWeatherEvent = now;
                return; // Don't trigger event on first load
            }
            
            // Check if current weather event has ended
            if (gameState.weatherEvent && gameState.weatherEventEnd && now >= gameState.weatherEventEnd) {
                const eventEmojis = { cloudy: 'â˜ï¸', rainy: 'ðŸŒ§ï¸', storming: 'â›ˆï¸' };
                showNotification(`${eventEmojis[gameState.weatherEvent]} ${gameState.weatherEvent.toUpperCase()} Event Ended!`, 'var(--text-secondary)');
                gameState.weatherEvent = null;
                gameState.weatherEventEnd = null;
                updateEventBonuses();
            }
            
            // Try to start a new weather event (every 10 minutes)
            if (!gameState.weatherEvent && now - gameState.lastWeatherEvent >= 600000) { // 10 minutes
                if (Math.random() < 0.8) { // 80% chance to start event
                    const events = ['cloudy', 'rainy', 'storming'];
                    const selectedEvent = events[Math.floor(Math.random() * events.length)];
                    startWeatherEvent(selectedEvent);
                }
                gameState.lastWeatherEvent = now;
            }
        }
        
        function startWeatherEvent(eventType) {
            gameState.weatherEvent = eventType;
            gameState.weatherEventEnd = Date.now() + 60000; // 1 minute
            
            const eventNames = { cloudy: 'CLOUDY', rainy: 'RAINY', storming: 'STORMING' };
            const eventEmojis = { cloudy: 'â˜ï¸', rainy: 'ðŸŒ§ï¸', storming: 'â›ˆï¸' };
            showNotification(`${eventEmojis[eventType]} ${eventNames[eventType]} EVENT STARTED! 1 minute!`, '#00aaff');
            updateEventBonuses();
        }
        
        function checkSpecialEvents() {
            const now = new Date();
            const currentTime = now.getTime();
            const minutes = now.getMinutes();
            const hours = now.getHours();
            
            // First, check if any active event has expired (admin or scheduled)
            if (gameState.specialEvent && gameState.specialEventEnd && currentTime >= gameState.specialEventEnd) {
                const eventEmojis = { disco: 'ðŸª©', galactic: 'ðŸŒŒ', glitch: 'âš¡', fullmoon: 'ðŸŒ•', bloodmoon: 'ðŸ”´' };
                showNotification(`${eventEmojis[gameState.specialEvent]} ${gameState.specialEvent.toUpperCase()} Event Ended!`, 'var(--text-secondary)');
                gameState.specialEvent = null;
                gameState.specialEventEnd = null;
                gameState.specialEventIsAdmin = false;
                updateEventBonuses();
            }
            
            // Don't manage scheduled events if admin event is active
            if (gameState.specialEventIsAdmin) {
                return;
            }
            
            let shouldBeActive = null;
            let endMinute = 0;
            
            // Determine which event should be active based on current time
            if (minutes >= 15 && minutes < 20) {
                shouldBeActive = 'disco';
                endMinute = 20;
            } else if (minutes >= 30 && minutes < 35) {
                shouldBeActive = 'galactic';
                endMinute = 35;
            } else if (minutes >= 45 && minutes < 50) {
                shouldBeActive = 'glitch';
                endMinute = 50;
            } else if (minutes >= 20 && minutes < 25 && hours % 2 === 0) {
                shouldBeActive = 'fullmoon';
                endMinute = 25;
            } else if (minutes >= 50 && minutes < 55 && hours % 3 === 0) {
                shouldBeActive = 'bloodmoon';
                endMinute = 55;
            }
            
            // Handle scheduled event state changes
            if (shouldBeActive && !gameState.specialEvent) {
                // Start new scheduled event
                startSpecialEvent(shouldBeActive, endMinute, false);
            } else if (shouldBeActive && gameState.specialEvent && shouldBeActive !== gameState.specialEvent) {
                // Wrong scheduled event is active, switch to correct one
                gameState.specialEvent = null;
                startSpecialEvent(shouldBeActive, endMinute, false);
            }
            // If shouldBeActive is null and there's an event, it will be ended by the time check above
        }
        
        function startSpecialEvent(eventType, endMinute = null, isAdmin = true) {
            gameState.specialEvent = eventType;
            gameState.specialEventIsAdmin = isAdmin;
            
            // Calculate exact end time based on the end minute of the time window
            if (endMinute !== null) {
                const now = new Date();
                const endTime = new Date(now);
                endTime.setMinutes(endMinute);
                endTime.setSeconds(0);
                endTime.setMilliseconds(0);
                
                // If end time is in the past (shouldn't happen), add an hour
                if (endTime <= now) {
                    endTime.setHours(endTime.getHours() + 1);
                }
                
                gameState.specialEventEnd = endTime.getTime();
            } else {
                // Admin-triggered events last 5 minutes
                gameState.specialEventEnd = Date.now() + 300000;
            }
            
            const eventNames = { 
                disco: 'DISCO ðŸª©', 
                galactic: 'GALACTIC ðŸŒŒ', 
                glitch: 'GLITCH âš¡', 
                fullmoon: 'FULL MOON ðŸŒ•', 
                bloodmoon: 'BLOOD MOON ðŸ”´' 
            };
            const eventColors = {
                disco: '#ff00ff',
                galactic: '#4B0082',
                glitch: '#00ff00',
                fullmoon: '#f0f0f0',
                bloodmoon: '#8B0000'
            };
            
            const eventTypeLabel = isAdmin ? 'Admin' : 'Scheduled';
            showNotification(`âœ¨ ${eventNames[eventType]} EVENT STARTED! (${eventTypeLabel}) âœ¨`, eventColors[eventType]);
            updateEventBonuses();
        }
        
        function sellAllItems() {
            if (!confirm('Are you sure you want to sell ALL items for 70% of their value?')) {
                return;
            }
            
            let totalSellValue = 0;
            let itemCount = 0;
            
            for (const [key, item] of Object.entries(gameState.inventory)) {
                if (item.count > 0) {
                    const sellValue = Math.floor(item.value * 0.7 * item.count);
                    totalSellValue += sellValue;
                    itemCount += item.count;
                    gameState.totalValue -= item.value * item.count;
                    item.count = 0;
                }
            }
            
            gameState.money += totalSellValue;
            gameState.flexedItem = null;
            
            showNotification(`Sold ${itemCount} items for $${formatNumber(totalSellValue)}!`, 'var(--success)');
            updateStats();
            updateInventory();
        }
        
        // ===== DAILY LOGIN SYSTEM =====
        function checkDailyLogin() {
            const today = new Date().toDateString();
            
            if (!gameState.lastLoginDate || gameState.lastLoginDate !== today) {
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toDateString();
                
                // Check if streak continues or breaks
                if (gameState.lastLoginDate === yesterdayStr) {
                    gameState.loginStreak++;
                } else if (gameState.lastLoginDate) {
                    gameState.loginStreak = 1; // Reset streak
                } else {
                    gameState.loginStreak = 1; // First login
                }
                
                gameState.lastLoginDate = today;
                gameState.totalLogins++;
                
                // Give rewards
                giveDailyLoginReward();
            }
        }
        
        function giveDailyLoginReward() {
            const day = gameState.loginStreak;
            const rewards = [
                { day: 1, money: 1000, desc: '$1,000' },
                { day: 2, money: 2500, desc: '$2,500' },
                { day: 3, money: 5000, xp: 100, desc: '$5,000 + 100 XP' },
                { day: 4, money: 10000, desc: '$10,000' },
                { day: 5, money: 25000, xp: 250, desc: '$25,000 + 250 XP' },
                { day: 6, money: 50000, desc: '$50,000' },
                { day: 7, money: 100000, xp: 500, item: 'Mythic', desc: '$100K + Mythic Item + 500 XP' }
            ];
            
            const rewardIndex = Math.min(day, 7) - 1;
            const reward = rewards[rewardIndex];
            
            if (reward.money) {
                gameState.money += reward.money;
                gameState.lifetimeMoneyEarned += reward.money;
            }
            if (reward.xp) {
                gameState.battlePassXP += reward.xp;
            }
            if (reward.item) {
                const rarity = rarities.find(r => r.name === reward.item);
                if (rarity) {
                    const itemName = generateItemName(rarity);
                    addItemToInventory(itemName, rarity);
                }
            }
            
            showDailyLoginPopup(day, reward.desc);
        }
        
        function showDailyLoginPopup(day, rewardDesc) {
            const popup = document.createElement('div');
            popup.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-medium) 100%);
                border: 3px solid var(--accent-gold);
                border-radius: 15px;
                padding: 40px;
                z-index: 10000;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
                text-align: center;
                animation: slideInTop 0.5s ease-out;
            `;
            
            popup.innerHTML = `
                <h2 style="color: var(--accent-gold); font-size: 2rem; margin-bottom: 20px;">ðŸŽ Daily Login Reward!</h2>
                <p style="color: var(--text-primary); font-size: 1.2rem; margin: 20px 0;">Day ${day} Streak!</p>
                <p style="color: var(--accent-primary); font-size: 1.5rem; margin: 20px 0; font-weight: bold;">${rewardDesc}</p>
                <button class="btn btn-accept" onclick="this.parentElement.remove()" style="margin-top: 20px; font-size: 1.1rem; padding: 12px 30px;">
                    Claim Reward
                </button>
            `;
            
            document.body.appendChild(popup);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (popup.parentElement) popup.remove();
            }, 10000);
        }
        
        // ===== FUSION SYSTEM =====
        const fusionSlots = [null, null, null];
        
        function updateFusionInventory() {
            const grid = document.getElementById('fusionInventoryGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            const sortedItems = Object.entries(gameState.inventory)
                .filter(([key, item]) => item.count > 0)
                .sort((a, b) => {
                    const rarityA = rarities.findIndex(r => r.name === a[1].rarity);
                    const rarityB = rarities.findIndex(r => r.name === b[1].rarity);
                    return rarityB - rarityA;
                });
            
            sortedItems.forEach(([key, item]) => {
                // Don't show items beyond Ethereal (can't fuse to next tier)
                const rarityIndex = rarities.findIndex(r => r.name === item.rarity);
                if (rarityIndex >= rarities.length - 1) return;
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'inventory-item';
                itemDiv.style.borderColor = item.color;
                itemDiv.style.cursor = 'pointer';
                itemDiv.onclick = () => addToFusionSlot(key, item);
                
                itemDiv.innerHTML = `
                    <div style="font-size: 1.5rem;">ðŸ”®</div>
                    <div class="item-name" style="color: ${item.color};">${item.name}</div>
                    <div style="font-size: 0.8rem; color: ${item.color};">${item.rarity}</div>
                    <div class="item-value">x${item.count}</div>
                `;
                
                grid.appendChild(itemDiv);
            });
        }
        
        function addToFusionSlot(itemKey, item) {
            // Check how many of this item are already in fusion slots
            const alreadyInSlots = fusionSlots.filter(slot => slot && slot.key === itemKey).length;
            
            // Check if we have enough of this item
            if (alreadyInSlots >= item.count) {
                showNotification(`You only have ${item.count} of this item! Can't add more to fusion.`, 'var(--danger)');
                return;
            }
            
            // Find first empty slot
            const emptySlotIndex = fusionSlots.findIndex(slot => slot === null);
            if (emptySlotIndex === -1) {
                showNotification('All fusion slots are full! Clear slots first.', 'var(--warning)');
                return;
            }
            
            // Check if rarity matches (if other slots have items)
            const existingRarity = fusionSlots.find(slot => slot !== null)?.rarity;
            if (existingRarity && existingRarity !== item.rarity) {
                showNotification(`Items must be same rarity! Slots have ${existingRarity} items.`, 'var(--danger)');
                return;
            }
            
            fusionSlots[emptySlotIndex] = { key: itemKey, ...item };
            updateFusionSlots();
        }
        
        function updateFusionSlots() {
            const container = document.getElementById('fusionItemsContainer');
            if (!container) return;
            
            container.innerHTML = '';
            
            fusionSlots.forEach((slot, index) => {
                const slotDiv = document.createElement('div');
                slotDiv.className = 'stat-card';
                slotDiv.style.minHeight = '150px';
                slotDiv.style.display = 'flex';
                slotDiv.style.flexDirection = 'column';
                slotDiv.style.alignItems = 'center';
                slotDiv.style.justifyContent = 'center';
                
                if (slot) {
                    slotDiv.style.borderColor = slot.color;
                    slotDiv.style.cursor = 'pointer';
                    slotDiv.onclick = () => {
                        fusionSlots[index] = null;
                        updateFusionSlots();
                    };
                    slotDiv.innerHTML = `
                        <div style="font-size: 2rem; margin-bottom: 10px;">ðŸ”®</div>
                        <div style="color: ${slot.color}; font-weight: bold;">${slot.name}</div>
                        <div style="color: ${slot.color}; font-size: 0.9rem; margin-top: 5px;">${slot.rarity}</div>
                        <div style="color: var(--text-secondary); font-size: 0.8rem; margin-top: 10px;">Click to remove</div>
                    `;
                } else {
                    slotDiv.style.border = '2px dashed var(--accent-primary)';
                    slotDiv.innerHTML = `<span style="color: var(--text-secondary);">Item Slot ${index + 1}</span>`;
                }
                
                container.appendChild(slotDiv);
            });
            
            // Update fusion button
            const fusionButton = document.getElementById('fusionButton');
            if (fusionButton) {
                const canFuse = fusionSlots.every(slot => slot !== null);
                fusionButton.disabled = !canFuse;
                fusionButton.style.opacity = canFuse ? '1' : '0.5';
                fusionButton.style.cursor = canFuse ? 'pointer' : 'not-allowed';
            }
        }
        
        function performFusion() {
            if (fusionSlots.some(slot => slot === null)) {
                showNotification('All 3 slots must be filled!', 'var(--danger)');
                return;
            }
            
            // Verify all same rarity
            const rarity = fusionSlots[0].rarity;
            if (!fusionSlots.every(slot => slot.rarity === rarity)) {
                showNotification('All items must be the same rarity!', 'var(--danger)');
                return;
            }
            
            // Get the current rarity (NOT next rarity - we stay at same rarity!)
            const currentRarityIndex = rarities.findIndex(r => r.name === rarity);
            const currentRarity = rarities[currentRarityIndex];
            
            // Remove items from inventory
            fusionSlots.forEach(slot => {
                const item = gameState.inventory[slot.key];
                if (item && item.count > 0) {
                    item.count--;
                    gameState.totalValue -= item.value;
                    if (item.count === 0 && gameState.flexedItem === slot.key) {
                        gameState.flexedItem = null;
                    }
                }
            });
            
            // Create new RANDOM item of SAME rarity (not next tier!)
            const newItemName = generateItemName(currentRarity);
            addItemToInventory(newItemName, currentRarity);
            
            gameState.fusionCount++;
            playSound('fusion');
            showNotification(`âš—ï¸ FUSION SUCCESS! Created ${newItemName} (${rarity})!`, currentRarity.color);
            
            // Clear slots
            clearFusionSlots();
            updateStats();
            updateInventory();
            updateFusionInventory();
            updateStatistics();
            checkAchievements();
        }
        
        function clearFusionSlots() {
            fusionSlots.fill(null);
            updateFusionSlots();
        }
        
        // ===== STATISTICS SYSTEM =====
        function updateStatistics() {
            // Update rarity counts
            gameState.rarityCounts = {};
            Object.values(gameState.inventory).forEach(item => {
                if (item.count > 0) {
                    gameState.rarityCounts[item.rarity] = (gameState.rarityCounts[item.rarity] || 0) + item.count;
                }
            });
            
            // General Stats
            document.getElementById('statTotalSpins').textContent = formatNumber(gameState.totalSpins);
            document.getElementById('statTotalLogins').textContent = formatNumber(gameState.totalLogins || 0);
            document.getElementById('statLoginStreak').textContent = gameState.loginStreak || 0;
            document.getElementById('statRebirths').textContent = gameState.rebirths;
            document.getElementById('statQuestsCompleted').textContent = gameState.questsCompleted;
            
            // Money Stats
            document.getElementById('statCurrentMoney').textContent = formatNumber(gameState.money);
            document.getElementById('statTotalValue').textContent = formatNumber(gameState.totalValue);
            document.getElementById('statLifetimeEarned').textContent = formatNumber(gameState.lifetimeMoneyEarned || 0);
            document.getElementById('statLifetimeSpent').textContent = formatNumber(gameState.lifetimeMoneySpent || 0);
            const netProfit = (gameState.lifetimeMoneyEarned || 0) - (gameState.lifetimeMoneySpent || 0);
            document.getElementById('statNetProfit').textContent = formatNumber(netProfit);
            
            // Trading Stats
            document.getElementById('statTradeWins').textContent = formatNumber(gameState.tradeWins);
            document.getElementById('statTradeLosses').textContent = formatNumber(gameState.tradeLosses);
            const winRate = gameState.tradeWins + gameState.tradeLosses > 0 
                ? ((gameState.tradeWins / (gameState.tradeWins + gameState.tradeLosses)) * 100).toFixed(1) 
                : 0;
            document.getElementById('statWinRate').textContent = winRate;
            document.getElementById('statBiggestWin').textContent = formatNumber(gameState.biggestTradeWin || 0);
            document.getElementById('statBiggestLoss').textContent = formatNumber(gameState.biggestTradeLoss || 0);
            
            // Crafting Stats
            document.getElementById('statCrafted').textContent = formatNumber(gameState.craftCount || 0);
            document.getElementById('statEnchantSuccess').textContent = formatNumber(gameState.enchantSuccess || 0);
            document.getElementById('statEnchantFails').textContent = formatNumber(gameState.enchantFails || 0);
            const enchantTotal = (gameState.enchantSuccess || 0) + (gameState.enchantFails || 0);
            const enchantRate = enchantTotal > 0 
                ? (((gameState.enchantSuccess || 0) / enchantTotal) * 100).toFixed(1) 
                : 0;
            document.getElementById('statEnchantRate').textContent = enchantRate;
            document.getElementById('statShopPurchases').textContent = formatNumber(gameState.shopPurchases);
            
            // Collection Stats
            const uniqueItems = Object.keys(gameState.inventory).filter(k => gameState.inventory[k].count > 0).length;
            const totalItems = Object.values(gameState.inventory).reduce((sum, item) => sum + item.count, 0);
            document.getElementById('statUniqueItems').textContent = formatNumber(uniqueItems);
            document.getElementById('statTotalItems').textContent = formatNumber(totalItems);
            document.getElementById('statEventItems').textContent = formatNumber(gameState.itemsFromEvents || 0);
            const achievementCount = Object.values(gameState.achievements).filter(a => a).length;
            document.getElementById('statAchievements').textContent = `${achievementCount} / ${achievements.length}`;
            document.getElementById('statBPTier').textContent = gameState.battlePassTier;
            
            // Pity Stats
            const totalLuck = (gameState.luckMultiplier * gameState.permanentLuckBoost).toFixed(2);
            document.getElementById('statCurrentLuck').textContent = totalLuck;
            document.getElementById('statPityCounter').textContent = gameState.pityCounter || 0;
            document.getElementById('statPityThreshold').textContent = gameState.pityThreshold;
            document.getElementById('statPityTriggered').textContent = gameState.pityTriggered || 0;
            const pityPercent = ((gameState.pityCounter / gameState.pityThreshold) * 100).toFixed(1);
            document.getElementById('pityProgress').style.width = `${pityPercent}%`;
            document.getElementById('pityProgress').textContent = `${pityPercent}%`;
            
            // Rarity Distribution
            const rarityDist = document.getElementById('rarityDistribution');
            if (rarityDist) {
                rarityDist.innerHTML = '';
                Object.entries(gameState.rarityCounts).forEach(([rarityName, count]) => {
                    const rarity = rarities.find(r => r.name === rarityName);
                    if (rarity) {
                        const div = document.createElement('div');
                        div.style.cssText = `
                            display: flex;
                            justify-content: space-between;
                            padding: 8px;
                            margin: 5px 0;
                            background: var(--bg-dark);
                            border-left: 3px solid ${rarity.color};
                            border-radius: 5px;
                        `;
                        div.innerHTML = `
                            <span style="color: ${rarity.color}; font-weight: bold;">${rarityName}</span>
                            <span style="color: var(--text-primary);">${formatNumber(count)}</span>
                        `;
                        rarityDist.appendChild(div);
                    }
                });
            }
        }
        
        function saveGame(isAutoSave = false) {
            try {
                const saveData = {
                    inventory: gameState.inventory,
                    totalValue: gameState.totalValue,
                    money: gameState.money,
                    totalSpins: gameState.totalSpins,
                    luckMultiplier: gameState.luckMultiplier,
                    tradeWins: gameState.tradeWins,
                    tradeLosses: gameState.tradeLosses,
                    battlePassXP: gameState.battlePassXP,
                    achievements: gameState.achievements,
                    upgrades: gameState.upgrades,
                    rebirths: gameState.rebirths,
                    permanentLuckBoost: gameState.permanentLuckBoost,
                    settings: gameState.settings,
                    craftCount: gameState.craftCount,
                    enchantSuccess: gameState.enchantSuccess,
                    enchantFails: gameState.enchantFails,
                    adminUnlocked: gameState.adminUnlocked,
                    saveDate: new Date().toISOString()
                };
                
                localStorage.setItem('rngTraderSave', JSON.stringify(saveData));
                
                // Only show notification if it's a manual save OR if auto-save notifications are enabled
                if (!isAutoSave || gameState.settings.showAutoSaveNotifications) {
                    showNotification('Game saved successfully!', 'var(--success)');
                }
            } catch (error) {
                showNotification('Failed to save game!', 'var(--danger)');
                console.error('Save error:', error);
            }
        }
        
        function loadGame() {
            try {
                const saveData = localStorage.getItem('rngTraderSave');
                
                if (!saveData) {
                    showNotification('No save file found!', 'var(--warning)');
                    return;
                }
                
                if (!confirm('Loading will overwrite current progress. Continue?')) {
                    return;
                }
                
                const data = JSON.parse(saveData);
                
                // Load all saved data
                gameState.inventory = data.inventory || {};
                gameState.totalValue = data.totalValue || 0;
                gameState.money = data.money || 0;
                gameState.totalSpins = data.totalSpins || 0;
                gameState.luckMultiplier = data.luckMultiplier || 1.0;
                gameState.tradeWins = data.tradeWins || 0;
                gameState.tradeLosses = data.tradeLosses || 0;
                gameState.battlePassXP = data.battlePassXP || 0;
                gameState.achievements = data.achievements || {};
                gameState.upgrades = data.upgrades || {
                    spinSpeed: 0,
                    popularity: 0,
                    luckBoost: 0,
                    autoSpin: 0,
                    tradeInsight: 0,
                    valueBoost: 0,
                    craftingMastery: 0,
                    enchantPower: 0,
                    multiSpin: 0,
                    shopDiscount: 0,
                    rarityBoost: 0
                };
                // Ensure new upgrades exist in old saves
                if (gameState.upgrades.valueBoost === undefined) gameState.upgrades.valueBoost = 0;
                if (gameState.upgrades.craftingMastery === undefined) gameState.upgrades.craftingMastery = 0;
                if (gameState.upgrades.enchantPower === undefined) gameState.upgrades.enchantPower = 0;
                if (gameState.upgrades.multiSpin === undefined) gameState.upgrades.multiSpin = 0;
                if (gameState.upgrades.shopDiscount === undefined) gameState.upgrades.shopDiscount = 0;
                if (gameState.upgrades.rarityBoost === undefined) gameState.upgrades.rarityBoost = 0;
                if (gameState.upgrades.eventLuck === undefined) gameState.upgrades.eventLuck = 0;
                if (gameState.upgrades.xpBoost === undefined) gameState.upgrades.xpBoost = 0;
                if (gameState.upgrades.sellPrice === undefined) gameState.upgrades.sellPrice = 0;
                if (gameState.upgrades.questSpeed === undefined) gameState.upgrades.questSpeed = 0;
                if (gameState.upgrades.mysteryBox === undefined) gameState.upgrades.mysteryBox = 0;
                if (gameState.specialEventIsAdmin === undefined) gameState.specialEventIsAdmin = false;
                
                // Backwards compatibility for new features
                if (gameState.pityCounter === undefined) gameState.pityCounter = 0;
                if (gameState.pityThreshold === undefined) gameState.pityThreshold = 100;
                if (gameState.pityTriggered === undefined) gameState.pityTriggered = 0;
                if (gameState.lastLoginDate === undefined) gameState.lastLoginDate = null;
                if (gameState.loginStreak === undefined) gameState.loginStreak = 0;
                if (gameState.totalLogins === undefined) gameState.totalLogins = 0;
                if (gameState.loginRewardsClaimed === undefined) gameState.loginRewardsClaimed = [];
                if (gameState.lifetimeMoneyEarned === undefined) gameState.lifetimeMoneyEarned = 0;
                if (gameState.lifetimeMoneySpent === undefined) gameState.lifetimeMoneySpent = 0;
                if (gameState.biggestTradeWin === undefined) gameState.biggestTradeWin = 0;
                if (gameState.biggestTradeLoss === undefined) gameState.biggestTradeLoss = 0;
                if (gameState.rarityCounts === undefined) gameState.rarityCounts = {};
                if (gameState.itemsFromEvents === undefined) gameState.itemsFromEvents = 0;
                if (gameState.craftCount === undefined) gameState.craftCount = 0;
                if (gameState.enchantSuccess === undefined) gameState.enchantSuccess = 0;
                if (gameState.enchantFails === undefined) gameState.enchantFails = 0;
                if (gameState.fusionCount === undefined) gameState.fusionCount = 0;
                if (gameState.statisticsViewed === undefined) gameState.statisticsViewed = false;
                if (gameState.collectionBonuses === undefined) gameState.collectionBonuses = {discoComplete:false,galacticComplete:false,glitchComplete:false,fullmoonComplete:false,bloodmoonComplete:false,weatherComplete:false,christmasComplete:false};
                if (gameState.rarityMilestones === undefined) gameState.rarityMilestones = {};
                if (gameState.upgrades.autoFusion === undefined) gameState.upgrades.autoFusion = 0;
                if (gameState.notificationQueue === undefined) gameState.notificationQueue = [];
                if (gameState.isShowingNotification === undefined) gameState.isShowingNotification = false;
                
                gameState.rebirths = data.rebirths || 0;
                gameState.permanentLuckBoost = data.permanentLuckBoost || 1.0;
                gameState.settings = data.settings || {
                    soundEffects: true,
                    showTradeNotifications: true,
                    showExpiredNotifications: true,
                    showSpinResults: true,
                    showAchievementNotifications: true,
                    showRandomEvents: true,
                    showAutoSaveNotifications: false
                };
                // Ensure new setting exists in old saves
                if (gameState.settings.soundEffects === undefined) {
                    gameState.settings.soundEffects = true;
                }
                if (gameState.settings.showAutoSaveNotifications === undefined) {
                    gameState.settings.showAutoSaveNotifications = false;
                }
                gameState.craftCount = data.craftCount || 0;
                gameState.enchantSuccess = data.enchantSuccess || 0;
                gameState.enchantFails = data.enchantFails || 0;
                gameState.adminUnlocked = data.adminUnlocked || false;
                gameState.questsCompleted = data.questsCompleted || 0;
                gameState.dailyStreak = data.dailyStreak || 0;
                gameState.weeklyQuestsCompleted = data.weeklyQuestsCompleted || 0;
                gameState.shopPurchases = data.shopPurchases || 0;
                gameState.activeQuests = data.activeQuests || [];
                gameState.completedQuests = data.completedQuests || [];
                gameState.lastQuestRefresh = data.lastQuestRefresh || 0;
                gameState.claimedBPTiers = data.claimedBPTiers || [];
                
                // Update all displays
                updateStats();
                updateInventory();
                updateBattlePass();
                updateRebirthDisplay();
                refreshQuests();
                updateQuestDisplay();
                updateBossesDisplay();
                updateArtifactsDisplay();
                checkAchievements();
                
                const saveDate = data.saveDate ? new Date(data.saveDate) : 'Unknown';
                showNotification(`Game loaded! (Saved: ${saveDate})`, 'var(--success)');
            } catch (error) {
                showNotification('Failed to load game!', 'var(--danger)');
                console.error('Load error:', error);
            }
        }
        
        // ===== ADMIN FUNCTIONS =====
        
        function adminAddMoney(amount) {
            gameState.money += amount;
            updateStats();
            showNotification(`Admin: Added $${formatNumber(amount)}!`, 'var(--accent-gold)');
        }
        
        function adminSpawnItem() {
            const rarityIndex = parseInt(document.getElementById('adminRaritySelect').value);
            const count = parseInt(document.getElementById('adminItemCount').value) || 1;
            const rarity = rarities[rarityIndex];
            
            for (let i = 0; i < count; i++) {
                const itemName = generateItemName(rarity);
                addItemToInventory(itemName, rarity);
            }
            
            updateInventory();
            showNotification(`Admin: Spawned ${count}x ${rarity.name} item(s)!`, rarity.color);
        }
        
        function adminSetLuck(multiplier) {
            gameState.luckMultiplier = multiplier;
            updateStats();
            showNotification(`Admin: Luck set to ${multiplier}x`, 'var(--accent-primary)');
        }
        
        function adminMaxUpgrades() {
            for (const key in gameState.upgrades) {
                gameState.upgrades[key] = upgradeData[key].maxLevel;
            }
            // Apply effects
            gameState.luckMultiplier = 1.0 + (upgradeData.luckBoost.maxLevel * 0.1);
            updateStats();
            initUpgrades();
            showNotification('Admin: All upgrades maxed!', 'var(--success)');
        }
        
        function adminAddBPXP(amount) {
            gameState.battlePassXP += amount;
            updateBattlePass();
            showNotification(`Admin: Added ${formatNumber(amount)} BP XP`, 'var(--accent-primary)');
        }
        
        function adminMaxBP() {
            gameState.battlePassXP = battlePassTiers[battlePassTiers.length - 1].xpRequired;
            updateBattlePass();
            showNotification('Admin: Battle Pass maxed!', 'var(--accent-gold)');
        }
        
        function adminToggleChristmas() {
            gameState.christmasEvent = !gameState.christmasEvent;
            if (gameState.christmasEvent) {
                gameState.christmasEventEnd = new Date(Date.now() + 5 * 60000);
            } else {
                gameState.christmasEventEnd = null;
            }
            updateEventBonuses();
            showNotification(`Admin: Christmas Event ${gameState.christmasEvent ? 'Activated' : 'Deactivated'}!`, '#ff0000');
        }
        
        function adminSpawnTrade() {
            generateNPCTrade();
            showNotification('Admin: Spawned trade!', 'var(--accent-primary)');
        }
        
        function adminStartWeatherEvent(eventType) {
            startWeatherEvent(eventType);
            showNotification(`Admin: Started ${eventType} event!`, '#00aaff');
        }
        
        function adminStartSpecialEvent(eventType) {
            startSpecialEvent(eventType);
            const eventColors = {
                disco: '#ff00ff',
                galactic: '#4B0082',
                glitch: '#00ff00',
                fullmoon: '#f0f0f0',
                bloodmoon: '#8B0000'
            };
            showNotification(`Admin: Started ${eventType} event!`, eventColors[eventType]);
        }
        
        function adminClearInventory() {
            if (!confirm('Clear entire inventory?')) return;
            gameState.inventory = {};
            gameState.totalValue = 0;
            gameState.flexedItem = null;
            updateStats();
            updateInventory();
            showNotification('Admin: Inventory cleared!', 'var(--warning)');
        }
        
        function adminDuplicateInventory() {
            let duplicatedItems = 0;
            for (const [key, item] of Object.entries(gameState.inventory)) {
                if (item.count > 0) {
                    const originalCount = item.count;
                    item.count *= 2;
                    gameState.totalValue += item.value * originalCount;
                    duplicatedItems += originalCount;
                }
            }
            updateStats();
            updateInventory();
            showNotification(`Admin: Duplicated ${duplicatedItems} items!`, 'var(--success)');
        }
        
        function adminUnlockAllAchievements() {
            achievements.forEach(achievement => {
                if (!gameState.achievements[achievement.id]) {
                    gameState.achievements[achievement.id] = true;
                }
            });
            checkAchievements();
            showNotification('Admin: All achievements unlocked!', 'var(--accent-gold)');
        }
        
        function adminResetAchievements() {
            if (!confirm('Reset all achievements?')) return;
            gameState.achievements = {};
            checkAchievements();
            showNotification('Admin: Achievements reset!', 'var(--warning)');
        }
        
        function adminSetSpins(amount) {
            gameState.totalSpins = amount;
            updateStats();
            checkAchievements();
            showNotification(`Admin: Set spins to ${formatNumber(amount)}!`, 'var(--accent-primary)');
        }
        
        function adminAddRebirths(amount) {
            gameState.rebirths += amount;
            gameState.permanentLuckBoost += (amount * 2.0);
            updateStats();
            updateRebirthDisplay();
            showNotification(`Admin: Added ${amount} rebirth(s)!`, 'var(--accent-gold)');
        }
        
        function adminSetTradeWins(amount) {
            gameState.tradeWins = amount;
            updateStats();
            checkAchievements();
            showNotification(`Admin: Set trade wins to ${formatNumber(amount)}!`, 'var(--accent-primary)');
        }
        
        function adminCompleteEverything() {
            if (!confirm('This will max out upgrades, battle pass, money, and unlock achievements. Continue?')) return;
            
            // Max upgrades
            for (const key in gameState.upgrades) {
                gameState.upgrades[key] = upgradeData[key].maxLevel;
            }
            gameState.luckMultiplier = 1.0 + (upgradeData.luckBoost.maxLevel * 0.1);
            
            // Max battle pass
            gameState.battlePassXP = battlePassTiers[battlePassTiers.length - 1].xpRequired;
            
            // Add money
            gameState.money += 100000000;
            
            // Unlock achievements
            achievements.forEach(achievement => {
                gameState.achievements[achievement.id] = true;
            });
            
            updateStats();
            updateBattlePass();
            initUpgrades();
            checkAchievements();
            
            showNotification('Admin: Everything completed!', 'var(--accent-gold)');
        }
        
        function adminResetGame() {
            if (confirm('Are you SURE you want to reset all progress? This cannot be undone!')) {
                if (confirm('Last chance! Reset everything?')) {
                    localStorage.removeItem('rngTraderSave');
                    location.reload();
                }
            }
        }
        
        function updateEventBonuses() {
            const bonusesDiv = document.getElementById('eventBonuses');
            let activeEvents = [];
            
            if (gameState.christmasEvent) {
                const timeLeft = gameState.christmasEventEnd ? Math.max(0, Math.floor((gameState.christmasEventEnd - new Date()) / 1000)) : 300;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                activeEvents.push(`
                    <div class="stat-card">
                        <div class="stat-label">ðŸŽ„ Holiday Luck</div>
                        <div class="stat-value" style="color: var(--success);">+15% Holiday Items</div>
                        <div class="stat-label" style="margin-top: 5px;">Time: ${minutes}:${seconds.toString().padStart(2, '0')}</div>
                    </div>
                `);
            }
            
            if (gameState.specialEvent) {
                const timeLeft = Math.max(0, Math.floor((gameState.specialEventEnd - Date.now()) / 1000));
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                const eventNames = { 
                    disco: 'ðŸª© Disco', 
                    galactic: 'ðŸŒŒ Galactic', 
                    glitch: 'âš¡ Glitch', 
                    fullmoon: 'ðŸŒ• Full Moon', 
                    bloodmoon: 'ðŸ”´ Blood Moon' 
                };
                const eventColors = {
                    disco: '#ff00ff',
                    galactic: '#4B0082',
                    glitch: '#00ff00',
                    fullmoon: '#f0f0f0',
                    bloodmoon: '#8B0000'
                };
                activeEvents.push(`
                    <div class="stat-card">
                        <div class="stat-label">${eventNames[gameState.specialEvent]} Event</div>
                        <div class="stat-value" style="color: ${eventColors[gameState.specialEvent]};">Special Items! 40%</div>
                        <div class="stat-label" style="margin-top: 5px;">Time: ${minutes}:${seconds.toString().padStart(2, '0')}</div>
                    </div>
                `);
            }
            
            if (gameState.weatherEvent) {
                const timeLeft = Math.max(0, Math.floor((gameState.weatherEventEnd - Date.now()) / 1000));
                const eventNames = { cloudy: 'â˜ï¸ Cloudy', rainy: 'ðŸŒ§ï¸ Rainy', storming: 'â›ˆï¸ Storming' };
                activeEvents.push(`
                    <div class="stat-card">
                        <div class="stat-label">${eventNames[gameState.weatherEvent]} Event</div>
                        <div class="stat-value" style="color: var(--accent-primary);">Weather Items! 30%</div>
                        <div class="stat-label" style="margin-top: 5px;">Time: ${timeLeft}s</div>
                    </div>
                `);
            }
            
            if (activeEvents.length > 0) {
                bonusesDiv.innerHTML = activeEvents.join('');
            } else {
                const now = new Date();
                const currentMinute = now.getMinutes();
                const currentHour = now.getHours();
                
                // Calculate next event
                let nextEventText = '';
                if (currentMinute < 15) {
                    nextEventText = `ðŸª© Disco in ${15 - currentMinute} min`;
                } else if (currentMinute < 20) {
                    nextEventText = `ðŸŒ• Full Moon in ${20 - currentMinute} min`;
                } else if (currentMinute < 30) {
                    nextEventText = `ðŸŒŒ Galactic in ${30 - currentMinute} min`;
                } else if (currentMinute < 45) {
                    nextEventText = `âš¡ Glitch in ${45 - currentMinute} min`;
                } else if (currentMinute < 50) {
                    nextEventText = `ðŸ”´ Blood Moon in ${50 - currentMinute} min`;
                } else {
                    nextEventText = `ðŸŽ„ Christmas in ${60 - currentMinute} min`;
                }
                
                bonusesDiv.innerHTML = `
                    <p style="color: var(--text-secondary);">No active event bonuses</p>
                    <p style="color: var(--accent-gold); margin-top: 10px; font-weight: bold;">Next: ${nextEventText}</p>
                    <p style="color: var(--text-secondary); margin-top: 5px; font-size: 0.9rem;">Weather events happen randomly</p>
                `;
            }
        }
        
        function triggerRandomEvent() {
            const events = [
                { name: 'Lucky Streak!', effect: () => { gameState.luckMultiplier += 0.2; }, message: 'Luck increased by 0.2x!' },
                { name: 'Mysterious Trader', effect: () => { gameState.money += 5000; }, message: 'A mysterious trader gave you $5,000!' },
                { name: 'Item Duplication', effect: () => {
                    const keys = Object.keys(gameState.inventory).filter(k => gameState.inventory[k].count > 0);
                    if (keys.length > 0) {
                        const key = keys[Math.floor(Math.random() * keys.length)];
                        gameState.inventory[key].count++;
                        gameState.totalValue += gameState.inventory[key].value;
                    }
                }, message: 'A random item was duplicated!' }
            ];
            
            const event = events[Math.floor(Math.random() * events.length)];
            event.effect();
            showNotification(`ðŸŽ‰ ${event.name}: ${event.message}`, 'var(--accent-gold)');
            updateStats();
            updateInventory();
        }
        
        function showNotification(message, color) {
            // Check settings before showing certain notifications
            if (message.includes('wants to trade') && !gameState.settings.showTradeNotifications) return;
            if (message.includes('expired') && !gameState.settings.showExpiredNotifications) return;
            if (message.includes('You got:') && !gameState.settings.showSpinResults) return;
            if (message.includes('Achievement') && !gameState.settings.showAchievementNotifications) return;
            if (message.includes('Random Event') && !gameState.settings.showRandomEvents) return;
            
            // Add to queue
            gameState.notificationQueue.push({ message, color });
            
            // Process queue if not already processing
            if (!gameState.isShowingNotification) {
                processNotificationQueue();
            }
        }
        
        function processNotificationQueue() {
            if (gameState.notificationQueue.length === 0) {
                gameState.isShowingNotification = false;
                return;
            }
            
            gameState.isShowingNotification = true;
            const { message, color } = gameState.notificationQueue.shift();
            
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.style.borderColor = color;
            notification.innerHTML = `<strong style="color: ${color};">${message}</strong>`;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideInRight 0.5s ease-out reverse';
                setTimeout(() => {
                    notification.remove();
                    // Process next notification after a small delay
                    setTimeout(() => processNotificationQueue(), 200);
                }, 500);
            }, 2000); // Reduced from 3000 to 2000 for faster queue processing
        }
        
        function unlockAdmin() {
            const password = document.getElementById('adminPasswordInput').value;
            if (password === ADMIN_PASSWORD) {
                gameState.adminUnlocked = true;
                document.getElementById('adminLogin').style.display = 'none';
                document.getElementById('adminPanel').style.display = 'block';
                showNotification('Admin panel unlocked!', 'var(--success)');
            } else {
                showNotification('Incorrect password!', 'var(--danger)');
                document.getElementById('adminPasswordInput').value = '';
            }
        }
        
        function updateSettings() {
            gameState.settings.soundEffects = document.getElementById('settingSoundEffects').checked;
            gameState.settings.showTradeNotifications = document.getElementById('settingTradeNotif').checked;
            gameState.settings.showExpiredNotifications = document.getElementById('settingExpiredNotif').checked;
            gameState.settings.showSpinResults = document.getElementById('settingSpinNotif').checked;
            gameState.settings.showAchievementNotifications = document.getElementById('settingAchievementNotif').checked;
            gameState.settings.showRandomEvents = document.getElementById('settingEventNotif').checked;
            gameState.settings.showAutoSaveNotifications = document.getElementById('settingAutoSaveNotif').checked;
            gameState.settings.showPityNotifications = document.getElementById('settingPityNotif').checked;
            gameState.settings.showFusionNotifications = document.getElementById('settingFusionNotif').checked;
            gameState.settings.showCollectionNotifications = document.getElementById('settingCollectionNotif').checked;
            gameState.settings.confirmSell = document.getElementById('settingConfirmSell').checked;
            gameState.settings.animations = document.getElementById('settingAnimations').checked;
            gameState.settings.compactMode = document.getElementById('settingCompactMode').checked;
            gameState.settings.showValue = document.getElementById('settingShowValue').checked;
            gameState.settings.autoSaveInterval = parseInt(document.getElementById('settingAutoSaveInterval').value);
            showNotification('Settings saved!', 'var(--success)');
        }
        
        function updateRebirthDisplay() {
            const rebirthLevel = gameState.rebirths || 0;
            document.getElementById('rebirthCount').textContent = rebirthLevel;
            document.getElementById('permanentLuck').textContent = gameState.permanentLuckBoost.toFixed(1) + 'x';
            
            // Show next rebirth requirements
            const moneyRequired = Math.floor(1000000 * Math.pow(2, Math.min(rebirthLevel, 20)));
            let requiredRarityIndex = 5 + Math.floor(rebirthLevel / 5);
            requiredRarityIndex = Math.min(requiredRarityIndex, rarities.length - 1);
            const requiredRarity = rarities[requiredRarityIndex];
            
            // Calculate next rebirth bonus
            let luckBonus = 2.0;
            if (rebirthLevel >= 10) luckBonus += 1.0;
            if (rebirthLevel >= 25) luckBonus += 2.0;
            if (rebirthLevel >= 50) luckBonus += 5.0;
            
            const reqDisplay = document.getElementById('rebirthRequirements');
            if (reqDisplay) {
                reqDisplay.innerHTML = `
                    <p style="color: var(--accent-gold);">Next Rebirth Requirements:</p>
                    <p style="color: var(--text-secondary);">ðŸ’° Money: $${formatNumber(moneyRequired)}</p>
                    <p style="color: ${requiredRarity.color};">âœ¨ Item: ${requiredRarity.name}+ rarity</p>
                    <p style="color: var(--success);">ðŸŽ Reward: +${luckBonus}x permanent luck</p>
                `;
            }
        }
        
        function performRebirth() {
            // Calculate rebirth requirements based on current rebirth count
            const rebirthLevel = gameState.rebirths || 0;
            
            // Scaling money requirement
            const moneyRequired = Math.floor(1000000 * Math.pow(2, Math.min(rebirthLevel, 20))); // Caps at 2^20 multiplier
            
            // Scaling rarity requirement
            let requiredRarityIndex = 5 + Math.floor(rebirthLevel / 5); // Mythic at 0, increases every 5 rebirths
            requiredRarityIndex = Math.min(requiredRarityIndex, rarities.length - 1);
            const requiredRarity = rarities[requiredRarityIndex];
            
            // Check money requirement
            if (gameState.money < moneyRequired) {
                showNotification(`Need $${formatNumber(moneyRequired)} to rebirth!`, 'var(--danger)');
                return;
            }
            
            // Check for required rarity item
            const hasRequiredRarity = Object.keys(gameState.inventory).some(key => {
                const item = gameState.inventory[key];
                if (item.count === 0) return false;
                const rarityIndex = rarities.findIndex(r => r.name === item.rarity);
                return rarityIndex >= requiredRarityIndex;
            });
            
            if (!hasRequiredRarity) {
                showNotification(`Need at least 1 ${requiredRarity.name} (or higher) item to rebirth!`, 'var(--danger)');
                return;
            }
            
            // Confirm rebirth
            if (!confirm(`Rebirth #${rebirthLevel + 1}\n\nCost: $${formatNumber(moneyRequired)}\nRequired: ${requiredRarity.name}+ item\n\nYou will lose ALL progress except achievements!\n\nContinue?`)) {
                return;
            }
            
            // Calculate rebirth rewards
            let luckBonus = 2.0; // Base luck bonus
            
            // Scaling bonuses for higher rebirths
            if (rebirthLevel >= 10) luckBonus += 1.0;
            if (rebirthLevel >= 25) luckBonus += 2.0;
            if (rebirthLevel >= 50) luckBonus += 5.0;
            
            // Perform rebirth
            gameState.rebirths++;
            gameState.permanentLuckBoost += luckBonus;
            
            // Reset everything except achievements, rebirths, and permanent luck
            const savedAchievements = { ...gameState.achievements };
            const savedRebirths = gameState.rebirths;
            const savedPermanentLuck = gameState.permanentLuckBoost;
            const savedSettings = { ...gameState.settings };
            const savedAdminUnlocked = gameState.adminUnlocked;
            const savedQuestsCompleted = gameState.questsCompleted || 0;
            const savedDailyStreak = gameState.dailyStreak || 0;
            const savedWeeklyQuestsCompleted = gameState.weeklyQuestsCompleted || 0;
            
            // Clear inventory
            gameState.inventory = {};
            gameState.totalValue = 0;
            gameState.money = 0;
            gameState.totalSpins = 0;
            gameState.luckMultiplier = 1.0; // Start fresh at 1.0, permanent luck applies separately
            gameState.tradeWins = 0;
            gameState.tradeLosses = 0;
            gameState.flexedItem = null;
            gameState.battlePassTier = 0;
            gameState.battlePassXP = 0;
            gameState.claimedBPTiers = [];
            gameState.enchantmentTarget = null;
            gameState.activeTrades = [];
            gameState.activeQuests = [];
            gameState.completedQuests = [];
            gameState.lastQuestRefresh = 0;
            gameState.shopPurchases = 0;
            gameState.upgrades = {
                spinSpeed: 0,
                popularity: 0,
                luckBoost: 0,
                autoSpin: 0,
                tradeInsight: 0,
                valueBoost: 0,
                craftingMastery: 0,
                enchantPower: 0,
                multiSpin: 0,
                shopDiscount: 0,
                rarityBoost: 0,
                eventLuck: 0,
                xpBoost: 0,
                sellPrice: 0,
                questSpeed: 0,
                mysteryBox: 0
            };
            gameState.craftCount = 0;
            gameState.enchantSuccess = 0;
            gameState.enchantFails = 0;
            
            // Restore what shouldn't be reset
            gameState.achievements = savedAchievements;
            gameState.rebirths = savedRebirths;
            gameState.permanentLuckBoost = savedPermanentLuck;
            gameState.settings = savedSettings;
            gameState.adminUnlocked = savedAdminUnlocked;
            gameState.questsCompleted = savedQuestsCompleted;
            gameState.dailyStreak = savedDailyStreak;
            gameState.weeklyQuestsCompleted = savedWeeklyQuestsCompleted;
            
            // Refresh quests
            refreshQuests();
            
            // Update all displays
            updateStats();
            updateInventory();
            updateBattlePass();
            updateRebirthDisplay();
            updateQuestDisplay();
            checkAchievements();
            
            showNotification(`ðŸŽ‰ REBIRTH #${gameState.rebirths} COMPLETE! Permanent luck is now ${gameState.permanentLuckBoost.toFixed(1)}x! (+${luckBonus}x this rebirth) ðŸŽ‰`, 'var(--accent-gold)');
        }
        
        function initBattlePass() {
            const tiersDiv = document.getElementById('bpTiers');
            tiersDiv.innerHTML = '';
            
            battlePassTiers.forEach(tier => {
                const unlocked = gameState.battlePassXP >= tier.xpRequired;
                
                const tierDiv = document.createElement('div');
                tierDiv.className = 'battlepass-tier' + (unlocked ? ' unlocked' : '');
                tierDiv.innerHTML = `
                    <div>
                        <h3 style="color: var(--accent-primary);">Tier ${tier.tier}</h3>
                        <p style="color: var(--text-secondary);">${formatNumber(tier.xpRequired)} XP Required</p>
                        <p style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 5px;">Current: ${formatNumber(gameState.battlePassXP)} XP</p>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 1.5rem;">${unlocked ? 'âœ…' : 'ðŸ”’'}</div>
                        <div style="color: var(--accent-gold); font-weight: bold;">${tier.reward}</div>
                    </div>
                `;
                tiersDiv.appendChild(tierDiv);
            });
        }
        
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            // Close mobile menu when tab is selected
            closeMobileMenu();
            
            if (tabName === 'inventory') updateInventory();
            if (tabName === 'shop') initShop();
            if (tabName === 'upgrades') initUpgrades();
            if (tabName === 'trading') {
                // Trading tab is now automatically populated
            }
            if (tabName === 'crafting') {
                document.getElementById('craftingGrid').innerHTML = '';
                initCrafting();
            }
            if (tabName === 'enchanting') {
                updateEnchantInventory();
            }
            if (tabName === 'quests') {
                updateQuestDisplay();
            }
            if (tabName === 'fusion') {
                updateFusionInventory();
                updateFusionSlots();
            }
            if (tabName === 'statistics') {
                gameState.statisticsViewed = true;
                updateStatistics();
                checkAchievements();
            }
            if (tabName === 'collections') {
                updateCollectionsDisplay();
            }
            if (tabName === 'settings') {
                // Load current settings
                document.getElementById('settingSoundEffects').checked = gameState.settings.soundEffects !== false;
                document.getElementById('settingTradeNotif').checked = gameState.settings.showTradeNotifications;
                document.getElementById('settingExpiredNotif').checked = gameState.settings.showExpiredNotifications;
                document.getElementById('settingSpinNotif').checked = gameState.settings.showSpinResults;
                document.getElementById('settingAchievementNotif').checked = gameState.settings.showAchievementNotifications;
                document.getElementById('settingEventNotif').checked = gameState.settings.showRandomEvents;
                document.getElementById('settingAutoSaveNotif').checked = gameState.settings.showAutoSaveNotifications;
                document.getElementById('settingPityNotif').checked = gameState.settings.showPityNotifications !== false;
                document.getElementById('settingFusionNotif').checked = gameState.settings.showFusionNotifications !== false;
                document.getElementById('settingCollectionNotif').checked = gameState.settings.showCollectionNotifications !== false;
                document.getElementById('settingConfirmSell').checked = gameState.settings.confirmSell || false;
                document.getElementById('settingAnimations').checked = gameState.settings.animations !== false;
                document.getElementById('settingCompactMode').checked = gameState.settings.compactMode || false;
                document.getElementById('settingShowValue').checked = gameState.settings.showValue !== false;
                document.getElementById('settingAutoSaveInterval').value = gameState.settings.autoSaveInterval || 60;
            }
            if (tabName === 'rebirth') {
                updateRebirthDisplay();
            }
            if (tabName === 'dailies') {
                generateDailyChallenges();
                updateDailyChallengesDisplay();
                updateAchievementPointsDisplay();
            }
            if (tabName === 'achievementshop') {
                updateAchievementShopDisplay();
                updateAchievementPointsDisplay();
            }
            if (tabName === 'pets') {
                updatePetsDisplay();
            }
            if (tabName === 'prestige') {
                updatePrestigeDisplay();
            }
            if (tabName === 'bosses') {
                updateBossesDisplay();
            }
            if (tabName === 'artifacts') {
                updateArtifactsDisplay();
            }
            if (tabName === 'admin') {
                if (gameState.adminUnlocked) {
                    document.getElementById('adminLogin').style.display = 'none';
                    document.getElementById('adminPanel').style.display = 'block';
                } else {
                    document.getElementById('adminLogin').style.display = 'block';
                    document.getElementById('adminPanel').style.display = 'none';
                }
            }
        }
        
        // ===== MOBILE SUPPORT FUNCTIONS =====
        
        function toggleMobileMenu() {
            const tabNav = document.getElementById('tabNav');
            const btn = document.getElementById('mobileMenuBtn');
            
            if (tabNav.classList.contains('mobile-open')) {
                closeMobileMenu();
            } else {
                openMobileMenu();
            }
        }
        
        function openMobileMenu() {
            const tabNav = document.getElementById('tabNav');
            const btn = document.getElementById('mobileMenuBtn');
            tabNav.classList.add('mobile-open');
            btn.textContent = 'âœ•';
        }
        
        function closeMobileMenu() {
            const tabNav = document.getElementById('tabNav');
            const btn = document.getElementById('mobileMenuBtn');
            tabNav.classList.remove('mobile-open');
            btn.textContent = 'â˜°';
        }
        
        // Close mobile menu when clicking outside
        document.addEventListener('click', (e) => {
            const tabNav = document.getElementById('tabNav');
            const btn = document.getElementById('mobileMenuBtn');
            
            if (tabNav && btn && tabNav.classList.contains('mobile-open')) {
                if (!tabNav.contains(e.target) && !btn.contains(e.target)) {
                    closeMobileMenu();
                }
            }
        });
        
        // Swipe gestures for mobile navigation
        let touchStartX = 0;
        let touchEndX = 0;
        
        document.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
        });
        
        document.addEventListener('touchend', e => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        });
        
        function handleSwipe() {
            const swipeThreshold = 100; // Minimum distance for swipe
            const tabNav = document.getElementById('tabNav');
            
            if (touchEndX < touchStartX - swipeThreshold) {
                // Swipe left - close menu
                closeMobileMenu();
            }
            
            if (touchEndX > touchStartX + swipeThreshold && touchStartX < 50) {
                // Swipe right from left edge - open menu
                openMobileMenu();
            }
        }
        
        // Detect mobile device
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   window.innerWidth <= 768;
        }
        
        // Vibration feedback helper
        function vibrate(duration = 10) {
            if (navigator.vibrate) {
                navigator.vibrate(duration);
            }
        }
        
        // Prevent zoom on double-tap for specific elements
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        // Adjust UI for mobile on load
        window.addEventListener('resize', () => {
            if (window.innerWidth > 768) {
                closeMobileMenu();
            }
        });
        
        // ===== TUTORIAL SYSTEM =====
        
        const tutorialSteps = [
            {
                title: "Welcome to RNG Trader!",
                message: "Click the ðŸŽ° Spin button to get your first item!",
                tab: "spin",
                highlight: null
            },
            {
                title: "Check Your Inventory",
                message: "Great! Now go to the ðŸŽ’ Inventory tab to see your items.",
                tab: "inventory",
                highlight: null
            },
            {
                title: "Visit the Shop",
                message: "You can buy items with money in the ðŸª Shop tab!",
                tab: "shop",
                highlight: null
            },
            {
                title: "Upgrade Your Game",
                message: "Permanent upgrades are in the â¬†ï¸ Upgrades tab!",
                tab: "upgrades",
                highlight: null
            },
            {
                title: "You're Ready!",
                message: "Explore trading, crafting, achievements, and more! Have fun! ðŸŽ‰",
                tab: null,
                highlight: null
            }
        ];
        
        function startTutorial() {
            if (gameState.tutorialComplete || gameState.tutorialSkipped) return;
            gameState.tutorialStep = 0;
            showTutorialStep();
        }
        
        function showTutorialStep() {
            if (gameState.tutorialStep >= tutorialSteps.length) {
                gameState.tutorialComplete = true;
                closeTutorialModal();
                showNotification('ðŸŽ‰ Tutorial Complete! Enjoy the game!', 'var(--success)');
                return;
            }
            
            const step = tutorialSteps[gameState.tutorialStep];
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10001; display: flex; align-items: center; justify-content: center; padding: 20px;';
            modal.innerHTML = `
                <div style="background: var(--bg-medium); padding: 30px; border-radius: 15px; max-width: 500px; width: 100%; border: 3px solid var(--accent-primary); box-shadow: 0 0 30px var(--accent-primary);">
                    <h2 style="color: var(--accent-primary); margin-bottom: 15px;">ðŸ“š Tutorial (${gameState.tutorialStep + 1}/${tutorialSteps.length})</h2>
                    <h3 style="color: var(--accent-gold); margin-bottom: 15px;">${step.title}</h3>
                    <p style="color: var(--text-primary); font-size: 1.1rem; margin: 20px 0; line-height: 1.6;">${step.message}</p>
                    <div style="display: flex; gap: 10px; margin-top: 30px;">
                        <button onclick="nextTutorialStep()" class="btn btn-accept" style="flex: 1; padding: 15px; font-size: 1.1rem;">
                            ${gameState.tutorialStep === tutorialSteps.length - 1 ? 'ðŸŽ‰ Finish' : 'Next âž¡ï¸'}
                        </button>
                        <button onclick="skipTutorial()" class="btn btn-decline" style="padding: 15px;">Skip</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Auto-switch to relevant tab
            if (step.tab) {
                setTimeout(() => switchTab(step.tab), 500);
            }
        }
        
        function nextTutorialStep() {
            gameState.tutorialStep++;
            closeTutorialModal();
            setTimeout(showTutorialStep, 300);
        }
        
        function skipTutorial() {
            gameState.tutorialSkipped = true;
            closeTutorialModal();
            showNotification('Tutorial skipped. You can restart it in Settings!', 'var(--text-secondary)');
        }
        
        function closeTutorialModal() {
            const modal = document.getElementById('tutorialModal');
            if (modal) modal.remove();
        }
        
        function resetTutorial() {
            gameState.tutorialStep = 0;
            gameState.tutorialComplete = false;
            gameState.tutorialSkipped = false;
            startTutorial();
        }
        
        // ===== DAILY CHALLENGES SYSTEM =====
        
        const dailyChallengeTemplates = [
            { id: 'spin50', name: 'Spin Master', desc: 'Spin 50 items', goal: 50, type: 'spins', reward: { money: 25000, points: 3 } },
            { id: 'spin100', name: 'Spin Grinder', desc: 'Spin 100 items', goal: 100, type: 'spins', reward: { money: 60000, points: 5 } },
            { id: 'trade10', name: 'Trader', desc: 'Win 10 trades', goal: 10, type: 'tradeWins', reward: { money: 20000, points: 4 } },
            { id: 'trade25', name: 'Trade Expert', desc: 'Win 25 trades', goal: 25, type: 'tradeWins', reward: { money: 50000, points: 7 } },
            { id: 'craft5', name: 'Crafter', desc: 'Craft 5 items', goal: 5, type: 'crafts', reward: { money: 15000, points: 3 } },
            { id: 'craft15', name: 'Master Crafter', desc: 'Craft 15 items', goal: 15, type: 'crafts', reward: { money: 40000, points: 6 } },
            { id: 'money100k', name: 'Money Maker', desc: 'Earn $100,000', goal: 100000, type: 'moneyEarned', reward: { money: 30000, points: 4 } },
            { id: 'money500k', name: 'Big Earner', desc: 'Earn $500,000', goal: 500000, type: 'moneyEarned', reward: { money: 100000, points: 8 } },
            { id: 'legendary3', name: 'Legend Hunter', desc: 'Get 3 Legendary+ items', goal: 3, type: 'legendaryItems', reward: { money: 50000, points: 10 } },
            { id: 'rare20', name: 'Rare Collector', desc: 'Get 20 Rare+ items', goal: 20, type: 'rareItems', reward: { money: 35000, points: 5 } }
        ];
        
        function generateDailyChallenges() {
            // Check if need to reset (daily at midnight)
            const now = Date.now();
            const lastReset = gameState.lastDailyChallengeReset || 0;
            const dayInMs = 86400000;
            
            if (now - lastReset < dayInMs && gameState.dailyChallenges.length > 0) {
                return; // Not time to reset yet
            }
            
            // Generate 3 random challenges
            const shuffled = [...dailyChallengeTemplates].sort(() => Math.random() - 0.5);
            gameState.dailyChallenges = shuffled.slice(0, 3).map(template => ({
                ...template,
                progress: 0,
                completed: false
            }));
            
            gameState.dailyChallengesCompleted = [];
            gameState.lastDailyChallengeReset = now;
            
            showNotification('ðŸ“… New Daily Challenges available!', 'var(--accent-primary)');
        }
        
        function updateDailyChallengeProgress(type, amount = 1) {
            if (!gameState.dailyChallenges) return;
            
            for (let challenge of gameState.dailyChallenges) {
                if (challenge.type === type && !challenge.completed) {
                    challenge.progress += amount;
                    
                    if (challenge.progress >= challenge.goal) {
                        challenge.progress = challenge.goal;
                        // Will be claimed manually
                    }
                }
            }
        }
        
        function claimDailyChallenge(index) {
            const challenge = gameState.dailyChallenges[index];
            if (!challenge || challenge.completed || challenge.progress < challenge.goal) {
                showNotification('âŒ Challenge not complete!', 'var(--danger)');
                return;
            }
            
            challenge.completed = true;
            gameState.money += challenge.reward.money;
            gameState.achievementPoints += challenge.reward.points;
            
            showNotification(`âœ… ${challenge.name} Complete! +$${formatNumber(challenge.reward.money)} +${challenge.reward.points} Points!`, 'var(--success)');
            updateDailyChallengesDisplay();
            updateAchievementPointsDisplay();
        }
        
        function updateDailyChallengesDisplay() {
            const container = document.getElementById('dailyChallengesContainer');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (!gameState.dailyChallenges || gameState.dailyChallenges.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">Generating challenges...</p>';
                generateDailyChallenges();
                setTimeout(updateDailyChallengesDisplay, 100);
                return;
            }
            
            gameState.dailyChallenges.forEach((challenge, index) => {
                const progress = Math.min(challenge.progress, challenge.goal);
                const percent = (progress / challenge.goal * 100).toFixed(0);
                const isComplete = challenge.progress >= challenge.goal;
                const isClaimed = challenge.completed;
                
                const card = document.createElement('div');
                card.className = 'recipe-card';
                card.style.border = isClaimed ? '2px solid var(--success)' : isComplete ? '2px solid var(--accent-gold)' : '';
                card.innerHTML = `
                    <h3 style="color: var(--accent-primary);">${challenge.name}</h3>
                    <p style="color: var(--text-secondary); margin: 10px 0;">${challenge.desc}</p>
                    <div class="progress-bar" style="margin: 15px 0;">
                        <div class="progress-fill" style="width: ${percent}%; background: ${isClaimed ? 'var(--success)' : 'var(--accent-gold)'};">
                            ${progress} / ${challenge.goal}
                        </div>
                    </div>
                    <div style="margin: 10px 0; color: var(--accent-gold);">
                        Rewards: $${formatNumber(challenge.reward.money)} + ${challenge.reward.points} Points
                    </div>
                    <button class="btn ${isClaimed ? 'btn-decline' : isComplete ? 'btn-accept' : 'btn-decline'}" 
                            onclick="claimDailyChallenge(${index})" 
                            ${isClaimed || !isComplete ? 'disabled' : ''}
                            style="${isClaimed || !isComplete ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
                        ${isClaimed ? 'âœ… Claimed' : isComplete ? 'ðŸŽ Claim Reward' : 'ðŸ”’ Incomplete'}
                    </button>
                `;
                container.appendChild(card);
            });
        }
        
        // ===== ACHIEVEMENT SHOP SYSTEM =====
        
        const achievementShopItems = [
            { id: 'perm_luck_1', name: 'Lucky Charm I', desc: '+5% Permanent Luck', cost: 10, bonus: { type: 'luck', value: 0.05 } },
            { id: 'perm_luck_2', name: 'Lucky Charm II', desc: '+10% Permanent Luck', cost: 25, bonus: { type: 'luck', value: 0.10 }, requires: 'perm_luck_1' },
            { id: 'perm_luck_3', name: 'Lucky Charm III', desc: '+20% Permanent Luck', cost: 50, bonus: { type: 'luck', value: 0.20 }, requires: 'perm_luck_2' },
            { id: 'auto_spin_boost', name: 'Speed Boost', desc: '2x Auto-Spin Speed', cost: 30, bonus: { type: 'autoSpinSpeed', value: 2 } },
            { id: 'pity_reduction', name: 'Pity Helper', desc: 'Pity at 80 instead of 100', cost: 40, bonus: { type: 'pityReduction', value: 20 } },
            { id: 'starting_money', name: 'Rich Start', desc: 'Start with $50k on Rebirth', cost: 20, bonus: { type: 'startMoney', value: 50000 } },
            { id: 'xp_boost', name: 'XP Boost', desc: '+50% Battle Pass XP', cost: 35, bonus: { type: 'xpBoost', value: 0.5 } },
            { id: 'pet_slot_1', name: 'Pet Slot', desc: 'Unlock pet system', cost: 15, bonus: { type: 'petSlot', value: 1 } }
        ];
        
        function updateAchievementShopDisplay() {
            const container = document.getElementById('achievementShopContainer');
            if (!container) return;
            
            container.innerHTML = '';
            
            achievementShopItems.forEach(item => {
                const owned = gameState.achievementShopPurchases[item.id] || false;
                const canAfford = gameState.achievementPoints >= item.cost;
                const meetsRequirement = !item.requires || gameState.achievementShopPurchases[item.requires];
                const canBuy = !owned && canAfford && meetsRequirement;
                
                const card = document.createElement('div');
                card.className = 'recipe-card';
                card.style.border = owned ? '2px solid var(--success)' : '';
                card.innerHTML = `
                    <h3 style="color: ${owned ? 'var(--success)' : 'var(--accent-gold)'};">${item.name}</h3>
                    <p style="color: var(--text-secondary); margin: 10px 0;">${item.desc}</p>
                    ${item.requires && !owned ? `<p style="color: var(--warning); font-size: 0.85rem;">Requires: ${achievementShopItems.find(i => i.id === item.requires)?.name}</p>` : ''}
                    <div style="margin: 15px 0; font-size: 1.2rem; color: var(--accent-gold);">
                        ðŸ’° ${item.cost} Points
                    </div>
                    <button class="btn ${owned ? 'btn-decline' : canBuy ? 'btn-accept' : 'btn-decline'}" 
                            onclick="purchaseAchievementShopItem('${item.id}')" 
                            ${!canBuy ? 'disabled' : ''}
                            style="${!canBuy ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
                        ${owned ? 'âœ… Owned' : !meetsRequirement ? 'ðŸ”’ Locked' : !canAfford ? 'âŒ Too Expensive' : 'ðŸ’³ Purchase'}
                    </button>
                `;
                container.appendChild(card);
            });
        }
        
        function purchaseAchievementShopItem(itemId) {
            const item = achievementShopItems.find(i => i.id === itemId);
            if (!item) return;
            
            if (gameState.achievementShopPurchases[itemId]) {
                showNotification('Already owned!', 'var(--warning)');
                return;
            }
            
            if (item.requires && !gameState.achievementShopPurchases[item.requires]) {
                showNotification('Missing requirement!', 'var(--danger)');
                return;
            }
            
            if (gameState.achievementPoints < item.cost) {
                showNotification('Not enough points!', 'var(--danger)');
                return;
            }
            
            gameState.achievementPoints -= item.cost;
            gameState.achievementShopPurchases[itemId] = true;
            
            // Apply bonus
            applyAchievementShopBonus(item);
            
            showNotification(`âœ… Purchased ${item.name}!`, 'var(--success)');
            updateAchievementShopDisplay();
            updateAchievementPointsDisplay();
        }
        
        function applyAchievementShopBonus(item) {
            if (item.bonus.type === 'luck') {
                gameState.luckMultiplier += item.bonus.value;
            } else if (item.bonus.type === 'pityReduction') {
                gameState.pityThreshold = 80;
            }
            // Other bonuses applied when checked
            updateStats();
        }
        
        function updateAchievementPointsDisplay() {
            const displays = [
                document.getElementById('achievementPointsDisplay'),
                document.getElementById('achievementPointsShopDisplay')
            ];
            displays.forEach(display => {
                if (display) display.textContent = gameState.achievementPoints || 0;
            });
        }
        
        // Award achievement points when achievements are unlocked
        function awardAchievementPoints(achievementId) {
            // Award 2 points per achievement
            gameState.achievementPoints = (gameState.achievementPoints || 0) + 2;
            updateAchievementPointsDisplay();
        }
        
        // ===== PET SYSTEM =====
        
        const availablePets = [
            { id: 'lucky_dragon', name: 'ðŸ‰ Lucky Dragon', rarity: 'Legendary', bonus: { type: 'luck', value: 0.10 }, cost: 100000 },
            { id: 'trade_cat', name: 'ðŸ± Trade Cat', rarity: 'Rare', bonus: { type: 'tradeBonus', value: 0.15 }, cost: 50000 },
            { id: 'wise_owl', name: 'ðŸ¦‰ Wise Owl', rarity: 'Epic', bonus: { type: 'craftDiscount', value: 0.05 }, cost: 75000 },
            { id: 'loyal_dog', name: 'ðŸ• Loyal Dog', rarity: 'Common', bonus: { type: 'allStats', value: 0.05 }, cost: 25000 },
            { id: 'rainbow_unicorn', name: 'ðŸ¦„ Rainbow Unicorn', rarity: 'Mythic', bonus: { type: 'rareChance', value: 2 }, cost: 150000 },
            { id: 'ancient_turtle', name: 'ðŸ¢ Ancient Turtle', rarity: 'Epic', bonus: { type: 'pityBoost', value: 0.20 }, cost: 80000 },
            { id: 'mystic_fox', name: 'ðŸ¦Š Mystic Fox', rarity: 'Legendary', bonus: { type: 'fusionLuck', value: 2 }, cost: 120000 },
            { id: 'golden_phoenix', name: 'ðŸ¦… Golden Phoenix', rarity: 'Exotic', bonus: { type: 'luck', value: 0.15 }, cost: 200000 },
            { id: 'space_monkey', name: 'ðŸ’ Space Monkey', rarity: 'Rare', bonus: { type: 'xpBoost', value: 0.25 }, cost: 60000 },
            { id: 'crystal_butterfly', name: 'ðŸ¦‹ Crystal Butterfly', rarity: 'Epic', bonus: { type: 'valueBoost', value: 0.10 }, cost: 90000 },
            { id: 'shadow_wolf', name: 'ðŸº Shadow Wolf', rarity: 'Mythic', bonus: { type: 'enchantPower', value: 0.20 }, cost: 175000 },
            { id: 'cosmic_squid', name: 'ðŸ¦‘ Cosmic Squid', rarity: 'Celestial', bonus: { type: 'multiSpin', value: 0.10 }, cost: 250000 },
            { id: 'thunder_lion', name: 'ðŸ¦ Thunder Lion', rarity: 'Divine', bonus: { type: 'allStats', value: 0.10 }, cost: 300000 },
            { id: 'void_raven', name: 'ðŸ¦… Void Raven', rarity: 'Cosmic', bonus: { type: 'luck', value: 0.25 }, cost: 500000 },
            { id: 'eternal_serpent', name: 'ðŸ Eternal Serpent', rarity: 'Infinite', bonus: { type: 'allStats', value: 0.15 }, cost: 750000 }
        ];
        
        function updatePetsDisplay() {
            const container = document.getElementById('petsContainer');
            if (!container) return;
            
            container.innerHTML = '';
            
            availablePets.forEach(pet => {
                const owned = gameState.pets.includes(pet.id);
                const isActive = gameState.activePet === pet.id;
                const level = gameState.petLevels[pet.id] || 1;
                const canBuy = !owned && gameState.money >= pet.cost;
                
                const card = document.createElement('div');
                card.className = 'recipe-card';
                card.style.border = isActive ? '3px solid var(--accent-gold)' : owned ? '2px solid var(--success)' : '';
                card.innerHTML = `
                    <div style="font-size: 3rem; margin: 10px 0;">${pet.name.split(' ')[0]}</div>
                    <h3 style="color: ${isActive ? 'var(--accent-gold)' : 'var(--accent-primary)'};">${pet.name.split(' ').slice(1).join(' ')}</h3>
                    <p style="color: var(--text-secondary); font-size: 0.9rem;">${pet.rarity}</p>
                    <div style="margin: 10px 0; color: var(--success);">
                        ${getBonusDescription(pet.bonus)}
                    </div>
                    ${owned ? `<p style="color: var(--accent-gold);">Level ${level}</p>` : ''}
                    <div style="margin: 10px 0;">
                        ${owned ? 
                            `<button class="btn ${isActive ? 'btn-decline' : 'btn-accept'}" onclick="equipPet('${pet.id}')" style="width: 100%; margin-bottom: 5px;">
                                ${isActive ? 'âœ… Equipped' : 'ðŸ”„ Equip'}
                            </button>` :
                            `<button class="btn btn-accept" onclick="buyPet('${pet.id}')" ${!canBuy ? 'disabled' : ''} style="width: 100%; ${!canBuy ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
                                ðŸ’° Buy ($${formatNumber(pet.cost)})
                            </button>`
                        }
                    </div>
                `;
                container.appendChild(card);
            });
            
            updateActivePetDisplay();
        }
        
        function getBonusDescription(bonus) {
            switch (bonus.type) {
                case 'luck': return `+${(bonus.value * 100).toFixed(0)}% Luck`;
                case 'tradeBonus': return `+${(bonus.value * 100).toFixed(0)}% Trade Win Chance`;
                case 'craftDiscount': return `-${(bonus.value * 100).toFixed(0)}% Craft Cost`;
                case 'allStats': return `+${(bonus.value * 100).toFixed(0)}% All Stats`;
                case 'rareChance': return `${bonus.value}x Rare Item Chance`;
                case 'pityBoost': return `+${(bonus.value * 100).toFixed(0)}% Pity Progress`;
                case 'fusionLuck': return `${bonus.value}x Fusion Luck`;
                default: return 'Special Bonus';
            }
        }
        
        function buyPet(petId) {
            const pet = availablePets.find(p => p.id === petId);
            if (!pet) return;
            
            if (gameState.pets.includes(petId)) {
                showNotification('Already owned!', 'var(--warning)');
                return;
            }
            
            if (gameState.money < pet.cost) {
                showNotification('Not enough money!', 'var(--danger)');
                return;
            }
            
            gameState.money -= pet.cost;
            gameState.pets.push(petId);
            gameState.petLevels[petId] = 1;
            gameState.petXP[petId] = 0;
            
            // Auto-equip if first pet
            if (!gameState.activePet) {
                gameState.activePet = petId;
                applyPetBonus(pet);
            }
            
            showNotification(`ðŸŽ‰ Pet acquired: ${pet.name}!`, 'var(--success)');
            updatePetsDisplay();
            updateStats();
        }
        
        function equipPet(petId) {
            const pet = availablePets.find(p => p.id === petId);
            if (!pet || !gameState.pets.includes(petId)) return;
            
            // Remove old pet bonus
            if (gameState.activePet) {
                const oldPet = availablePets.find(p => p.id === gameState.activePet);
                if (oldPet) removePetBonus(oldPet);
            }
            
            // Equip new pet
            gameState.activePet = petId;
            applyPetBonus(pet);
            
            showNotification(`${pet.name} equipped!`, 'var(--success)');
            updatePetsDisplay();
            updateStats();
        }
        
        function applyPetBonus(pet) {
            if (pet.bonus.type === 'luck') {
                gameState.luckMultiplier += pet.bonus.value;
            }
            // Other bonuses checked when needed
        }
        
        function removePetBonus(pet) {
            if (pet.bonus.type === 'luck') {
                gameState.luckMultiplier -= pet.bonus.value;
            }
        }
        
        function updateActivePetDisplay() {
            const activePet = gameState.activePet ? availablePets.find(p => p.id === gameState.activePet) : null;
            
            const displays = {
                icon: document.getElementById('activePetDisplay'),
                name: document.getElementById('activePetName'),
                bonus: document.getElementById('activePetBonus'),
                level: document.getElementById('activePetLevel')
            };
            
            if (activePet) {
                if (displays.icon) displays.icon.textContent = activePet.name.split(' ')[0];
                if (displays.name) displays.name.textContent = activePet.name.split(' ').slice(1).join(' ');
                if (displays.bonus) displays.bonus.textContent = getBonusDescription(activePet.bonus);
                if (displays.level) displays.level.textContent = `Level ${gameState.petLevels[activePet.id] || 1}`;
            } else {
                if (displays.icon) displays.icon.textContent = 'â“';
                if (displays.name) displays.name.textContent = 'No pet equipped';
                if (displays.bonus) displays.bonus.textContent = 'Buy a pet to get bonuses!';
                if (displays.level) displays.level.textContent = 'Level: 0';
            }
        }
        
        // ===== PRESTIGE SYSTEM =====
        
        const prestigeShopItems = [
            { id: 'start_2x_luck', name: 'Lucky Start', desc: 'Start with 2x Luck', cost: 5 },
            { id: 'start_autospin', name: 'Auto Start', desc: 'Start with Auto-Spin', cost: 10 },
            { id: 'start_100k', name: 'Rich Start', desc: 'Start with $100,000', cost: 8 },
            { id: 'keep_pets', name: 'Pet Keeper', desc: 'Keep all pets on Prestige', cost: 15 },
            { id: 'double_points', name: 'Point Doubler', desc: '2x Achievement Points', cost: 20 }
        ];
        
        function updatePrestigeDisplay() {
            if (!document.getElementById('prestigeLevelDisplay')) return;
            
            document.getElementById('prestigeLevelDisplay').textContent = gameState.prestigeLevel || 0;
            document.getElementById('prestigePointsDisplay').textContent = gameState.prestigePoints || 0;
            
            // Check requirements
            const hasRebirths = (gameState.rebirths || 0) >= 10;
            const hasMoney = gameState.money >= 1000000000; // 1 billion
            const hasPrimordial = Object.values(gameState.inventory).some(item => {
                const rarityIndex = rarities.findIndex(r => r.name === item.rarity);
                return rarityIndex >= 13 && item.count > 0; // Primordial is index 13
            });
            
            document.getElementById('prestigeRebirthReq').textContent = hasRebirths ? 'âœ… Met' : 'âŒ Not met';
            document.getElementById('prestigeRebirthReq').style.color = hasRebirths ? 'var(--success)' : 'var(--danger)';
            
            document.getElementById('prestigeMoneyReq').textContent = hasMoney ? 'âœ… Met' : 'âŒ Not met';
            document.getElementById('prestigeMoneyReq').style.color = hasMoney ? 'var(--success)' : 'var(--danger)';
            
            document.getElementById('prestigeItemReq').textContent = hasPrimordial ? 'âœ… Met' : 'âŒ Not met';
            document.getElementById('prestigeItemReq').style.color = hasPrimordial ? 'var(--success)' : 'var(--danger)';
            
            const canPrestige = hasRebirths && hasMoney && hasPrimordial;
            const button = document.getElementById('prestigeButton');
            button.disabled = !canPrestige;
            button.style.opacity = canPrestige ? '1' : '0.5';
            button.style.cursor = canPrestige ? 'pointer' : 'not-allowed';
            
            updatePrestigeShopDisplay();
        }
        
        function updatePrestigeShopDisplay() {
            const container = document.getElementById('prestigeShopContainer');
            if (!container) return;
            
            container.innerHTML = '';
            
            prestigeShopItems.forEach(item => {
                const owned = gameState.prestigeShopPurchases[item.id] || false;
                const canBuy = !owned && (gameState.prestigePoints >= item.cost);
                
                const card = document.createElement('div');
                card.className = 'recipe-card';
                card.style.border = owned ? '2px solid var(--accent-gold)' : '';
                card.innerHTML = `
                    <h3 style="color: var(--accent-gold);">${item.name}</h3>
                    <p style="color: var(--text-secondary); margin: 10px 0;">${item.desc}</p>
                    <div style="margin: 15px 0; font-size: 1.2rem; color: var(--accent-primary);">
                        â­ ${item.cost} Points
                    </div>
                    <button class="btn ${owned ? 'btn-decline' : canBuy ? 'btn-accept' : 'btn-decline'}" 
                            onclick="buyPrestigeItem('${item.id}')" 
                            ${!canBuy ? 'disabled' : ''}
                            style="${!canBuy ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
                        ${owned ? 'âœ… Owned' : canBuy ? 'ðŸ’³ Purchase' : 'ðŸ”’ Locked'}
                    </button>
                `;
                container.appendChild(card);
            });
        }
        
        function buyPrestigeItem(itemId) {
            const item = prestigeShopItems.find(i => i.id === itemId);
            if (!item) return;
            
            if (gameState.prestigeShopPurchases[itemId]) {
                showNotification('Already owned!', 'var(--warning)');
                return;
            }
            
            if (gameState.prestigePoints < item.cost) {
                showNotification('Not enough prestige points!', 'var(--danger)');
                return;
            }
            
            gameState.prestigePoints -= item.cost;
            gameState.prestigeShopPurchases[itemId] = true;
            
            showNotification(`â­ Purchased: ${item.name}!`, 'var(--success)');
            updatePrestigeDisplay();
        }
        
        function performPrestige() {
            const hasRebirths = (gameState.rebirths || 0) >= 10;
            const hasMoney = gameState.money >= 1000000000;
            const hasPrimordial = Object.values(gameState.inventory).some(item => {
                const rarityIndex = rarities.findIndex(r => r.name === item.rarity);
                return rarityIndex >= 13 && item.count > 0; // Primordial is index 13
            });
            
            if (!hasRebirths || !hasMoney || !hasPrimordial) {
                showNotification('âŒ Requirements not met!', 'var(--danger)');
                return;
            }
            
            if (!confirm(`â­ PRESTIGE â­\n\nThis will reset EVERYTHING except:\n- Prestige Points\n- Prestige Shop\n- Pets (if you bought Pet Keeper)\n\nYou will gain ${5 + (gameState.prestigeLevel || 0)} Prestige Points.\n\nContinue?`)) {
                return;
            }
            
            // Calculate prestige points
            const pointsGained = 5 + (gameState.prestigeLevel || 0);
            
            // Save what we keep
            const keepPets = gameState.prestigeShopPurchases.keep_pets;
            const savedPets = keepPets ? [...gameState.pets] : [];
            const savedActivePet = keepPets ? gameState.activePet : null;
            const savedPetLevels = keepPets ? {...gameState.petLevels} : {};
            const savedPrestigePoints = (gameState.prestigePoints || 0) + pointsGained;
            const savedPrestigeLevel = (gameState.prestigeLevel || 0) + 1;
            const savedPrestigeShop = {...gameState.prestigeShopPurchases};
            
            // Reset most of game state
            Object.assign(gameState, {
                inventory: {},
                totalValue: 0,
                money: gameState.prestigeShopPurchases.start_100k ? 100000 : 0,
                totalSpins: 0,
                luckMultiplier: gameState.prestigeShopPurchases.start_2x_luck ? 2.0 : 1.0,
                tradeWins: 0,
                tradeLosses: 0,
                battlePassXP: 0,
                battlePassTier: 0,
                achievements: {},
                upgrades: {
                    spinSpeed: 0,
                    popularity: 0,
                    luckBoost: 0,
                    autoSpin: gameState.prestigeShopPurchases.start_autospin ? 1 : 0,
                    tradeInsight: 0,
                    valueBoost: 0,
                    craftingMastery: 0,
                    enchantPower: 0,
                    multiSpin: 0,
                    shopDiscount: 0,
                    rarityBoost: 0,
                    eventLuck: 0,
                    xpBoost: 0,
                    sellPrice: 0,
                    questSpeed: 0,
                    mysteryBox: 0,
                    autoFusion: 0
                },
                rebirths: 0,
                permanentLuckBoost: 1.0,
                craftCount: 0,
                enchantSuccess: 0,
                enchantFails: 0,
                fusionCount: 0,
                itemsFromEvents: 0,
                lifetimeMoneyEarned: 0,
                lifetimeMoneySpent: 0,
                biggestTradeWin: 0,
                biggestTradeLoss: 0,
                rarityCounts: {},
                pityCounter: 0,
                collectionBonuses: {
                    discoComplete: false,
                    galacticComplete: false,
                    glitchComplete: false,
                    fullmoonComplete: false,
                    bloodmoonComplete: false,
                    weatherComplete: false,
                    christmasComplete: false
                },
                rarityMilestones: {},
                achievementPoints: 0,
                achievementShopPurchases: {},
                dailyChallenges: [],
                dailyChallengesCompleted: [],
                favoriteItems: [],
                pets: savedPets,
                activePet: savedActivePet,
                petLevels: savedPetLevels,
                prestigeLevel: savedPrestigeLevel,
                prestigePoints: savedPrestigePoints,
                prestigeShopPurchases: savedPrestigeShop
            });
            
            showNotification(`â­ PRESTIGE COMPLETE! Level ${savedPrestigeLevel}! +${pointsGained} Points!`, 'var(--success)');
            
            // Refresh everything
            updateStats();
            updateInventory();
            initAchievements();
            updatePrestigeDisplay();
            updatePetsDisplay();
            switchTab('prestige');
            saveGame();
        }
        
        // ===== FEATURE 1: EXPORT/IMPORT SAVES =====
        
        function exportSaveData() {
            try {
                const saveData = JSON.stringify(gameState);
                const encoded = btoa(saveData);
                
                // Create a modal to show the code
                const modal = document.createElement('div');
                modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';
                modal.innerHTML = `
                    <div style="background: var(--bg-medium); padding: 30px; border-radius: 15px; max-width: 600px; width: 100%; border: 2px solid var(--accent-primary);">
                        <h2 style="color: var(--accent-primary); margin-bottom: 20px;">ðŸ“¤ Export Save Code</h2>
                        <p style="color: var(--text-secondary); margin-bottom: 15px;">Copy this code to backup your progress:</p>
                        <textarea id="saveCodeExport" readonly style="width: 100%; height: 150px; padding: 15px; background: var(--bg-dark); color: var(--text-primary); border: 2px solid var(--accent-primary); border-radius: 8px; font-family: monospace; font-size: 0.85rem; resize: none;">${encoded}</textarea>
                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button onclick="copyExportCode()" class="btn btn-accept" style="flex: 1;">ðŸ“‹ Copy to Clipboard</button>
                            <button onclick="closeModal()" class="btn btn-decline" style="flex: 1;">Close</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                modal.onclick = (e) => { if (e.target === modal) closeModal(); };
                window.currentModal = modal;
                
                // Auto-select text
                setTimeout(() => {
                    document.getElementById('saveCodeExport').select();
                }, 100);
            } catch (error) {
                showNotification('âŒ Error exporting save!', 'var(--danger)');
                console.error('Export error:', error);
            }
        }
        
        function showImportDialog() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';
            modal.innerHTML = `
                <div style="background: var(--bg-medium); padding: 30px; border-radius: 15px; max-width: 600px; width: 100%; border: 2px solid var(--accent-primary);">
                    <h2 style="color: var(--accent-primary); margin-bottom: 20px;">ðŸ“¥ Import Save Code</h2>
                    <p style="color: var(--warning); margin-bottom: 15px;">âš ï¸ This will OVERWRITE your current progress!</p>
                    <textarea id="saveCodeImport" placeholder="Paste your save code here..." style="width: 100%; height: 150px; padding: 15px; background: var(--bg-dark); color: var(--text-primary); border: 2px solid var(--accent-primary); border-radius: 8px; font-family: monospace; font-size: 0.85rem; resize: none;"></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button onclick="importSaveData()" class="btn btn-accept" style="flex: 1;">âœ… Import</button>
                        <button onclick="closeModal()" class="btn btn-decline" style="flex: 1;">Cancel</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            modal.onclick = (e) => { if (e.target === modal) closeModal(); };
            window.currentModal = modal;
        }
        
        function importSaveData() {
            const code = document.getElementById('saveCodeImport').value.trim();
            if (!code) {
                showNotification('âŒ Please paste a save code!', 'var(--danger)');
                return;
            }
            
            try {
                const decoded = atob(code);
                const loadedState = JSON.parse(decoded);
                
                // Validate it's actually a save file
                if (!loadedState.inventory || !loadedState.money === undefined) {
                    showNotification('âŒ Invalid save code!', 'var(--danger)');
                    return;
                }
                
                // Load the save
                Object.assign(gameState, loadedState);
                
                // Ensure backward compatibility
                if (gameState.favoriteItems === undefined) gameState.favoriteItems = [];
                
                closeModal();
                showNotification('âœ… Save imported successfully!', 'var(--success)');
                
                // Refresh display
                updateStats();
                updateInventory();
                initAchievements();
                updateRebirthDisplay();
                
                // Auto-save the imported state
                saveGame();
            } catch (error) {
                showNotification('âŒ Error importing save!', 'var(--danger)');
                console.error('Import error:', error);
            }
        }
        
        function copyExportCode() {
            const textarea = document.getElementById('saveCodeExport');
            textarea.select();
            document.execCommand('copy');
            showNotification('ðŸ“‹ Copied to clipboard!', 'var(--success)');
        }
        
        function closeModal() {
            if (window.currentModal) {
                window.currentModal.remove();
                window.currentModal = null;
            }
        }
        
        // ===== FEATURE 2: BULK SELL BY RARITY =====
        
        function bulkSellByRarity() {
            const raritySelect = document.getElementById('bulkSellRarity');
            const selectedRarity = raritySelect.value;
            
            if (!selectedRarity) {
                showNotification('âŒ Please select a rarity!', 'var(--danger)');
                return;
            }
            
            // Get confirmation
            if (!gameState.settings || gameState.settings.confirmSell !== false) {
                if (!confirm(`Sell ALL ${selectedRarity} items for 70% value?`)) {
                    return;
                }
            }
            
            let soldCount = 0;
            let totalMoney = 0;
            
            // Sell all items of this rarity (except favorited)
            for (const [key, item] of Object.entries(gameState.inventory)) {
                if (item.rarity === selectedRarity && item.count > 0) {
                    // Skip if favorited
                    if (gameState.favoriteItems && gameState.favoriteItems.includes(key)) {
                        continue;
                    }
                    
                    let sellMultiplier = 0.7;
                    
                    // Check for Money Multi enchantment
                    if (item.enchantments && item.enchantments.includes('Money Multi')) {
                        sellMultiplier += 0.2;
                    }
                    
                    const sellPrice = Math.floor(item.value * sellMultiplier * item.count);
                    gameState.money += sellPrice;
                    gameState.lifetimeMoneyEarned += sellPrice;
                    gameState.totalValue -= item.value * item.count;
                    totalMoney += sellPrice;
                    soldCount += item.count;
                    item.count = 0;
                }
            }
            
            if (soldCount > 0) {
                showNotification(`ðŸ’° Sold ${soldCount} ${selectedRarity} items for $${formatNumber(totalMoney)}!`, 'var(--success)');
                playSound('coin');
                updateStats();
                updateInventory();
            } else {
                showNotification(`No ${selectedRarity} items to sell!`, 'var(--text-secondary)');
            }
        }
        
        function sellAllNonFavorited() {
            // Get confirmation
            if (!gameState.settings || gameState.settings.confirmSell !== false) {
                if (!confirm('Sell ALL non-favorited items for 70% value?')) {
                    return;
                }
            }
            
            let soldCount = 0;
            let totalMoney = 0;
            
            // Sell all items that are NOT favorited
            for (const [key, item] of Object.entries(gameState.inventory)) {
                if (item.count > 0) {
                    // Skip if favorited
                    if (gameState.favoriteItems && gameState.favoriteItems.includes(key)) {
                        continue;
                    }
                    
                    let sellMultiplier = 0.7;
                    
                    // Check for Money Multi enchantment
                    if (item.enchantments && item.enchantments.includes('Money Multi')) {
                        sellMultiplier += 0.2;
                    }
                    
                    const sellPrice = Math.floor(item.value * sellMultiplier * item.count);
                    gameState.money += sellPrice;
                    gameState.lifetimeMoneyEarned += sellPrice;
                    gameState.totalValue -= item.value * item.count;
                    totalMoney += sellPrice;
                    soldCount += item.count;
                    item.count = 0;
                }
            }
            
            if (soldCount > 0) {
                showNotification(`ðŸ’° Sold ${soldCount} non-favorited items for $${formatNumber(totalMoney)}!`, 'var(--success)');
                playSound('coin');
                updateStats();
                updateInventory();
            } else {
                showNotification('No non-favorited items to sell!', 'var(--text-secondary)');
            }
        }
        
        function favoriteAllByRarity() {
            const minRarity = prompt('Favorite all items of which rarity and above?\n\nOptions:\n0 = Common\n1 = Uncommon\n2 = Rare\n3 = Epic\n4 = Legendary\n5 = Mythic\n6 = Exotic\n7 = Celestial\n8 = Divine\n9 = Cosmic\n10 = Infinite\n11 = Transcendent\n12 = Ethereal\n13 = Primordial+', '4');
            
            if (minRarity === null) return;
            
            const minIndex = parseInt(minRarity);
            if (isNaN(minIndex) || minIndex < 0 || minIndex >= rarities.length) {
                showNotification('âŒ Invalid rarity index!', 'var(--danger)');
                return;
            }
            
            if (!gameState.favoriteItems) gameState.favoriteItems = [];
            
            let favoritedCount = 0;
            
            for (const [key, item] of Object.entries(gameState.inventory)) {
                if (item.count > 0) {
                    const itemRarityIndex = rarities.findIndex(r => r.name === item.rarity);
                    if (itemRarityIndex >= minIndex && !gameState.favoriteItems.includes(key)) {
                        gameState.favoriteItems.push(key);
                        favoritedCount++;
                    }
                }
            }
            
            if (favoritedCount > 0) {
                showNotification(`â­ Favorited ${favoritedCount} items (${rarities[minIndex].name}+)!`, 'var(--accent-gold)');
                playSound('success');
                updateInventory();
            } else {
                showNotification('No new items to favorite!', 'var(--text-secondary)');
            }
        }
        
        function unfavoriteAll() {
            if (!gameState.favoriteItems || gameState.favoriteItems.length === 0) {
                showNotification('No favorited items!', 'var(--text-secondary)');
                return;
            }
            
            if (!confirm('Remove all favorites?')) {
                return;
            }
            
            const count = gameState.favoriteItems.length;
            gameState.favoriteItems = [];
            
            showNotification(`âœ–ï¸ Removed ${count} favorites!`, 'var(--warning)');
            playSound('button');
            updateInventory();
        }
        
        // ===== FEATURE 3: CRAFT MAX =====
        
        function craftMax(recipeName) {
            const recipe = recipes.find(r => r.name === recipeName);
            if (!recipe) return;
            
            // Calculate max possible crafts
            let maxCrafts = Infinity;
            
            for (const [rarity, requiredCount] of Object.entries(recipe.requires)) {
                const availableItems = Object.values(gameState.inventory).filter(item => 
                    item.rarity === rarity && item.count > 0
                );
                const availableCount = availableItems.reduce((sum, item) => sum + item.count, 0);
                const possibleCrafts = Math.floor(availableCount / requiredCount);
                maxCrafts = Math.min(maxCrafts, possibleCrafts);
            }
            
            if (maxCrafts === 0 || maxCrafts === Infinity) {
                showNotification('âŒ Not enough materials!', 'var(--danger)');
                return;
            }
            
            // Confirm if crafting more than 10
            if (maxCrafts > 10) {
                if (!confirm(`Craft ${maxCrafts}x ${recipeName}?`)) {
                    return;
                }
            }
            
            // Perform crafts
            for (let i = 0; i < maxCrafts; i++) {
                craftItem(recipeName, true); // Pass true to skip notifications
            }
            
            showNotification(`ðŸ”¨ Crafted ${maxCrafts}x ${recipeName}!`, 'var(--success)');
            updateStats();
            updateInventory();
            
            // Refresh crafting grid
            document.getElementById('craftingGrid').innerHTML = '';
            initCrafting();
        }
        
        // ===== FEATURE 4: FAVORITE ITEMS =====
        
        function toggleFavorite(itemKey) {
            if (!gameState.favoriteItems) gameState.favoriteItems = [];
            
            const index = gameState.favoriteItems.indexOf(itemKey);
            if (index === -1) {
                gameState.favoriteItems.push(itemKey);
                showNotification(`â­ ${itemKey} favorited (protected from selling)`, 'var(--accent-gold)');
            } else {
                gameState.favoriteItems.splice(index, 1);
                showNotification(`Unfavorited ${itemKey}`, 'var(--text-secondary)');
            }
            
            updateInventory();
        }
        
        // ===== FEATURE 5: CONFIRMATION DIALOGS =====
        // This is integrated into existing functions via checks
        
        // Initialize game
        // Try to auto-load save file on startup
        const hasSaveFile = localStorage.getItem('rngTraderSave');
        if (hasSaveFile) {
            try {
                const data = JSON.parse(hasSaveFile);
                gameState.inventory = data.inventory || {};
                gameState.totalValue = data.totalValue || 0;
                gameState.money = data.money || 0;
                gameState.totalSpins = data.totalSpins || 0;
                gameState.luckMultiplier = data.luckMultiplier || 1.0;
                gameState.tradeWins = data.tradeWins || 0;
                gameState.tradeLosses = data.tradeLosses || 0;
                gameState.battlePassXP = data.battlePassXP || 0;
                gameState.achievements = data.achievements || {};
                gameState.upgrades = data.upgrades || {
                    spinSpeed: 0,
                    popularity: 0,
                    luckBoost: 0,
                    autoSpin: 0,
                    tradeInsight: 0,
                    valueBoost: 0,
                    craftingMastery: 0,
                    enchantPower: 0,
                    multiSpin: 0,
                    shopDiscount: 0,
                    rarityBoost: 0
                };
                // Ensure new upgrades exist in old saves
                if (gameState.upgrades.valueBoost === undefined) gameState.upgrades.valueBoost = 0;
                if (gameState.upgrades.craftingMastery === undefined) gameState.upgrades.craftingMastery = 0;
                if (gameState.upgrades.enchantPower === undefined) gameState.upgrades.enchantPower = 0;
                if (gameState.upgrades.multiSpin === undefined) gameState.upgrades.multiSpin = 0;
                if (gameState.upgrades.shopDiscount === undefined) gameState.upgrades.shopDiscount = 0;
                if (gameState.upgrades.rarityBoost === undefined) gameState.upgrades.rarityBoost = 0;
                if (gameState.upgrades.eventLuck === undefined) gameState.upgrades.eventLuck = 0;
                if (gameState.upgrades.xpBoost === undefined) gameState.upgrades.xpBoost = 0;
                if (gameState.upgrades.sellPrice === undefined) gameState.upgrades.sellPrice = 0;
                if (gameState.upgrades.questSpeed === undefined) gameState.upgrades.questSpeed = 0;
                if (gameState.upgrades.mysteryBox === undefined) gameState.upgrades.mysteryBox = 0;
                if (gameState.specialEventIsAdmin === undefined) gameState.specialEventIsAdmin = false;
                
                // Backwards compatibility for new features
                if (gameState.pityCounter === undefined) gameState.pityCounter = 0;
                if (gameState.pityThreshold === undefined) gameState.pityThreshold = 100;
                if (gameState.pityTriggered === undefined) gameState.pityTriggered = 0;
                if (gameState.lastLoginDate === undefined) gameState.lastLoginDate = null;
                if (gameState.loginStreak === undefined) gameState.loginStreak = 0;
                if (gameState.totalLogins === undefined) gameState.totalLogins = 0;
                if (gameState.loginRewardsClaimed === undefined) gameState.loginRewardsClaimed = [];
                if (gameState.lifetimeMoneyEarned === undefined) gameState.lifetimeMoneyEarned = 0;
                if (gameState.lifetimeMoneySpent === undefined) gameState.lifetimeMoneySpent = 0;
                if (gameState.biggestTradeWin === undefined) gameState.biggestTradeWin = 0;
                if (gameState.biggestTradeLoss === undefined) gameState.biggestTradeLoss = 0;
                if (gameState.rarityCounts === undefined) gameState.rarityCounts = {};
                if (gameState.itemsFromEvents === undefined) gameState.itemsFromEvents = 0;
                if (gameState.craftCount === undefined) gameState.craftCount = 0;
                if (gameState.enchantSuccess === undefined) gameState.enchantSuccess = 0;
                if (gameState.enchantFails === undefined) gameState.enchantFails = 0;
                if (gameState.fusionCount === undefined) gameState.fusionCount = 0;
                if (gameState.statisticsViewed === undefined) gameState.statisticsViewed = false;
                if (gameState.collectionBonuses === undefined) gameState.collectionBonuses = {discoComplete:false,galacticComplete:false,glitchComplete:false,fullmoonComplete:false,bloodmoonComplete:false,weatherComplete:false,christmasComplete:false};
                if (gameState.rarityMilestones === undefined) gameState.rarityMilestones = {};
                if (gameState.upgrades.autoFusion === undefined) gameState.upgrades.autoFusion = 0;
                if (gameState.notificationQueue === undefined) gameState.notificationQueue = [];
                if (gameState.isShowingNotification === undefined) gameState.isShowingNotification = false;
                
                gameState.rebirths = data.rebirths || 0;
                gameState.permanentLuckBoost = data.permanentLuckBoost || 1.0;
                gameState.settings = data.settings || {
                    soundEffects: true,
                    showTradeNotifications: true,
                    showExpiredNotifications: true,
                    showSpinResults: true,
                    showAchievementNotifications: true,
                    showRandomEvents: true,
                    showAutoSaveNotifications: false
                };
                // Ensure new setting exists in old saves
                if (gameState.settings.soundEffects === undefined) {
                    gameState.settings.soundEffects = true;
                }
                if (gameState.settings.showAutoSaveNotifications === undefined) {
                    gameState.settings.showAutoSaveNotifications = false;
                }
                gameState.craftCount = data.craftCount || 0;
                gameState.enchantSuccess = data.enchantSuccess || 0;
                gameState.enchantFails = data.enchantFails || 0;
                gameState.adminUnlocked = data.adminUnlocked || false;
                gameState.questsCompleted = data.questsCompleted || 0;
                gameState.dailyStreak = data.dailyStreak || 0;
                gameState.weeklyQuestsCompleted = data.weeklyQuestsCompleted || 0;
                gameState.shopPurchases = data.shopPurchases || 0;
                gameState.activeQuests = data.activeQuests || [];
                gameState.completedQuests = data.completedQuests || [];
                gameState.lastQuestRefresh = data.lastQuestRefresh || 0;
                gameState.claimedBPTiers = data.claimedBPTiers || [];
            } catch (error) {
                console.error('Auto-load failed:', error);
            }
        }
        
        // Ensure new features exist (backward compatibility)
        if (gameState.favoriteItems === undefined) gameState.favoriteItems = [];
        if (gameState.inventorySort === undefined) gameState.inventorySort = 'rarity';
        if (gameState.inventoryFilter === undefined) gameState.inventoryFilter = 'all';
        if (gameState.tutorialStep === undefined) gameState.tutorialStep = 0;
        if (gameState.tutorialComplete === undefined) gameState.tutorialComplete = false;
        if (gameState.tutorialSkipped === undefined) gameState.tutorialSkipped = false;
        if (gameState.dailyChallenges === undefined) gameState.dailyChallenges = [];
        if (gameState.dailyChallengesCompleted === undefined) gameState.dailyChallengesCompleted = [];
        if (gameState.lastDailyChallengeReset === undefined) gameState.lastDailyChallengeReset = 0;
        if (gameState.achievementPoints === undefined) gameState.achievementPoints = 0;
        if (gameState.achievementShopPurchases === undefined) gameState.achievementShopPurchases = {};
        if (gameState.pets === undefined) gameState.pets = [];
        if (gameState.activePet === undefined) gameState.activePet = null;
        if (gameState.petLevels === undefined) gameState.petLevels = {};
        if (gameState.petXP === undefined) gameState.petXP = {};
        if (gameState.prestigeLevel === undefined) gameState.prestigeLevel = 0;
        if (gameState.prestigePoints === undefined) gameState.prestigePoints = 0;
        if (gameState.prestigeShopPurchases === undefined) gameState.prestigeShopPurchases = {};
        
        updateStats();
        initAchievements();
        initBattlePass();
        updateEventBonuses();
        startAutoTrading();
        updateRebirthDisplay();
        refreshQuests();
        updateQuestDisplay();
        checkDailyLogin();
        updateStatistics();
        
        // Initialize new systems
        generateDailyChallenges();
        updateAchievementPointsDisplay();
        
        // Start tutorial for new players
        if (!gameState.tutorialComplete && !gameState.tutorialSkipped && gameState.totalSpins === 0) {
            setTimeout(() => startTutorial(), 1000);
        }
        
        // Mobile welcome message
        if (isMobileDevice() && !localStorage.getItem('mobileWelcomeShown')) {
            setTimeout(() => {
                showNotification('ðŸ“± Mobile Controls: Tap to flex, Long-press to sell! Swipe from left edge to open menu.', 'var(--accent-primary)');
                localStorage.setItem('mobileWelcomeShown', 'true');
            }, 2000);
        }
        
        // Start auto-spin if unlocked
        if (gameState.upgrades.autoSpin > 0) {
            startAutoSpin();
        }
        
        // Check for Christmas events every minute
        setInterval(checkChristmasEvent, 60000);
        checkChristmasEvent();
        
        // Check for Weather events every 30 seconds
        setInterval(checkWeatherEvents, 30000);
        checkWeatherEvents();
        
        // Check for Special events every 10 seconds
        setInterval(checkSpecialEvents, 10000);
        checkSpecialEvents();
        
        // Update event timers every second
        setInterval(() => {
            if (gameState.christmasEvent || gameState.weatherEvent || gameState.specialEvent) {
                updateEventBonuses();
            }
        }, 1000);
        
        // Check for quest refresh every minute
        setInterval(() => {
            refreshQuests();
        }, 60000);
        
        // ===== BOSS BATTLES SYSTEM =====
        
        const bossesData = [
            {
                id: 'money_goblin',
                name: 'ðŸ’° Money Goblin',
                emoji: 'ðŸ’°',
                description: 'A greedy goblin hoarding gold',
                difficulty: 'Beginner',
                cost: 100000,
                maxHP: 1000,
                rewards: {
                    moneyMin: 500000,
                    moneyMax: 1000000,
                    items: ['Rare', 'Epic']
                },
                color: '#ffd700'
            },
            {
                id: 'slot_demon',
                name: 'ðŸŽ° Slot Demon',
                emoji: 'ðŸŽ°',
                description: 'Corrupted luck incarnate',
                difficulty: 'Easy',
                cost: 500000,
                maxHP: 2500,
                rewards: {
                    moneyMin: 1000000,
                    moneyMax: 2500000,
                    items: ['Legendary'],
                    crates: 3
                },
                color: '#ff1493'
            },
            {
                id: 'rarity_dragon',
                name: 'ðŸ”® Rarity Dragon',
                emoji: 'ðŸ”®',
                description: 'Guardian of rare treasures',
                difficulty: 'Medium',
                cost: 1000000,
                maxHP: 5000,
                rewards: {
                    moneyMin: 3000000,
                    moneyMax: 7000000,
                    items: ['Divine'],
                    guaranteed: 'Divine'
                },
                color: '#ffd700'
            },
            {
                id: 'xp_phantom',
                name: 'ðŸ‘» XP Phantom',
                emoji: 'ðŸ‘»',
                description: 'Spirit of endless grinding',
                difficulty: 'Medium',
                cost: 2000000,
                maxHP: 7500,
                rewards: {
                    moneyMin: 5000000,
                    moneyMax: 10000000,
                    battlePassTiers: 10
                },
                color: '#9370db'
            },
            {
                id: 'pet_master',
                name: 'ðŸ‰ Pet Master',
                emoji: 'ðŸ‰',
                description: 'Tamer of legendary beasts',
                difficulty: 'Hard',
                cost: 5000000,
                maxHP: 10000,
                rewards: {
                    moneyMin: 10000000,
                    moneyMax: 20000000,
                    randomPet: true
                },
                color: '#ff4500'
            },
            {
                id: 'time_keeper',
                name: 'â° Time Keeper',
                emoji: 'â°',
                description: 'Master of temporal power',
                difficulty: 'Hard',
                cost: 10000000,
                maxHP: 15000,
                rewards: {
                    moneyMin: 20000000,
                    moneyMax: 40000000,
                    speedBoost: 3600
                },
                color: '#00ced1'
            },
            {
                id: 'artifact_guardian',
                name: 'ðŸ’Ž Artifact Guardian',
                emoji: 'ðŸ’Ž',
                description: 'Protector of ancient relics',
                difficulty: 'Very Hard',
                cost: 25000000,
                maxHP: 25000,
                rewards: {
                    moneyMin: 50000000,
                    moneyMax: 100000000,
                    randomArtifact: true
                },
                color: '#ff1493'
            },
            {
                id: 'cosmic_horror',
                name: 'ðŸŒŒ Cosmic Horror',
                emoji: 'ðŸŒŒ',
                description: 'Being from beyond reality',
                difficulty: 'Extreme',
                cost: 50000000,
                maxHP: 50000,
                rewards: {
                    moneyMin: 100000000,
                    moneyMax: 250000000,
                    items: ['Cosmic', 'Infinite'],
                    guaranteed: 'Cosmic'
                },
                color: '#4b0082'
            },
            {
                id: 'prestige_king',
                name: 'ðŸ‘‘ Prestige King',
                emoji: 'ðŸ‘‘',
                description: 'Ruler of the prestiged realm',
                difficulty: 'Extreme',
                cost: 100000000,
                maxHP: 100000,
                rewards: {
                    moneyMin: 250000000,
                    moneyMax: 500000000,
                    prestigePoints: 5
                },
                color: '#ffd700'
            },
            {
                id: 'primordial_titan',
                name: 'ðŸ”¥ Primordial Titan',
                emoji: 'ðŸ”¥',
                description: 'Ancient force of creation',
                difficulty: 'IMPOSSIBLE',
                cost: 500000000,
                maxHP: 500000,
                rewards: {
                    moneyMin: 1000000000,
                    moneyMax: 2000000000,
                    items: ['Primordial', 'Omega'],
                    guaranteed: 'Primordial',
                    randomArtifact: true
                },
                color: '#ff0000'
            }
        ];
        
        function initializeBossState() {
            if (!gameState.bosses) {
                gameState.bosses = {};
                bossesData.forEach(boss => {
                    gameState.bosses[boss.id] = {
                        defeated: 0,
                        lastFought: 0,
                        currentHP: boss.maxHP,
                        inBattle: false
                    };
                });
            }
            if (!gameState.bossStats) {
                gameState.bossStats = {
                    totalDefeated: 0,
                    totalDamage: 0,
                    bestReward: 0
                };
            }
        }
        
        function updateBossesDisplay() {
            initializeBossState();
            
            const container = document.getElementById('bossesContainer');
            if (!container) return;
            
            container.innerHTML = '';
            
            // Update stats
            document.getElementById('totalBossesDefeated').textContent = gameState.bossStats.totalDefeated || 0;
            document.getElementById('totalBossDamage').textContent = formatNumber(gameState.bossStats.totalDamage || 0);
            document.getElementById('bestBossReward').textContent = '$' + formatNumber(gameState.bossStats.bestReward || 0);
            
            bossesData.forEach(boss => {
                const bossState = gameState.bosses[boss.id];
                const canFight = gameState.money >= boss.cost;
                const onCooldown = bossState.lastFought > 0 && (Date.now() - bossState.lastFought) < 86400000; // 24 hours
                
                const card = document.createElement('div');
                card.className = 'recipe-card';
                card.style.border = `3px solid ${boss.color}`;
                card.style.background = `linear-gradient(135deg, var(--bg-medium), ${boss.color}22)`;
                
                card.innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 4rem; margin-bottom: 10px;">${boss.emoji}</div>
                        <h3 style="color: ${boss.color}; margin: 10px 0;">${boss.name}</h3>
                        <div style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 5px;">${boss.description}</div>
                        <div style="display: inline-block; padding: 4px 12px; background: ${boss.color}33; border-radius: 12px; font-size: 0.85rem; font-weight: bold; color: ${boss.color}; margin: 5px 0;">
                            ${boss.difficulty}
                        </div>
                    </div>
                    
                    <div style="margin: 15px 0; padding: 15px; background: var(--bg-dark); border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span style="color: var(--text-secondary);">ðŸ’ª HP:</span>
                            <span style="color: var(--danger); font-weight: bold;">${formatNumber(boss.maxHP)}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span style="color: var(--text-secondary);">ðŸ’° Entry Cost:</span>
                            <span style="color: var(--accent-gold); font-weight: bold;">$${formatNumber(boss.cost)}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: var(--text-secondary);">ðŸ† Defeated:</span>
                            <span style="color: var(--success); font-weight: bold;">${bossState.defeated}x</span>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg-dark); padding: 12px; border-radius: 8px; margin: 15px 0;">
                        <div style="color: var(--accent-gold); font-weight: bold; margin-bottom: 8px;">ðŸŽ Rewards:</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem; line-height: 1.6;">
                            ${boss.rewards.moneyMin ? `ðŸ’° $${formatNumber(boss.rewards.moneyMin)} - $${formatNumber(boss.rewards.moneyMax)}<br>` : ''}
                            ${boss.rewards.guaranteed ? `âœ¨ Guaranteed ${boss.rewards.guaranteed} item<br>` : ''}
                            ${boss.rewards.battlePassTiers ? `ðŸ“Š +${boss.rewards.battlePassTiers} Battle Pass Tiers<br>` : ''}
                            ${boss.rewards.randomPet ? `ðŸ‰ Random Pet<br>` : ''}
                            ${boss.rewards.randomArtifact ? `ðŸ’Ž Random Artifact<br>` : ''}
                            ${boss.rewards.prestigePoints ? `â­ +${boss.rewards.prestigePoints} Prestige Points<br>` : ''}
                            ${boss.rewards.crates ? `ðŸ“¦ ${boss.rewards.crates} Legendary Crates<br>` : ''}
                        </div>
                    </div>
                    
                    ${onCooldown ? `
                        <div style="text-align: center; padding: 10px; background: var(--warning)33; border-radius: 8px; color: var(--warning); margin-bottom: 10px;">
                            â° On Cooldown - Wait 24h
                        </div>
                    ` : ''}
                    
                    <button class="btn ${canFight && !onCooldown ? 'btn-accept' : 'btn-decline'}" 
                            onclick="startBossFight('${boss.id}')" 
                            ${!canFight || onCooldown ? 'disabled' : ''}
                            style="width: 100%; padding: 15px; font-size: 1.1rem; ${!canFight || onCooldown ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
                        ${!canFight ? 'âŒ Not Enough Money' : onCooldown ? 'â° On Cooldown' : 'âš”ï¸ FIGHT BOSS'}
                    </button>
                `;
                
                container.appendChild(card);
            });
        }
        
        function startBossFight(bossId) {
            initializeBossState();
            const boss = bossesData.find(b => b.id === bossId);
            if (!boss) return;
            
            const bossState = gameState.bosses[bossId];
            
            // Check cooldown
            if (bossState.lastFought > 0 && (Date.now() - bossState.lastFought) < 86400000) {
                showNotification('â° This boss is on cooldown! Wait 24 hours.', 'var(--warning)');
                return;
            }
            
            // Check cost
            if (gameState.money < boss.cost) {
                showNotification(`âŒ Need $${formatNumber(boss.cost)} to fight this boss!`, 'var(--danger)');
                return;
            }
            
            // Pay cost
            gameState.money -= boss.cost;
            playSound('coin');
            
            // Reset boss HP
            bossState.currentHP = boss.maxHP;
            bossState.inBattle = true;
            
            playSound('boss_appear');
            showNotification(`ðŸ‘¹ ${boss.name} appears! Click to attack!`, boss.color);
            
            // Create boss fight modal
            const modal = document.createElement('div');
            modal.id = 'bossFightModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.95);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: var(--bg-dark);
                padding: 30px;
                border-radius: 15px;
                border: 3px solid ${boss.color};
                max-width: 600px;
                width: 90%;
                text-align: center;
            `;
            
            content.innerHTML = `
                <div style="font-size: 6rem; margin-bottom: 20px; animation: boss-float 2s ease-in-out infinite;" id="bossEmoji">${boss.emoji}</div>
                <h2 style="color: ${boss.color}; margin-bottom: 10px;">${boss.name}</h2>
                <div style="color: var(--text-secondary); margin-bottom: 20px;">${boss.difficulty} - ${boss.description}</div>
                
                <div style="margin: 20px 0;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span style="color: var(--text-secondary);">HP:</span>
                        <span style="color: var(--danger); font-weight: bold;" id="bossHPText">${formatNumber(bossState.currentHP)} / ${formatNumber(boss.maxHP)}</span>
                    </div>
                    <div class="progress-bar" style="height: 30px;">
                        <div class="progress-fill" id="bossHPBar" style="width: 100%; background: linear-gradient(90deg, var(--danger), var(--warning)); transition: width 0.3s;">
                            <span style="font-weight: bold;">100%</span>
                        </div>
                    </div>
                </div>
                
                <button class="btn btn-accept" onclick="attackBoss('${bossId}')" id="attackButton" style="width: 100%; padding: 20px; font-size: 1.3rem; margin-top: 20px;">
                    âš”ï¸ ATTACK!
                </button>
                
                <div style="margin-top: 15px; color: var(--text-secondary); font-size: 0.9rem;">
                    Click to deal damage!
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        
        function attackBoss(bossId) {
            const boss = bossesData.find(b => b.id === bossId);
            const bossState = gameState.bosses[bossId];
            
            if (!bossState.inBattle) return;
            
            // Calculate damage (random between 50-200)
            const damage = Math.floor(Math.random() * 151) + 50;
            bossState.currentHP = Math.max(0, bossState.currentHP - damage);
            
            gameState.bossStats.totalDamage = (gameState.bossStats.totalDamage || 0) + damage;
            
            playSound('boss_hit');
            
            // Update HP bar
            const hpPercent = (bossState.currentHP / boss.maxHP) * 100;
            document.getElementById('bossHPBar').style.width = hpPercent + '%';
            document.getElementById('bossHPBar').innerHTML = `<span style="font-weight: bold;">${hpPercent.toFixed(0)}%</span>`;
            document.getElementById('bossHPText').textContent = `${formatNumber(bossState.currentHP)} / ${formatNumber(boss.maxHP)}`;
            
            // Screen shake on hit
            const emoji = document.getElementById('bossEmoji');
            emoji.style.animation = 'none';
            setTimeout(() => { emoji.style.animation = 'boss-float 2s ease-in-out infinite'; }, 10);
            
            // Check if defeated
            if (bossState.currentHP <= 0) {
                defeatBoss(bossId);
            }
        }
        
        function defeatBoss(bossId) {
            const boss = bossesData.find(b => b.id === bossId);
            const bossState = gameState.bosses[bossId];
            
            bossState.inBattle = false;
            bossState.defeated++;
            bossState.lastFought = Date.now();
            
            gameState.bossStats.totalDefeated++;
            
            playSound('boss_defeated');
            
            // Calculate rewards
            const moneyReward = Math.floor(Math.random() * (boss.rewards.moneyMax - boss.rewards.moneyMin + 1)) + boss.rewards.moneyMin;
            gameState.money += moneyReward;
            
            if (moneyReward > gameState.bossStats.bestReward) {
                gameState.bossStats.bestReward = moneyReward;
            }
            
            let rewardText = `ðŸ’° $${formatNumber(moneyReward)}`;
            
            // Give item rewards
            if (boss.rewards.guaranteed) {
                const guaranteedRarity = rarities.find(r => r.name === boss.rewards.guaranteed);
                const itemName = generateItemName(guaranteedRarity);
                addItemToInventory(itemName, guaranteedRarity);
                rewardText += `<br>âœ¨ ${itemName} (${boss.rewards.guaranteed})`;
            }
            
            // Battle pass tiers
            if (boss.rewards.battlePassTiers) {
                gameState.battlePassTier = Math.min(50, (gameState.battlePassTier || 0) + boss.rewards.battlePassTiers);
                rewardText += `<br>ðŸ“Š +${boss.rewards.battlePassTiers} Battle Pass Tiers`;
            }
            
            // Random pet
            if (boss.rewards.randomPet) {
                const availablePetsNotOwned = availablePets.filter(p => !gameState.pets.includes(p.id));
                if (availablePetsNotOwned.length > 0) {
                    const randomPet = availablePetsNotOwned[Math.floor(Math.random() * availablePetsNotOwned.length)];
                    gameState.pets.push(randomPet.id);
                    gameState.petLevels[randomPet.id] = 1;
                    rewardText += `<br>ðŸ‰ ${randomPet.name}`;
                }
            }
            
            // Prestige points
            if (boss.rewards.prestigePoints) {
                gameState.prestigePoints = (gameState.prestigePoints || 0) + boss.rewards.prestigePoints;
                rewardText += `<br>â­ +${boss.rewards.prestigePoints} Prestige Points`;
            }
            
            // Random artifact
            if (boss.rewards.randomArtifact) {
                const unownedArtifacts = artifactsData.filter(a => !gameState.artifacts || !gameState.artifacts.includes(a.id));
                if (unownedArtifacts.length > 0) {
                    const randomArtifact = unownedArtifacts[Math.floor(Math.random() * unownedArtifacts.length)];
                    if (!gameState.artifacts) gameState.artifacts = [];
                    gameState.artifacts.push(randomArtifact.id);
                    rewardText += `<br>ðŸ’Ž ${randomArtifact.name}`;
                    playSound('artifact');
                }
            }
            
            // Close modal and show rewards
            const modal = document.getElementById('bossFightModal');
            if (modal) {
                modal.innerHTML = `
                    <div style="background: var(--bg-dark); padding: 40px; border-radius: 15px; border: 3px solid var(--accent-gold); max-width: 600px; width: 90%; text-align: center; margin: auto;">
                        <div style="font-size: 8rem; margin-bottom: 20px;">ðŸ†</div>
                        <h2 style="color: var(--accent-gold); margin-bottom: 20px;">VICTORY!</h2>
                        <div style="font-size: 1.2rem; color: var(--text-primary); margin-bottom: 30px;">
                            You defeated ${boss.name}!
                        </div>
                        <div style="background: var(--bg-medium); padding: 20px; border-radius: 10px; margin: 20px 0;">
                            <div style="color: var(--accent-gold); font-weight: bold; margin-bottom: 15px; font-size: 1.1rem;">ðŸŽ Rewards:</div>
                            <div style="color: var(--text-primary); line-height: 2; font-size: 1.1rem;">${rewardText}</div>
                        </div>
                        <button class="btn btn-accept" onclick="closeBossFight()" style="width: 100%; padding: 15px; font-size: 1.2rem;">
                            âœ¨ CLAIM REWARDS
                        </button>
                    </div>
                `;
            }
            
            updateStats();
            updateBossesDisplay();
            checkAchievements();
        }
        
        function closeBossFight() {
            const modal = document.getElementById('bossFightModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // ===== ARTIFACTS SYSTEM =====
        
        const artifactsData = [
            // Tier 1 - Common ($1M)
            { id: 'lucky_coin', name: 'ðŸª™ Lucky Coin', tier: 1, cost: 1000000, bonus: { type: 'luck', value: 0.10 }, description: '+10% permanent luck' },
            { id: 'time_crystal', name: 'â±ï¸ Time Crystal', tier: 1, cost: 1000000, bonus: { type: 'autoSpinSpeed', value: 1.5 }, description: 'Auto-spin 1.5x faster' },
            { id: 'extra_pouch', name: 'ðŸ“¦ Extra Pouch', tier: 1, cost: 1000000, bonus: { type: 'inventorySlots', value: 25 }, description: '+25 inventory slots' },
            
            // Tier 2 - Rare ($5M)
            { id: 'loaded_dice', name: 'ðŸŽ² Loaded Dice', tier: 2, cost: 5000000, bonus: { type: 'doubleSpin', value: 0.05 }, description: '5% chance for double spin' },
            { id: 'golden_goose', name: 'ðŸ’° Golden Goose', tier: 2, cost: 5000000, bonus: { type: 'sellValue', value: 2 }, description: '2x sell value' },
            { id: 'skill_tome', name: 'ðŸ“š Skill Tome', tier: 2, cost: 5000000, bonus: { type: 'xpGain', value: 2 }, description: '2x XP gain' },
            
            // Tier 3 - Epic ($25M)
            { id: 'royal_crown', name: 'ðŸ‘‘ Royal Crown', tier: 3, cost: 25000000, bonus: { type: 'allStats', value: 0.25 }, description: '+25% all stats' },
            { id: 'crystal_ball', name: 'ðŸ”® Crystal Ball', tier: 3, cost: 25000000, bonus: { type: 'seeNext', value: 1 }, description: 'See next spin rarity' },
            { id: 'philosophers_stone', name: 'âš—ï¸ Philosopher\'s Stone', tier: 3, cost: 25000000, bonus: { type: 'freeCrafting', value: 1 }, description: 'Free crafting forever' },
            
            // Tier 4 - Legendary ($100M)
            { id: 'wishing_star', name: 'ðŸŒŸ Wishing Star', tier: 4, cost: 100000000, bonus: { type: 'reSpinDaily', value: 1 }, description: 'Re-spin once per day' },
            { id: 'hourglass_ages', name: 'â³ Hourglass of Ages', tier: 4, cost: 100000000, bonus: { type: 'timeFreeze', value: 0.05 }, description: '5% chance for 10 free spins' },
            { id: 'eternal_diamond', name: 'ðŸ’Ž Eternal Diamond', tier: 4, cost: 100000000, bonus: { type: 'noValueDecay', value: 1 }, description: 'Items never lose value' },
            
            // Tier 5 - Mythic (Boss Drops)
            { id: 'dragons_hoard', name: 'ðŸ‰ Dragon\'s Hoard', tier: 5, cost: 0, bonus: { type: 'moneyMultiplier', value: 3 }, description: '3x money from all sources', bossOnly: true },
            { id: 'mask_of_fate', name: 'ðŸŽ­ Mask of Fate', tier: 5, cost: 0, bonus: { type: 'guaranteeNextTier', value: 1 }, description: 'Guarantee next rarity tier', bossOnly: true },
            { id: 'infinity_stone', name: 'â™¾ï¸ Infinity Stone', tier: 5, cost: 0, bonus: { type: 'bonusMultiplier', value: 0.50 }, description: 'All bonuses +50%', bossOnly: true }
        ];
        
        function initializeArtifactsState() {
            if (!gameState.artifacts) {
                gameState.artifacts = [];
            }
        }
        
        function updateArtifactsDisplay() {
            initializeArtifactsState();
            
            const container = document.getElementById('artifactsContainer');
            if (!container) return;
            
            container.innerHTML = '';
            
            // Update stats
            document.getElementById('artifactsOwned').textContent = gameState.artifacts.length;
            const totalPower = calculateTotalArtifactPower();
            document.getElementById('totalArtifactPower').textContent = totalPower.toFixed(0) + '%';
            
            // Group by tier
            const tiers = [
                { name: 'Tier 1 - Common Artifacts', tier: 1, color: 'var(--rarity-common)' },
                { name: 'Tier 2 - Rare Artifacts', tier: 2, color: 'var(--rarity-rare)' },
                { name: 'Tier 3 - Epic Artifacts', tier: 3, color: 'var(--rarity-epic)' },
                { name: 'Tier 4 - Legendary Artifacts', tier: 4, color: 'var(--rarity-legendary)' },
                { name: 'Tier 5 - Mythic Artifacts (Boss Drops)', tier: 5, color: 'var(--rarity-mythic)' }
            ];
            
            tiers.forEach(tierInfo => {
                const tierArtifacts = artifactsData.filter(a => a.tier === tierInfo.tier);
                
                const tierSection = document.createElement('div');
                tierSection.style.marginBottom = '30px';
                
                const tierHeader = document.createElement('h3');
                tierHeader.style.color = tierInfo.color;
                tierHeader.style.marginBottom = '15px';
                tierHeader.textContent = tierInfo.name;
                tierSection.appendChild(tierHeader);
                
                const tierGrid = document.createElement('div');
                tierGrid.style.display = 'grid';
                tierGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(300px, 1fr))';
                tierGrid.style.gap = '15px';
                
                tierArtifacts.forEach(artifact => {
                    const owned = gameState.artifacts.includes(artifact.id);
                    const canBuy = !artifact.bossOnly && gameState.money >= artifact.cost && !owned;
                    
                    const card = document.createElement('div');
                    card.className = 'recipe-card';
                    card.style.border = owned ? `3px solid ${tierInfo.color}` : '2px solid var(--bg-medium)';
                    card.style.opacity = owned ? '1' : '0.7';
                    
                    card.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                            <div style="font-size: 3rem;">${artifact.name.split(' ')[0]}</div>
                            <div style="flex: 1;">
                                <h4 style="color: ${tierInfo.color}; margin: 0 0 5px 0;">${artifact.name.substring(3)}</h4>
                                <div style="color: var(--text-secondary); font-size: 0.85rem;">${artifact.description}</div>
                            </div>
                        </div>
                        
                        ${!artifact.bossOnly ? `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--bg-dark); border-radius: 8px; margin-bottom: 15px;">
                                <span style="color: var(--text-secondary);">Cost:</span>
                                <span style="color: var(--accent-gold); font-weight: bold; font-size: 1.1rem;">$${formatNumber(artifact.cost)}</span>
                            </div>
                        ` : `
                            <div style="padding: 12px; background: var(--danger)33; border-radius: 8px; margin-bottom: 15px; text-align: center; color: var(--danger);">
                                ðŸ† Boss Drop Only
                            </div>
                        `}
                        
                        ${owned ? `
                            <div style="text-align: center; padding: 15px; background: ${tierInfo.color}33; border-radius: 8px; color: ${tierInfo.color}; font-weight: bold;">
                                âœ… OWNED - Bonus Active!
                            </div>
                        ` : artifact.bossOnly ? `
                            <div style="text-align: center; padding: 15px; background: var(--bg-dark); border-radius: 8px; color: var(--text-secondary);">
                                Defeat bosses to unlock
                            </div>
                        ` : `
                            <button class="btn ${canBuy ? 'btn-accept' : 'btn-decline'}" 
                                    onclick="buyArtifact('${artifact.id}')" 
                                    ${!canBuy ? 'disabled' : ''}
                                    style="width: 100%; padding: 12px; ${!canBuy ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
                                ${!canBuy ? 'ðŸ”’ Locked' : 'ðŸ’Ž Purchase'}
                            </button>
                        `}
                    `;
                    
                    tierGrid.appendChild(card);
                });
                
                tierSection.appendChild(tierGrid);
                container.appendChild(tierSection);
            });
        }
        
        function buyArtifact(artifactId) {
            initializeArtifactsState();
            
            const artifact = artifactsData.find(a => a.id === artifactId);
            if (!artifact) return;
            
            if (artifact.bossOnly) {
                showNotification('âŒ This artifact can only be obtained from boss drops!', 'var(--danger)');
                return;
            }
            
            if (gameState.artifacts.includes(artifactId)) {
                showNotification('âœ… You already own this artifact!', 'var(--warning)');
                return;
            }
            
            if (gameState.money < artifact.cost) {
                showNotification(`âŒ Need $${formatNumber(artifact.cost)} to purchase this artifact!`, 'var(--danger)');
                return;
            }
            
            // Purchase artifact
            gameState.money -= artifact.cost;
            gameState.artifacts.push(artifactId);
            
            playSound('artifact');
            showNotification(`ðŸ’Ž Artifact Acquired: ${artifact.name}!`, 'var(--accent-gold)');
            
            updateStats();
            updateArtifactsDisplay();
            checkAchievements();
        }
        
        function calculateTotalArtifactPower() {
            if (!gameState.artifacts || gameState.artifacts.length === 0) return 0;
            
            let totalPower = 0;
            gameState.artifacts.forEach(artifactId => {
                const artifact = artifactsData.find(a => a.id === artifactId);
                if (artifact) {
                    // Calculate "power" as a percentage
                    if (artifact.bonus.type === 'luck') totalPower += artifact.bonus.value * 100;
                    if (artifact.bonus.type === 'allStats') totalPower += artifact.bonus.value * 100;
                    if (artifact.bonus.type === 'sellValue') totalPower += (artifact.bonus.value - 1) * 100;
                    if (artifact.bonus.type === 'xpGain') totalPower += (artifact.bonus.value - 1) * 100;
                    if (artifact.bonus.type === 'moneyMultiplier') totalPower += (artifact.bonus.value - 1) * 100;
                    if (artifact.bonus.type === 'bonusMultiplier') totalPower += artifact.bonus.value * 100;
                    if (artifact.bonus.type === 'doubleSpin') totalPower += artifact.bonus.value * 100;
                    if (artifact.bonus.type === 'autoSpinSpeed') totalPower += (artifact.bonus.value - 1) * 50;
                    // Special artifacts count as 25 power
                    if (['seeNext', 'freeCrafting', 'reSpinDaily', 'guaranteeNextTier', 'noValueDecay', 'timeFreeze'].includes(artifact.bonus.type)) {
                        totalPower += 25;
                    }
                }
            });
            
            return totalPower;
        }
        
        function getArtifactBonus(bonusType) {
            if (!gameState.artifacts) return 0;
            
            let total = 0;
            gameState.artifacts.forEach(artifactId => {
                const artifact = artifactsData.find(a => a.id === artifactId);
                if (artifact && artifact.bonus.type === bonusType) {
                    total += artifact.bonus.value;
                }
            });
            
            return total;
        }
        
        function hasArtifact(artifactId) {
            return gameState.artifacts && gameState.artifacts.includes(artifactId);
        }
        
        // ===== SOUND EFFECTS SYSTEM =====
        
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        const soundEffects = {
            coin: { frequency: 800, duration: 0.1, type: 'sine' },
            spin: { frequency: 400, duration: 0.15, type: 'sawtooth' },
            rare: { frequency: 600, duration: 0.3, type: 'square', slide: 900 },
            ultra_rare: { frequency: 400, duration: 0.5, type: 'sine', slide: 1200 },
            achievement: { frequency: 523.25, duration: 0.4, type: 'sine', chord: [659.25, 783.99] },
            success: { frequency: 650, duration: 0.2, type: 'sine' },
            error: { frequency: 200, duration: 0.2, type: 'sawtooth' },
            button: { frequency: 300, duration: 0.05, type: 'sine' },
            fusion: { frequency: 500, duration: 0.4, type: 'triangle', slide: 800 },
            boss_appear: { frequency: 150, duration: 0.6, type: 'sawtooth', slide: 300 },
            boss_hit: { frequency: 100, duration: 0.2, type: 'square' },
            boss_defeated: { frequency: 400, duration: 0.6, type: 'sine', chord: [500, 600, 800] },
            artifact: { frequency: 800, duration: 0.8, type: 'sine', chord: [1000, 1200, 1600] }
        };
        
        function playSound(soundName) {
            if (!gameState.settings || gameState.settings.soundEffects === false) return;
            
            try {
                const sound = soundEffects[soundName];
                if (!sound) return;
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = sound.type;
                oscillator.frequency.value = sound.frequency;
                
                // Frequency slide for special effects
                if (sound.slide) {
                    oscillator.frequency.exponentialRampToValueAtTime(
                        sound.slide,
                        audioContext.currentTime + sound.duration
                    );
                }
                
                // Volume envelope
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + sound.duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + sound.duration);
                
                // Play chord if specified
                if (sound.chord) {
                    sound.chord.forEach((freq, i) => {
                        setTimeout(() => {
                            const chordOsc = audioContext.createOscillator();
                            const chordGain = audioContext.createGain();
                            
                            chordOsc.connect(chordGain);
                            chordGain.connect(audioContext.destination);
                            
                            chordOsc.type = 'sine';
                            chordOsc.frequency.value = freq;
                            
                            chordGain.gain.setValueAtTime(0.2, audioContext.currentTime);
                            chordGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + sound.duration * 0.8);
                            
                            chordOsc.start(audioContext.currentTime);
                            chordOsc.stop(audioContext.currentTime + sound.duration * 0.8);
                        }, i * 50);
                    });
                }
            } catch (e) {
                console.log('Sound playback failed:', e);
            }
        }
        
        // ===== KEYBOARD SHORTCUTS =====
        
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            // Prevent default for shortcuts we're using
            const shortcutKeys = ['Space', ' ', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 's', 'S', 'i', 'I', 'b', 'B', 'a', 'A', 'p', 'P', 'r', 'R', 'Escape'];
            if (shortcutKeys.includes(e.key)) {
                e.preventDefault();
            }
            
            switch(e.key) {
                // Space - Spin
                case ' ':
                case 'Space':
                    spinItem();
                    break;
                
                // Number keys - Switch tabs
                case '1':
                    switchTab('inventory');
                    break;
                case '2':
                    switchTab('shop');
                    break;
                case '3':
                    switchTab('trades');
                    break;
                case '4':
                    switchTab('craft');
                    break;
                case '5':
                    switchTab('enchant');
                    break;
                case '6':
                    switchTab('fusion');
                    break;
                case '7':
                    switchTab('collections');
                    break;
                case '8':
                    switchTab('quests');
                    break;
                case '9':
                    switchTab('achievements');
                    break;
                case '0':
                    switchTab('settings');
                    break;
                
                // Letter shortcuts
                case 's':
                case 'S':
                    switchTab('shop');
                    break;
                case 'i':
                case 'I':
                    switchTab('inventory');
                    break;
                case 'b':
                case 'B':
                    switchTab('bosses');
                    break;
                case 'a':
                case 'A':
                    switchTab('artifacts');
                    break;
                case 'p':
                case 'P':
                    switchTab('prestige');
                    break;
                case 'r':
                case 'R':
                    switchTab('rebirth');
                    break;
                
                // Escape - Close modals
                case 'Escape':
                    closeBossFight();
                    break;
            }
        });
        
        // ===== TIMED SPECIAL EVENTS SYSTEM =====
        
        const timedEvents = [
            { time: '10:59', action: 'message', message: 'Early bird in a minute' },
            { time: '11:00', action: 'event', eventType: 'disco', message: 'ðŸª© DISCO EVENT STARTED!' },
            { time: '11:40', action: 'event', eventType: 'disco', message: 'ðŸª© DISCO EVENT STARTED!' },
            { time: '11:41', action: 'message', message: 'Real ones will know what they want' },
            { time: '11:42', action: 'givePrimordial', message: 'ðŸŽ FREE PRIMORDIAL ITEM!' },
            { time: '11:43', action: 'message', message: 'Enjoy' },
            { time: '11:44', action: 'message', message: 'first admin abuse hows it going' },
            { time: '11:45', action: 'event', eventType: 'galactic', message: 'ðŸŒŒ GALAXY EVENT STARTED!' },
            { time: '11:46', action: 'message', message: 'this is just to test' },
            { time: '11:47', action: 'giveMoney', amount: 50000, message: 'ðŸ’° FREE $50,000!' },
            { time: '11:48', action: 'message', message: 'Guys stop spamming me to give you guys beyond infinity im not going to' },
            { time: '11:49', action: 'message', message: 'Hope yalls enjoy next event will be longer and better' },
            { time: '11:50', action: 'event', eventType: 'bloodmoon', message: 'ðŸ”´ BLOOD MOON EVENT STARTED!' },
            { time: '11:51', action: 'message', message: 'Next admin abuse is on wendsday its going to be better' },
            { time: '11:52', action: 'message', message: 'Cya and have a nice day' }
        ];
        
        // Track which events have been triggered today
        if (!gameState.triggeredTimedEvents) {
            gameState.triggeredTimedEvents = {};
        }
        
        function checkTimedEvents() {
            const now = new Date();
            const currentTime = `${now.getHours()}:${String(now.getMinutes()).padStart(2, '0')}`;
            const todayKey = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}`;
            
            // Reset triggered events at midnight
            if (!gameState.triggeredTimedEvents[todayKey]) {
                gameState.triggeredTimedEvents = { [todayKey]: [] };
            }
            
            timedEvents.forEach(event => {
                const eventKey = `${todayKey}-${event.time}`;
                
                // Check if current time matches event time and hasn't been triggered yet
                if (currentTime === event.time && !gameState.triggeredTimedEvents[todayKey].includes(event.time)) {
                    // Mark as triggered
                    gameState.triggeredTimedEvents[todayKey].push(event.time);
                    
                    // Execute the event action
                    switch(event.action) {
                        case 'event':
                            startSpecialEvent(event.eventType);
                            showNotification(event.message, 'var(--accent-gold)');
                            playSound('achievement');
                            break;
                            
                        case 'message':
                            showNotification(`ðŸ“¢ ${event.message}`, 'var(--accent-primary)');
                            playSound('button');
                            break;
                            
                        case 'givePrimordial':
                            const primordialRarity = rarities.find(r => r.name === 'Primordial');
                            if (primordialRarity) {
                                const itemName = generateItemName(primordialRarity);
                                addItemToInventory(itemName, primordialRarity);
                                showNotification(event.message + ` You got ${itemName}!`, primordialRarity.color);
                                playSound('ultra_rare');
                                updateInventory();
                            }
                            break;
                            
                        case 'giveMoney':
                            gameState.money += event.amount;
                            showNotification(event.message, 'var(--accent-gold)');
                            playSound('coin');
                            updateStats();
                            break;
                    }
                }
            });
        }
        
        // Check timed events every minute
        setInterval(checkTimedEvents, 60000);
        // Also check immediately on load
        checkTimedEvents();
        
        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            initializeBossState();
            initializeArtifactsState();
            updateBossesDisplay();
            updateArtifactsDisplay();
        });
        
        // Auto-save every 30 seconds
        setInterval(() => {
            saveGame(true); // Pass true to indicate auto-save
        }, 30000);
    </script>
</body>
</html>
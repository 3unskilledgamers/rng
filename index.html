<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RNG Trader - Spin & Trade Empire</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0a0e27;
            --bg-medium: #1a1f3a;
            --bg-light: #2a3154;
            --accent-primary: #00ffcc;
            --accent-secondary: #ff00aa;
            --accent-gold: #ffd700;
            --text-primary: #ffffff;
            --text-secondary: #a0a8c0;
            --success: #00ff88;
            --danger: #ff3366;
            --warning: #ffaa00;
            
            --rarity-common: #b0b0b0;
            --rarity-uncommon: #5eff5e;
            --rarity-rare: #5e9eff;
            --rarity-epic: #b45eff;
            --rarity-legendary: #ffaa00;
            --rarity-mythic: #ff3366;
            --rarity-exotic: #00ffcc;
            --rarity-celestial: #ffe4f5;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Space Mono', monospace;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #1a1535 100%);
            color: var(--text-primary);
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        /* Animated background stars */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, white, transparent),
                radial-gradient(2px 2px at 60% 70%, white, transparent),
                radial-gradient(1px 1px at 50% 50%, white, transparent),
                radial-gradient(1px 1px at 80% 10%, white, transparent),
                radial-gradient(2px 2px at 90% 60%, white, transparent),
                radial-gradient(1px 1px at 33% 80%, white, transparent);
            background-size: 200% 200%;
            animation: stars 120s linear infinite;
            opacity: 0.3;
            pointer-events: none;
            z-index: 0;
        }
        
        @keyframes stars {
            from { background-position: 0 0; }
            to { background-position: 200% 200%; }
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        header {
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            padding: 30px 0;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 2rem;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { filter: drop-shadow(0 0 5px var(--accent-primary)); }
            to { filter: drop-shadow(0 0 20px var(--accent-secondary)); }
        }
        
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: linear-gradient(135deg, var(--bg-medium), var(--bg-light));
            border: 2px solid var(--accent-primary);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 255, 204, 0.2);
            transition: all 0.3s;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 255, 204, 0.4);
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-primary);
            margin-top: 5px;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .tab-button {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            padding: 15px 25px;
            background: var(--bg-medium);
            border: 2px solid var(--accent-primary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }
        
        .tab-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 204, 0.3), transparent);
            transition: left 0.5s;
        }
        
        .tab-button:hover::before {
            left: 100%;
        }
        
        .tab-button:hover {
            background: var(--bg-light);
            transform: translateY(-2px);
        }
        
        .tab-button.active {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-dark);
            border-color: var(--accent-gold);
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.6);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .spin-section {
            background: var(--bg-medium);
            border: 3px solid var(--accent-primary);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 10px 50px rgba(0, 255, 204, 0.3);
            margin-bottom: 30px;
        }
        
        .spin-button {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.2rem;
            padding: 25px 50px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border: none;
            color: var(--bg-dark);
            cursor: pointer;
            border-radius: 15px;
            transition: all 0.3s;
            box-shadow: 0 8px 25px rgba(255, 0, 170, 0.4);
            position: relative;
            overflow: hidden;
        }
        
        .spin-button:hover {
            transform: scale(1.1) rotate(-2deg);
            box-shadow: 0 12px 35px rgba(255, 0, 170, 0.6);
        }
        
        .spin-button:active {
            transform: scale(0.95);
        }
        
        .spin-button.spinning {
            animation: spin-pulse 0.5s ease-in-out infinite;
            pointer-events: none;
        }
        
        @keyframes spin-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .result-display {
            margin-top: 30px;
            padding: 30px;
            background: var(--bg-light);
            border-radius: 15px;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px dashed var(--accent-primary);
        }
        
        .item-display {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 10px 0;
            padding: 15px 30px;
            border-radius: 10px;
            animation: itemAppear 0.5s ease-out;
        }
        
        @keyframes itemAppear {
            from { transform: scale(0) rotate(-180deg); opacity: 0; }
            to { transform: scale(1) rotate(0); opacity: 1; }
        }
        
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .inventory-item {
            background: var(--bg-light);
            border: 2px solid;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        
        .inventory-item:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 255, 204, 0.4);
        }
        
        .inventory-item.flexed {
            border-width: 4px;
            animation: flex-glow 1s ease-in-out infinite;
        }
        
        @keyframes flex-glow {
            0%, 100% { box-shadow: 0 0 10px currentColor; }
            50% { box-shadow: 0 0 25px currentColor; }
        }
        
        .item-name {
            font-weight: bold;
            margin: 10px 0 5px;
        }
        
        .item-value {
            color: var(--accent-gold);
            font-size: 0.9rem;
        }
        
        .item-count {
            position: absolute;
            top: 5px;
            right: 5px;
            background: var(--accent-secondary);
            color: white;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .npc-container {
            background: var(--bg-medium);
            border: 2px solid var(--accent-secondary);
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
        }
        
        .npc-card {
            background: var(--bg-light);
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            animation: slideIn 0.5s ease-out;
        }
        
        @keyframes slideIn {
            from { transform: translateX(-50px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .npc-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .npc-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: var(--accent-primary);
        }
        
        .npc-type {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.7rem;
            text-transform: uppercase;
        }
        
        .npc-type.honest { background: var(--success); color: var(--bg-dark); }
        .npc-type.scammer { background: var(--danger); color: white; }
        .npc-type.fair { background: var(--warning); color: var(--bg-dark); }
        
        .trade-offer {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
            padding: 15px;
            background: var(--bg-medium);
            border-radius: 10px;
        }
        
        .trade-buttons {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            padding: 12px 25px;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        
        .btn-accept {
            background: var(--success);
            border-color: var(--success);
            color: var(--bg-dark);
        }
        
        .btn-accept:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.5);
        }
        
        .btn-decline {
            background: var(--danger);
            border-color: var(--danger);
            color: white;
        }
        
        .btn-decline:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(255, 51, 102, 0.5);
        }
        
        .crafting-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .recipe-card {
            background: var(--bg-light);
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s;
        }
        
        .recipe-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 255, 204, 0.3);
        }
        
        .recipe-requirements {
            margin: 15px 0;
            padding: 15px;
            background: var(--bg-medium);
            border-radius: 8px;
        }
        
        .achievement-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .achievement-card {
            background: var(--bg-light);
            border: 2px solid var(--text-secondary);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s;
            opacity: 0.6;
        }
        
        .achievement-card.unlocked {
            border-color: var(--accent-gold);
            opacity: 1;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }
        
        .achievement-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .battlepass-tier {
            background: var(--bg-light);
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .battlepass-tier.unlocked {
            background: linear-gradient(135deg, var(--bg-light), var(--bg-medium));
            border-color: var(--accent-gold);
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: var(--bg-light);
            border: 2px solid var(--accent-primary);
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transition: width 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .event-banner {
            background: linear-gradient(135deg, #ff0000, #00ff00);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin: 20px 0;
            font-family: 'Press Start 2P', cursive;
            animation: rainbow 3s linear infinite;
        }
        
        @keyframes rainbow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-medium);
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 255, 204, 0.5);
            animation: slideInRight 0.5s ease-out;
            z-index: 1000;
            max-width: 350px;
        }
        
        @keyframes slideInRight {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .enchant-slots {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .enchant-slot {
            padding: 15px 25px;
            background: var(--bg-light);
            border: 2px dashed var(--accent-primary);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .enchant-slot:hover {
            background: var(--bg-medium);
            border-style: solid;
        }
        
        .enchant-slot.filled {
            border-color: var(--accent-gold);
            border-style: solid;
            background: var(--accent-primary);
            color: var(--bg-dark);
        }
        
        @media (max-width: 768px) {
            header {
                font-size: 1.2rem;
            }
            
            .tab-button {
                font-size: 0.6rem;
                padding: 12px 18px;
            }
            
            .spin-button {
                font-size: 0.9rem;
                padding: 18px 35px;
            }
        }
        
        /* Epic Animations for Ultra-Rare Pulls */
        .ultra-rare-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9999;
        }
        
        /* Cosmic (1/1024) - Purple sparkles */
        @keyframes cosmic-sparkle {
            0% { opacity: 0; transform: scale(0) rotate(0deg); }
            50% { opacity: 1; }
            100% { opacity: 0; transform: scale(2) rotate(360deg); }
        }
        
        /* Infinite (1/2048) - Rainbow waves */
        @keyframes infinite-wave {
            0% { transform: translateX(-100%) scale(1); opacity: 0; }
            50% { opacity: 0.8; }
            100% { transform: translateX(100%) scale(1.5); opacity: 0; }
        }
        
        /* Transcendent (1/4096) - Cyan lightning */
        @keyframes transcendent-lightning {
            0%, 100% { opacity: 0; }
            10%, 30%, 50% { opacity: 1; }
            20%, 40%, 60% { opacity: 0.3; }
        }
        
        /* Ethereal (1/8192) - Ghost wisps */
        @keyframes ethereal-wisp {
            0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            20% { opacity: 0.8; }
            80% { opacity: 0.8; }
            100% { transform: translateY(-100vh) rotate(720deg); opacity: 0; }
        }
        
        /* Primordial (1/16384) - Fire explosion */
        @keyframes primordial-explosion {
            0% { transform: scale(0); opacity: 1; }
            50% { transform: scale(3); opacity: 0.8; }
            100% { transform: scale(6); opacity: 0; }
        }
        
        /* Omega (1/32768) - Black hole vortex */
        @keyframes omega-vortex {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(2) rotate(1800deg); opacity: 1; }
            100% { transform: scale(0) rotate(3600deg); opacity: 0; }
        }
        
        /* Supreme (1/65536) - Golden rays */
        @keyframes supreme-rays {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: scale(4) rotate(180deg); opacity: 0; }
        }
        
        /* Godlike (1/131072) - Divine pillars */
        @keyframes godlike-pillar {
            0% { transform: translateY(100vh) scaleY(0); opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { transform: translateY(-100vh) scaleY(2); opacity: 0; }
        }
        
        /* Universal (1/262144) - Galaxy spiral */
        @keyframes universal-spiral {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(5) rotate(1080deg); opacity: 1; }
            100% { transform: scale(10) rotate(2160deg); opacity: 0; }
        }
        
        /* Multiversal (1/524288) - Reality fracture */
        @keyframes multiversal-fracture {
            0%, 100% { opacity: 0; }
            10%, 30%, 50%, 70%, 90% { opacity: 1; }
            20%, 40%, 60%, 80% { opacity: 0; }
        }
        
        /* Omnipotent (1/1048576) - World shake */
        @keyframes omnipotent-shake {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-10px, -10px); }
            20% { transform: translate(10px, 10px); }
            30% { transform: translate(-10px, 10px); }
            40% { transform: translate(10px, -10px); }
            50% { transform: translate(-10px, -10px); }
            60% { transform: translate(10px, 10px); }
            70% { transform: translate(-10px, 10px); }
            80% { transform: translate(10px, -10px); }
            90% { transform: translate(-5px, 5px); }
        }
        
        /* Infinite Absolute (1/2097152) - Dual infinity spirals */
        @keyframes infinite-absolute-spiral {
            0% { transform: scale(1) rotate(0deg); opacity: 0.8; }
            50% { transform: scale(3) rotate(1800deg); opacity: 1; }
            100% { transform: scale(1) rotate(3600deg); opacity: 0.8; }
        }
        
        /* Eternal (1/4194304) - Time ripples */
        @keyframes eternal-ripple {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(2); opacity: 0.8; }
            100% { transform: scale(4); opacity: 0; }
        }
        
        /* Immortal (1/8388608) - Phoenix rebirth */
        @keyframes immortal-rebirth {
            0% { transform: scale(0) rotate(0deg); filter: hue-rotate(0deg); }
            50% { transform: scale(2) rotate(180deg); filter: hue-rotate(180deg); }
            100% { transform: scale(0) rotate(360deg); filter: hue-rotate(360deg); }
        }
        
        /* Ascended (1/16777216) - Heavenly ascension */
        @keyframes ascended-rise {
            0% { transform: translateY(100vh) scale(0.5); opacity: 0; }
            50% { transform: translateY(0) scale(2); opacity: 1; }
            100% { transform: translateY(-100vh) scale(0.5); opacity: 0; }
        }
        
        /* Transcendental (1/33554432) - Reality layers */
        @keyframes transcendental-layers {
            0% { transform: translateZ(0) scale(1); opacity: 0.5; }
            50% { transform: translateZ(100px) scale(3); opacity: 1; }
            100% { transform: translateZ(0) scale(1); opacity: 0.5; }
        }
        
        /* Boundless (1/67108864) - Expanding boundaries */
        @keyframes boundless-expand {
            0% { transform: scale(0.1); border-radius: 50%; }
            50% { transform: scale(5); border-radius: 0%; }
            100% { transform: scale(0.1); border-radius: 50%; }
        }
        
        /* Limitless (1/134217728) - Breaking limits */
        @keyframes limitless-break {
            0% { transform: scale(1); filter: brightness(1); }
            25% { transform: scale(0.1); filter: brightness(5); }
            50% { transform: scale(10); filter: brightness(10); }
            75% { transform: scale(0.1); filter: brightness(5); }
            100% { transform: scale(1); filter: brightness(1); }
        }
        
        /* Absolute (1/268435456) - Universe explosion */
        @keyframes absolute-big-bang {
            0% { transform: scale(0); opacity: 1; filter: brightness(10); }
            50% { transform: scale(20); opacity: 1; filter: brightness(5); }
            100% { transform: scale(50); opacity: 0; filter: brightness(1); }
        }
        
        /* Beyond (1/536870912) - Dimension tear */
        @keyframes beyond-tear {
            0%, 100% { clip-path: inset(0 0 0 0); }
            25% { clip-path: inset(25% 0 25% 0); }
            50% { clip-path: inset(0 25% 0 25%); }
            75% { clip-path: inset(25% 25% 25% 25%); }
        }
        
        /* Incomprehensible (1/1073741824) - Reality distortion */
        @keyframes incomprehensible-distort {
            0% { filter: blur(0px) hue-rotate(0deg); transform: scale(1); }
            25% { filter: blur(20px) hue-rotate(90deg); transform: scale(1.5); }
            50% { filter: blur(40px) hue-rotate(180deg); transform: scale(0.5); }
            75% { filter: blur(20px) hue-rotate(270deg); transform: scale(1.5); }
            100% { filter: blur(0px) hue-rotate(360deg); transform: scale(1); }
        }
        
        /* Unimaginable (1/2147483648) - Kaleidoscope */
        @keyframes unimaginable-kaleidoscope {
            0% { transform: rotate(0deg) scale(1); filter: saturate(1); }
            50% { transform: rotate(1800deg) scale(10); filter: saturate(10); }
            100% { transform: rotate(3600deg) scale(1); filter: saturate(1); }
        }
        
        /* Impossible (1/4294967296) - THE ULTIMATE */
        @keyframes impossible-ultimate {
            0% { transform: scale(1) rotate(0deg); opacity: 1; filter: brightness(1) contrast(1); }
            10% { transform: scale(0); opacity: 0; }
            20% { transform: scale(100) rotate(3600deg); opacity: 1; filter: brightness(100) contrast(10); }
            40% { transform: scale(0.1); opacity: 0.5; }
            60% { transform: scale(50); opacity: 1; }
            80% { transform: scale(0.01); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 0; filter: brightness(1) contrast(1); }
        }
        
        /* Paradox (1/8589934592) - Reality breaks */
        @keyframes paradox-break {
            0% { transform: scale(1); filter: invert(0); }
            20% { transform: scale(3) scaleX(-1); filter: invert(1); }
            40% { transform: scale(0.5) scaleY(-1); filter: invert(0); }
            60% { transform: scale(5) scaleX(-1) scaleY(-1); filter: invert(1); }
            80% { transform: scale(0.1); filter: invert(0); }
            100% { transform: scale(1); filter: invert(0); }
        }
        
        /* Singularity (1/17179869184) - Black hole collapse */
        @keyframes singularity-collapse {
            0% { transform: scale(10); opacity: 1; }
            50% { transform: scale(0.001) rotate(7200deg); opacity: 1; filter: brightness(100); }
            51% { transform: scale(100); opacity: 1; filter: brightness(0.1); }
            100% { transform: scale(0); opacity: 0; }
        }
        
        /* Void (1/34359738368) - Consume everything */
        @keyframes void-consume {
            0% { background: transparent; }
            50% { background: rgba(0,0,0,1); }
            100% { background: transparent; }
        }
        
        /* Nothingness (1/68719476736) - Erase reality */
        @keyframes nothingness-erase {
            0% { opacity: 1; filter: blur(0px); }
            50% { opacity: 0; filter: blur(100px); }
            100% { opacity: 1; filter: blur(0px); }
        }
        
        /* Everything (1/137438953472) - Create universe */
        @keyframes everything-create {
            0% { transform: scale(0); filter: brightness(0); }
            50% { transform: scale(1000); filter: brightness(100); }
            100% { transform: scale(0); filter: brightness(0); }
        }
        
        /* The End (1/274877906944) - Time stops */
        @keyframes end-timestop {
            0%, 30%, 60%, 90% { filter: grayscale(0); }
            15%, 45%, 75% { filter: grayscale(1); }
        }
        
        /* The Beginning (1/549755813888) - Big Bang */
        @keyframes beginning-bigbang {
            0% { transform: scale(0.001); filter: brightness(1000); }
            50% { transform: scale(500); filter: brightness(100); }
            100% { transform: scale(0); filter: brightness(0); }
        }
        
        /* Alpha Omega (1/1099511627776) - Start and End merge */
        @keyframes alphaomega-merge {
            0% { clip-path: circle(0% at 0% 0%); }
            25% { clip-path: circle(100% at 0% 0%); }
            50% { clip-path: circle(0% at 100% 100%); }
            75% { clip-path: circle(100% at 100% 100%); }
            100% { clip-path: circle(0% at 50% 50%); }
        }
        
        /* True Infinity (1/2199023255552) - Endless recursion */
        @keyframes infinity-recursion {
            0% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(100) rotate(1800deg); }
            50% { transform: scale(0.01) rotate(3600deg); }
            75% { transform: scale(100) rotate(5400deg); }
            100% { transform: scale(1) rotate(7200deg); }
        }
        
        /* The One (1/4398046511104) - EXISTENCE ITSELF - OPTIMIZED */
        @keyframes theone-existence {
            0% { transform: scale(0); opacity: 0; filter: brightness(0) saturate(0); }
            25% { transform: scale(50); opacity: 1; filter: brightness(20) saturate(5); }
            50% { transform: scale(0); opacity: 0; filter: brightness(0) saturate(0); }
            75% { transform: scale(50); opacity: 1; filter: brightness(20) saturate(5); }
            100% { transform: scale(0); opacity: 0; filter: brightness(0) saturate(0); }
        }
        
        /* Primeval - Ancient swirling energy */
        @keyframes primeval-swirl {
            0% { transform: rotate(0deg) scale(1); filter: sepia(0); }
            50% { transform: rotate(360deg) scale(3); filter: sepia(1); }
            100% { transform: rotate(720deg) scale(1); filter: sepia(0); }
        }
        
        /* Celestial Prime - Star burst */
        @keyframes celestial-burst {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(10); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }
        
        /* Quantum - Wave collapse */
        @keyframes quantum-wave {
            0%, 100% { transform: scale(1); opacity: 1; filter: blur(0px); }
            25% { transform: scale(0.1); opacity: 0.5; filter: blur(10px); }
            50% { transform: scale(5); opacity: 1; filter: blur(0px); }
            75% { transform: scale(0.1); opacity: 0.5; filter: blur(10px); }
        }
        
        /* Dimensional - Portal effect */
        @keyframes dimensional-portal {
            0% { clip-path: circle(0% at 50% 50%); }
            50% { clip-path: circle(75% at 50% 50%); }
            100% { clip-path: circle(0% at 50% 50%); }
        }
        
        /* Hyperversal - Reality layers */
        @keyframes hyperversal-layers {
            0% { transform: translateZ(0); opacity: 1; }
            50% { transform: translateZ(200px); opacity: 0.5; }
            100% { transform: translateZ(0); opacity: 1; }
        }
        
        /* Outerversal - Edge fade */
        @keyframes outerversal-edge {
            0% { opacity: 1; box-shadow: inset 0 0 100px rgba(0,255,0,1); }
            50% { opacity: 0.3; box-shadow: inset 0 0 200px rgba(0,255,0,0.3); }
            100% { opacity: 1; box-shadow: inset 0 0 100px rgba(0,255,0,1); }
        }
        
        /* Boundaryless - Expanding infinity */
        @keyframes boundaryless-expand {
            0% { transform: scale(0.5); border-radius: 50%; }
            50% { transform: scale(20); border-radius: 0%; }
            100% { transform: scale(0.5); border-radius: 50%; }
        }
        
        /* Formless - Dissolve */
        @keyframes formless-dissolve {
            0%, 100% { opacity: 1; filter: blur(0px); }
            50% { opacity: 0.2; filter: blur(50px); }
        }
        
        /* Abstract - Concept shift */
        @keyframes abstract-shift {
            0% { transform: skew(0deg); }
            25% { transform: skew(30deg, 30deg); }
            50% { transform: skew(-30deg, -30deg); }
            75% { transform: skew(30deg, -30deg); }
            100% { transform: skew(0deg); }
        }
        
        /* Conceptual - Thought pulse */
        @keyframes conceptual-pulse {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(3); filter: brightness(5); }
        }
        
        /* Metaphysical - Being flicker */
        @keyframes metaphysical-flicker {
            0%, 100% { opacity: 1; }
            10%, 30%, 50%, 70%, 90% { opacity: 0; }
            20%, 40%, 60%, 80% { opacity: 1; }
        }
        
        /* The Source - Origin explosion */
        @keyframes source-explosion {
            0% { transform: scale(0.01); filter: brightness(100); }
            50% { transform: scale(100); filter: brightness(10); }
            100% { transform: scale(0); filter: brightness(0); }
        }
        
        /* The Eternal - Time loop */
        @keyframes eternal-loop {
            0% { transform: rotate(0deg) scale(1); }
            100% { transform: rotate(3600deg) scale(1); }
        }
        
        /* The Absolute Infinity - Infinity symbol */
        @keyframes absolute-infinity {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(20) rotate(180deg); }
            100% { transform: scale(1) rotate(360deg); }
        }
        
        /* Beyond Infinity - Transcendence */
        @keyframes beyond-transcend {
            0% { transform: scale(0); opacity: 0; filter: brightness(0) hue-rotate(0deg); }
            25% { transform: scale(50); opacity: 1; filter: brightness(100) hue-rotate(90deg); }
            50% { transform: scale(0); opacity: 0; filter: brightness(0) hue-rotate(180deg); }
            75% { transform: scale(50); opacity: 1; filter: brightness(100) hue-rotate(270deg); }
            100% { transform: scale(0); opacity: 0; filter: brightness(0) hue-rotate(360deg); }
        }
        
        /* Animation result display */
        .animation-result {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px 60px;
            border-radius: 20px;
            border: 4px solid var(--accent-primary);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
            text-align: center;
            animation: resultFadeIn 1s ease-out, resultGlow 2s ease-in-out infinite;
            transition: transform 0.3s ease;
        }
        
        .animation-result:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 0 80px rgba(0, 255, 255, 0.8);
        }
        
        @keyframes resultFadeIn {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        @keyframes resultGlow {
            0%, 100% { box-shadow: 0 0 50px rgba(0, 255, 255, 0.5); }
            50% { box-shadow: 0 0 100px rgba(0, 255, 255, 1), 0 0 150px rgba(255, 0, 255, 0.5); }
        }
        
        .animation-result-title {
            font-size: 2rem;
            margin-bottom: 20px;
            color: var(--accent-gold);
            text-shadow: 0 0 10px var(--accent-gold);
        }
        
        .animation-result-item {
            font-size: 2.5rem;
            font-weight: bold;
            margin: 20px 0;
            text-shadow: 0 0 20px currentColor;
            animation: textPulse 1.5s ease-in-out infinite;
        }
        
        @keyframes textPulse {
            0%, 100% { text-shadow: 0 0 20px currentColor; }
            50% { text-shadow: 0 0 40px currentColor, 0 0 60px currentColor; }
        }
        
        .animation-result-rarity {
            font-size: 1.5rem;
            margin: 15px 0;
        }
        
        .animation-result-chance {
            font-size: 1.3rem;
            color: var(--text-secondary);
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            ‚ö° RNG TRADER ‚ö°
        </header>
        
        <div style="display: flex; justify-content: center; gap: 15px; margin-bottom: 20px;">
            <button class="btn btn-accept" onclick="saveGame()" style="padding: 10px 25px;">üíæ Save Game</button>
            <button class="btn btn-accept" onclick="loadGame()" style="padding: 10px 25px;">üìÇ Load Game</button>
        </div>
        
        <div class="stats-bar">
            <div class="stat-card">
                <div class="stat-label">Money</div>
                <div class="stat-value" id="money">$0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Total Value</div>
                <div class="stat-value" id="totalValue">$0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Spins</div>
                <div class="stat-value" id="totalSpins">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Luck</div>
                <div class="stat-value" id="luckMultiplier">1.0x</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Trade Wins</div>
                <div class="stat-value" id="tradeWins">0</div>
            </div>
        </div>
        
        <div class="tabs">
            <button class="tab-button active" onclick="switchTab('spin')">üé∞ Spin</button>
            <button class="tab-button" onclick="switchTab('inventory')">üéí Inventory</button>
            <button class="tab-button" onclick="switchTab('shop')">üè™ Shop</button>
            <button class="tab-button" onclick="switchTab('upgrades')">‚¨ÜÔ∏è Upgrades</button>
            <button class="tab-button" onclick="switchTab('trading')">ü§ù Trading</button>
            <button class="tab-button" onclick="switchTab('crafting')">üî® Crafting</button>
            <button class="tab-button" onclick="switchTab('enchanting')">‚ú® Enchanting</button>
            <button class="tab-button" onclick="switchTab('achievements')">üèÜ Achievements</button>
            <button class="tab-button" onclick="switchTab('quests')">üìã Quests</button>
            <button class="tab-button" onclick="switchTab('battlepass')">üé´ Battle Pass</button>
            <button class="tab-button" onclick="switchTab('rebirth')">‚ôªÔ∏è Rebirth</button>
            <button class="tab-button" onclick="switchTab('events')">üéÑ Events</button>
            <button class="tab-button" onclick="switchTab('settings')">‚öôÔ∏è Settings</button>
            <button class="tab-button" onclick="switchTab('admin')">üîí Admin</button>
        </div>
        
        <!-- Spin Tab -->
        <div id="spin" class="tab-content active">
            <div class="spin-section">
                <h2 style="margin-bottom: 20px; color: var(--accent-primary);">üé≤ Spin the Wheel of Fortune! üé≤</h2>
                <button class="spin-button" onclick="spinItem()" id="spinBtn">SPIN NOW!</button>
                <div class="result-display" id="resultDisplay">
                    <p style="color: var(--text-secondary);">Click SPIN to get your first item!</p>
                </div>
            </div>
        </div>
        
        <!-- Inventory Tab -->
        <div id="inventory" class="tab-content">
            <h2>Your Inventory</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Click an item to flex it! Right-click to sell it for money.</p>
            <button class="btn btn-decline" onclick="sellAllItems()" style="margin: 10px 0;">üí∞ Sell All Items (70% value)</button>
            <div class="inventory-grid" id="inventoryGrid"></div>
        </div>
        
        <!-- Shop Tab -->
        <div id="shop" class="tab-content">
            <h2>Item Shop</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Buy items with your hard-earned money!</p>
            <div class="inventory-grid" id="shopGrid"></div>
        </div>
        
        <!-- Upgrades Tab -->
        <div id="upgrades" class="tab-content">
            <h2>Upgrades</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Spend money to improve your game permanently!</p>
            <div class="crafting-grid" id="upgradesGrid"></div>
        </div>
        
        <!-- Trading Tab -->
        <div id="trading" class="tab-content">
            <h2>NPC Trading Post</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">NPCs will randomly offer item trades. Values are hidden - trade at your own risk!</p>
            <p style="margin: 10px 0; color: var(--warning);">‚ö†Ô∏è The richer you are, the more NPCs will try to scam you! ‚ö†Ô∏è</p>
            <div id="npcContainer"></div>
        </div>
        
        <!-- Crafting Tab -->
        <div id="crafting" class="tab-content">
            <h2>Crafting Station</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Combine items to create more valuable ones!</p>
            <div class="crafting-grid" id="craftingGrid"></div>
        </div>
        
        <!-- Enchanting Tab -->
        <div id="enchanting" class="tab-content">
            <h2>‚ú® Enchantment Altar ‚ú®</h2>
            <p style="margin: 10px 0; color: var(--warning);">‚ö†Ô∏è Only items Divine rarity or higher can be enchanted!</p>
            <p style="margin: 10px 0; color: var(--text-secondary);">Get random enchantments with powerful effects - or risk losing your item!</p>
            
            <div style="margin: 20px 0;">
                <h3>Select Divine+ Item to Enchant:</h3>
                <div class="inventory-grid" id="enchantInventoryGrid"></div>
            </div>
            
            <div id="enchantmentInterface" style="display: none;">
                <div class="enchant-slots">
                    <div class="enchant-slot filled" id="selectedEnchantItem"></div>
                </div>
                <div style="margin: 20px 0; padding: 15px; background: var(--bg-light); border-radius: 12px;">
                    <h3 style="color: var(--accent-primary); margin-bottom: 10px;">Possible Enchantments:</h3>
                    <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
                        <div style="margin: 5px 0;">üí∞ <strong>Value Upgrade</strong> - Increases item value</div>
                        <div style="margin: 5px 0;">ü§ù <strong>Traders Dream</strong> - NPCs want this item more</div>
                        <div style="margin: 5px 0;">üî® <strong>Crafting Merger</strong> - Chance to duplicate crafts</div>
                        <div style="margin: 5px 0;">‚ú® <strong>Enchanters Tool</strong> - Better enchant chances</div>
                        <div style="margin: 5px 0;">üíµ <strong>Money Multi</strong> - Better sell value</div>
                        <div style="margin: 5px 0;">üé≤ <strong>Lucky Item</strong> - Boosts spin luck</div>
                        <div style="margin: 10px 0; padding-top: 10px; border-top: 2px solid var(--accent-gold);">
                            <strong style="color: var(--accent-gold);">GODLY ENCHANTS:</strong>
                        </div>
                        <div style="margin: 5px 0; color: var(--accent-gold);">üëë <strong>Admins Dreams</strong> - 2x value, 2x luck, trade boost</div>
                        <div style="margin: 5px 0; color: var(--accent-gold);">üé≠ <strong>Emperors Style</strong> - 4x luck, trade boost</div>
                        <div style="margin: 5px 0; color: var(--accent-gold);">üåÄ <strong>Endless Possibilities</strong> - Craft dupe + enchant luck</div>
                        <div style="margin: 5px 0; color: var(--accent-gold);">‚ö° <strong>Chaotics Thoughts</strong> - 2x spins, anti-scammer</div>
                        <div style="margin: 10px 0; padding-top: 10px; border-top: 2px solid #ff00ff;">
                            <strong style="color: #ff00ff;">ULTIMATE:</strong>
                        </div>
                        <div style="margin: 5px 0; color: #ff00ff;">üåü <strong>Ruler of the World</strong> - ALL ENCHANTS COMBINED!</div>
                        <div style="margin: 10px 0; padding-top: 10px; border-top: 2px solid var(--danger);">
                            <strong style="color: var(--danger);">BAD ENCHANTS:</strong>
                        </div>
                        <div style="margin: 5px 0; color: var(--danger);">‚ö†Ô∏è Ditto, Too Much/Little Energy (destroys item)</div>
                    </div>
                </div>
                <button class="btn btn-accept" onclick="enchantItem()" style="width: 100%; padding: 20px; font-size: 1.2rem;">
                    ‚ö° ENCHANT ITEM ‚ö°
                </button>
            </div>
        </div>
        
        <!-- Achievements Tab -->
        <div id="achievements" class="tab-content">
            <h2>Achievements</h2>
            <div class="achievement-list" id="achievementList"></div>
        </div>
        
        <!-- Quests Tab -->
        <div id="quests" class="tab-content">
            <h2>üìã Daily & Weekly Quests</h2>
            <p style="color: var(--text-secondary); margin-bottom: 20px;">Complete quests to earn Battle Pass XP!</p>
            
            <div id="questContainer" style="max-width: 800px; margin: 0 auto;">
                <!-- Quests will be populated here -->
            </div>
        </div>
        
        <!-- Battle Pass Tab -->
        <div id="battlepass" class="tab-content">
            <h2>Battle Pass - Season 1</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="bpProgress" style="width: 0%;">Tier 0/10</div>
            </div>
            <div id="bpTiers"></div>
        </div>
        
        <!-- Events Tab -->
        <div id="events" class="tab-content">
            <div class="event-banner">
                üéÑ CHRISTMAS EVENT üéÖ
            </div>
            <p style="margin: 20px 0;">The Christmas event happens automatically every hour (at XX:00) and lasts for 5 minutes! During this time, you have a 15% chance to spin special holiday items!</p>
            <div style="margin-top: 30px;">
                <h3>Active Bonuses:</h3>
                <div id="eventBonuses" style="margin-top: 15px;"></div>
            </div>
        </div>
        
        <!-- Rebirth Tab -->
        <div id="rebirth" class="tab-content">
            <h2>‚ôªÔ∏è Rebirth System</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Rebirth to gain permanent bonuses, but lose all progress!</p>
            
            <div class="stat-card" style="margin: 20px 0;">
                <div class="stat-label">Total Rebirths</div>
                <div class="stat-value" style="color: var(--accent-primary);" id="rebirthCount">0</div>
            </div>
            
            <div class="stat-card" style="margin: 20px 0;">
                <div class="stat-label">Permanent Luck Boost</div>
                <div class="stat-value" style="color: var(--accent-gold);" id="permanentLuck">1.0x</div>
                <p style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 10px;">Each rebirth adds +2x permanent luck</p>
            </div>
            
            <div class="npc-container" style="margin-top: 30px;">
                <h3 style="color: var(--accent-primary); margin-bottom: 15px;">Rebirth Requirements:</h3>
                <div id="rebirthRequirements" style="background: var(--bg-light); padding: 20px; border-radius: 12px; border: 2px solid var(--accent-secondary);">
                    <p style="color: var(--accent-gold);">Next Rebirth Requirements:</p>
                    <p style="color: var(--text-secondary);">üí∞ Money: $1,000,000</p>
                    <p style="color: var(--rarity-mythic);">‚ú® Item: Mythic+ rarity</p>
                    <p style="color: var(--success);">üéÅ Reward: +2.0x permanent luck</p>
                </div>
                <div style="margin: 20px 0; padding: 15px; background: var(--bg-medium); border-radius: 8px; border-left: 4px solid var(--danger);">
                    <p style="color: var(--danger); font-weight: bold; margin-bottom: 10px;">‚ö†Ô∏è WARNING ‚ö†Ô∏è</p>
                    <p style="color: var(--text-secondary); font-size: 0.9rem;">Rebirthing will reset:</p>
                    <ul style="color: var(--text-secondary); font-size: 0.9rem; margin: 10px 0 10px 20px;">
                        <li>All items in inventory</li>
                        <li>All money</li>
                        <li>All upgrades</li>
                        <li>Battle Pass progress</li>
                        <li>Total spins counter</li>
                    </ul>
                    <p style="color: var(--success); font-size: 0.9rem; margin-top: 10px;">‚úì You keep: Achievements, Rebirths, Permanent Luck, Quest Stats</p>
                </div>
                    <button class="btn btn-decline" onclick="performRebirth()" style="width: 100%; padding: 15px; font-size: 1.1rem;">
                        ‚ôªÔ∏è REBIRTH NOW ‚ôªÔ∏è
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Settings Tab -->
        <div id="settings" class="tab-content">
            <h2>‚öôÔ∏è Settings</h2>
            <p style="margin: 10px 0; color: var(--text-secondary);">Customize your gameplay experience</p>
            
            <div class="crafting-grid" style="margin-top: 20px;">
                <div class="recipe-card">
                    <h3 style="color: var(--accent-primary);">Notifications</h3>
                    <div style="margin: 15px 0;">
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingTradeNotif" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Trade Notifications</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingExpiredNotif" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Expired Trade Notifications</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingSpinNotif" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Spin Result Notifications</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingAchievementNotif" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Achievement Notifications</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingEventNotif" onchange="updateSettings()" checked style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Random Event Notifications</span>
                        </label>
                        <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                            <input type="checkbox" id="settingAutoSaveNotif" onchange="updateSettings()" style="width: 20px; height: 20px; margin-right: 10px;">
                            <span>Show Auto-Save Notifications</span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Admin Panel -->
        <div id="admin" class="tab-content">
            <div id="adminLogin" style="display: block;">
                <h2>üîí Admin Panel - Login Required</h2>
                <p style="margin: 20px 0; color: var(--text-secondary);">Enter the admin password to access cheat commands</p>
                <div style="max-width: 400px; margin: 0 auto;">
                    <input type="password" id="adminPasswordInput" placeholder="Enter password..." 
                           style="width: 100%; padding: 15px; margin: 20px 0; background: var(--bg-medium); color: var(--text-primary); border: 2px solid var(--accent-primary); border-radius: 8px; font-size: 1rem;">
                    <button class="btn btn-accept" onclick="unlockAdmin()" style="width: 100%;">Unlock Admin Panel</button>
                </div>
            </div>
            
            <div id="adminPanel" style="display: none;">
                <h2>‚öôÔ∏è Admin Panel</h2>
                <p style="margin: 10px 0; color: var(--warning);">‚ö†Ô∏è Warning: These are cheat commands for testing purposes!</p>
                
                <div class="crafting-grid" style="margin-top: 20px;">
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Money Cheats</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminAddMoney(1000)">+$1,000</button>
                            <button class="btn btn-accept" onclick="adminAddMoney(10000)" style="margin-top: 10px;">+$10,000</button>
                            <button class="btn btn-accept" onclick="adminAddMoney(100000)" style="margin-top: 10px;">+$100,000</button>
                            <button class="btn btn-accept" onclick="adminAddMoney(1000000)" style="margin-top: 10px;">+$1,000,000</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Item Spawner</h3>
                        <div style="margin: 15px 0;">
                            <select id="adminRaritySelect" style="width: 100%; padding: 10px; margin-bottom: 10px; background: var(--bg-medium); color: var(--text-primary); border: 2px solid var(--accent-primary); border-radius: 8px; max-height: 200px; overflow-y: auto;">
                                <option value="0">Common</option>
                                <option value="1">Uncommon</option>
                                <option value="2">Rare</option>
                                <option value="3">Epic</option>
                                <option value="4">Legendary</option>
                                <option value="5">Mythic</option>
                                <option value="6">Exotic</option>
                                <option value="7">Celestial</option>
                                <option value="8">Divine</option>
                                <option value="9">Cosmic</option>
                                <option value="10">Infinite</option>
                                <option value="11">Transcendent</option>
                                <option value="12">Ethereal</option>
                                <option value="13">Primordial</option>
                                <option value="14">Omega</option>
                                <option value="15">Supreme</option>
                                <option value="16">Godlike</option>
                                <option value="17">Universal</option>
                                <option value="18">Multiversal</option>
                                <option value="19">Omnipotent</option>
                                <option value="20">Infinite Absolute</option>
                                <option value="21">Eternal</option>
                                <option value="22">Immortal</option>
                                <option value="23">Ascended</option>
                                <option value="24">Transcendental</option>
                                <option value="25">Boundless</option>
                                <option value="26">Limitless</option>
                                <option value="27">Absolute</option>
                                <option value="28">Beyond</option>
                                <option value="29">Incomprehensible</option>
                                <option value="30">Unimaginable</option>
                                <option value="31">Impossible</option>
                                <option value="32">Paradox</option>
                                <option value="33">Singularity</option>
                                <option value="34">Void</option>
                                <option value="35">Nothingness</option>
                                <option value="36">Everything</option>
                                <option value="37">The End</option>
                                <option value="38">The Beginning</option>
                                <option value="39">Alpha Omega</option>
                                <option value="40">True Infinity</option>
                                <option value="41">The One</option>
                                <option value="42">Primeval</option>
                                <option value="43">Celestial Prime</option>
                                <option value="44">Quantum</option>
                                <option value="45">Dimensional</option>
                                <option value="46">Hyperversal</option>
                                <option value="47">Outerversal</option>
                                <option value="48">Boundaryless</option>
                                <option value="49">Formless</option>
                                <option value="50">Abstract</option>
                                <option value="51">Conceptual</option>
                                <option value="52">Metaphysical</option>
                                <option value="53">The Source</option>
                                <option value="54">The Eternal</option>
                                <option value="55">The Absolute Infinity</option>
                                <option value="56">Beyond Infinity</option>
                            </select>
                            <input type="number" id="adminItemCount" placeholder="Amount (1-100)" min="1" max="100" value="1" style="width: 100%; padding: 10px; margin-bottom: 10px; background: var(--bg-medium); color: var(--text-primary); border: 2px solid var(--accent-primary); border-radius: 8px;">
                            <button class="btn btn-accept" onclick="adminSpawnItem()">Spawn Item(s)</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Luck Manipulation</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminSetLuck(2)">Set Luck 2x</button>
                            <button class="btn btn-accept" onclick="adminSetLuck(5)" style="margin-top: 10px;">Set Luck 5x</button>
                            <button class="btn btn-accept" onclick="adminSetLuck(10)" style="margin-top: 10px;">Set Luck 10x</button>
                            <button class="btn btn-accept" onclick="adminSetLuck(100)" style="margin-top: 10px;">Set Luck 100x</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Max Upgrades</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminMaxUpgrades()">Max All Upgrades</button>
                            <p style="color: var(--text-secondary); margin-top: 10px; font-size: 0.9rem;">Sets all upgrades to max level</p>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Battle Pass</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminAddBPXP(1000)">+1,000 XP</button>
                            <button class="btn btn-accept" onclick="adminAddBPXP(10000)" style="margin-top: 10px;">+10,000 XP</button>
                            <button class="btn btn-accept" onclick="adminMaxBP()" style="margin-top: 10px;">Max Battle Pass</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Events</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminToggleChristmas()">Toggle Christmas Event</button>
                            <button class="btn btn-accept" onclick="adminSpawnTrade()" style="margin-top: 10px;">Spawn Trade Now</button>
                            <button class="btn btn-accept" onclick="adminStartWeatherEvent('cloudy')" style="margin-top: 10px;">Start Cloudy Event</button>
                            <button class="btn btn-accept" onclick="adminStartWeatherEvent('rainy')" style="margin-top: 10px;">Start Rainy Event</button>
                            <button class="btn btn-accept" onclick="adminStartWeatherEvent('storming')" style="margin-top: 10px;">Start Storming Event</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Inventory</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-decline" onclick="adminClearInventory()">Clear Inventory</button>
                            <button class="btn btn-accept" onclick="adminDuplicateInventory()" style="margin-top: 10px;">Duplicate Inventory</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Achievements</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminUnlockAllAchievements()">Unlock All Achievements</button>
                            <button class="btn btn-decline" onclick="adminResetAchievements()" style="margin-top: 10px;">Reset Achievements</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Stats Manipulation</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminSetSpins(10000)">Set 10k Spins</button>
                            <button class="btn btn-accept" onclick="adminAddRebirths(1)" style="margin-top: 10px;">+1 Rebirth</button>
                            <button class="btn btn-accept" onclick="adminSetTradeWins(1000)" style="margin-top: 10px;">Set 1k Trade Wins</button>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--accent-primary);">Quick Actions</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-accept" onclick="adminCompleteEverything()">Complete Everything</button>
                            <p style="color: var(--text-secondary); margin-top: 10px; font-size: 0.9rem;">Max upgrades, BP, money, achievements</p>
                        </div>
                    </div>
                    
                    <div class="recipe-card">
                        <h3 style="color: var(--danger);">Danger Zone</h3>
                        <div style="margin: 15px 0;">
                            <button class="btn btn-decline" onclick="adminResetGame()">Reset Everything</button>
                            <p style="color: var(--text-secondary); margin-top: 10px; font-size: 0.9rem;">‚ö†Ô∏è This will delete all progress!</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Game State
        const gameState = {
            inventory: {},
            totalValue: 0,
            money: 0,
            totalSpins: 0,
            luckMultiplier: 1.0,
            tradeWins: 0,
            tradeLosses: 0,
            flexedItem: null,
            christmasEvent: false,
            christmasEventEnd: null,
            battlePassTier: 0,
            battlePassXP: 0,
            achievements: {},
            enchantmentTarget: null,
            activeTrades: [],
            tradeTimer: null,
            upgrades: {
                spinSpeed: 0,
                popularity: 0,
                luckBoost: 0,
                autoSpin: 0,
                tradeInsight: 0,
                valueBoost: 0,
                craftingMastery: 0,
                enchantPower: 0,
                multiSpin: 0,
                shopDiscount: 0,
                rarityBoost: 0,
                eventLuck: 0,
                xpBoost: 0,
                sellPrice: 0,
                questSpeed: 0,
                mysteryBox: 0
            },
            adminUnlocked: false,
            rebirths: 0,
            permanentLuckBoost: 1.0,
            weatherEvent: null, // 'cloudy', 'rainy', 'storming', or null
            weatherEventEnd: null,
            lastWeatherEvent: 0,
            specialEvent: null, // 'disco', 'galactic', 'glitch', 'fullmoon', 'bloodmoon', or null
            specialEventEnd: null,
            questsCompleted: 0,
            dailyStreak: 0,
            weeklyQuestsCompleted: 0,
            shopPurchases: 0,
            activeQuests: [],
            completedQuests: [],
            lastQuestRefresh: 0,
            settings: {
                showTradeNotifications: true,
                showExpiredNotifications: true,
                showSpinResults: true,
                showAchievementNotifications: true,
                showRandomEvents: true,
                showAutoSaveNotifications: false
            }
        };
        
        const ADMIN_PASSWORD = "admin123"; // Change this to your desired password
        
        // Upgrade costs and effects
        const upgradeData = {
            spinSpeed: {
                name: 'Spin Speed',
                description: 'Reduce spin cooldown time',
                maxLevel: 25,
                baseCost: 50,
                costMultiplier: 2.5,
                effect: (level) => `${level * 10}% faster spins`
            },
            popularity: {
                name: 'Popularity',
                description: 'Increase trade frequency',
                maxLevel: 25,
                baseCost: 100,
                costMultiplier: 3,
                effect: (level) => `${level * 15}% more trades`
            },
            luckBoost: {
                name: 'Luck Boost',
                description: 'Permanently increase luck multiplier',
                maxLevel: 50,
                baseCost: 200,
                costMultiplier: 2,
                effect: (level) => `+${(level * 0.1).toFixed(1)}x luck`
            },
            autoSpin: {
                name: 'Auto Spin',
                description: 'Automatically spin every few seconds',
                maxLevel: 15,
                baseCost: 5000,
                costMultiplier: 5,
                effect: (level) => level > 0 ? `Auto-spin every ${Math.max(10 - level, 2)}s` : 'Not unlocked'
            },
            tradeInsight: {
                name: 'Trade Insight',
                description: 'See if trades are good or bad',
                maxLevel: 3,
                baseCost: 100000,
                costMultiplier: 20,
                effect: (level) => level === 0 ? 'Not unlocked' : level === 1 ? 'See trade quality' : level === 2 ? 'See exact difference' : 'See both item values'
            },
            valueBoost: {
                name: 'Value Boost',
                description: 'Increase value of all items you get',
                maxLevel: 50,
                baseCost: 1000,
                costMultiplier: 3,
                effect: (level) => `+${level * 5}% item value`
            },
            craftingMastery: {
                name: 'Crafting Mastery',
                description: 'Reduce crafting costs and increase output',
                maxLevel: 40,
                baseCost: 5000,
                costMultiplier: 4,
                effect: (level) => `${level * 5}% cheaper crafts, ${level * 2}% better results`
            },
            enchantPower: {
                name: 'Enchant Power',
                description: 'Increase chances of getting good enchantments',
                maxLevel: 50,
                baseCost: 10000,
                costMultiplier: 5,
                effect: (level) => `+${level * 10}% better enchant rolls`
            },
            multiSpin: {
                name: 'Multi Spin',
                description: 'Chance to spin multiple times at once',
                maxLevel: 20,
                baseCost: 50000,
                costMultiplier: 6,
                effect: (level) => `${level * 5}% chance for double spin`
            },
            shopDiscount: {
                name: 'Shop Discount',
                description: 'Reduce shop prices',
                maxLevel: 30,
                baseCost: 25000,
                costMultiplier: 4,
                effect: (level) => `${level * 3}% cheaper shop items`
            },
            rarityBoost: {
                name: 'Rarity Boost',
                description: 'Slightly increase chances for rarer items',
                maxLevel: 25,
                baseCost: 100000,
                costMultiplier: 8,
                effect: (level) => `${(level * 2).toFixed(1)}% better rarity rolls`
            },
            eventLuck: {
                name: 'Event Luck',
                description: 'Increase chance to get event items during events',
                maxLevel: 20,
                baseCost: 75000,
                costMultiplier: 5,
                effect: (level) => `+${level * 5}% event item chance`
            },
            xpBoost: {
                name: 'XP Boost',
                description: 'Gain more Battle Pass XP from all activities',
                maxLevel: 30,
                baseCost: 50000,
                costMultiplier: 4,
                effect: (level) => `+${level * 10}% XP gain`
            },
            sellPrice: {
                name: 'Sell Price',
                description: 'Get more money when selling items',
                maxLevel: 40,
                baseCost: 30000,
                costMultiplier: 4,
                effect: (level) => `+${level * 2}% sell price`
            },
            questSpeed: {
                name: 'Quest Master',
                description: 'Quests give more XP and progress faster',
                maxLevel: 25,
                baseCost: 60000,
                costMultiplier: 5,
                effect: (level) => `+${level * 5}% quest XP rewards`
            },
            mysteryBox: {
                name: 'Mystery Box',
                description: 'Small chance to get a random bonus item when spinning',
                maxLevel: 15,
                baseCost: 150000,
                costMultiplier: 7,
                effect: (level) => `${level * 2}% chance for bonus item`
            }
        };
        
        // Item Rarities with 1 in 2^n progression
        const rarities = [
            { name: 'Common', chance: 1/2, color: 'var(--rarity-common)', minValue: 1, maxValue: 5 },
            { name: 'Uncommon', chance: 1/4, color: 'var(--rarity-uncommon)', minValue: 6, maxValue: 15 },
            { name: 'Rare', chance: 1/8, color: 'var(--rarity-rare)', minValue: 16, maxValue: 40 },
            { name: 'Epic', chance: 1/16, color: 'var(--rarity-epic)', minValue: 41, maxValue: 100 },
            { name: 'Legendary', chance: 1/32, color: 'var(--rarity-legendary)', minValue: 101, maxValue: 250 },
            { name: 'Mythic', chance: 1/64, color: 'var(--rarity-mythic)', minValue: 251, maxValue: 650 },
            { name: 'Exotic', chance: 1/128, color: 'var(--rarity-exotic)', minValue: 651, maxValue: 1500 },
            { name: 'Celestial', chance: 1/256, color: 'var(--rarity-celestial)', minValue: 1501, maxValue: 4000 },
            { name: 'Divine', chance: 1/512, color: '#ffd700', minValue: 4001, maxValue: 10000 },
            { name: 'Cosmic', chance: 1/1024, color: '#ff69b4', minValue: 10001, maxValue: 25000 },
            { name: 'Infinite', chance: 1/2048, color: '#ffffff', minValue: 25001, maxValue: 65000 },
            { name: 'Transcendent', chance: 1/4096, color: '#00fff2', minValue: 65001, maxValue: 150000 },
            { name: 'Ethereal', chance: 1/8192, color: '#b19cd9', minValue: 150001, maxValue: 350000 },
            { name: 'Primordial', chance: 1/16384, color: '#ff6b35', minValue: 350001, maxValue: 800000 },
            { name: 'Omega', chance: 1/32768, color: '#4ecdc4', minValue: 800001, maxValue: 2000000 },
            { name: 'Supreme', chance: 1/65536, color: '#ffe66d', minValue: 2000001, maxValue: 5000000 },
            { name: 'Godlike', chance: 1/131072, color: '#ff00ff', minValue: 5000001, maxValue: 12000000 },
            { name: 'Universal', chance: 1/262144, color: '#00ffaa', minValue: 12000001, maxValue: 30000000 },
            { name: 'Multiversal', chance: 1/524288, color: '#ff3399', minValue: 30000001, maxValue: 75000000 },
            { name: 'Omnipotent', chance: 1/1048576, color: '#ffcc00', minValue: 75000001, maxValue: 200000000 },
            { name: 'Infinite Absolute', chance: 1/2097152, color: '#ff99ff', minValue: 200000001, maxValue: 500000000 },
            { name: 'Eternal', chance: 1/4194304, color: '#66ffff', minValue: 500000001, maxValue: 1000000000 },
            { name: 'Immortal', chance: 1/8388608, color: '#ffff66', minValue: 1000000001, maxValue: 2500000000 },
            { name: 'Ascended', chance: 1/16777216, color: '#ff6666', minValue: 2500000001, maxValue: 5000000000 },
            { name: 'Transcendental', chance: 1/33554432, color: '#66ff66', minValue: 5000000001, maxValue: 10000000000 },
            { name: 'Boundless', chance: 1/67108864, color: '#6666ff', minValue: 10000000001, maxValue: 25000000000 },
            { name: 'Limitless', chance: 1/134217728, color: '#ff66ff', minValue: 25000000001, maxValue: 50000000000 },
            { name: 'Absolute', chance: 1/268435456, color: '#ffffff', minValue: 50000000001, maxValue: 100000000000 },
            { name: 'Beyond', chance: 1/536870912, color: '#ffaa00', minValue: 100000000001, maxValue: 250000000000 },
            { name: 'Incomprehensible', chance: 1/1073741824, color: '#aa00ff', minValue: 250000000001, maxValue: 500000000000 },
            { name: 'Unimaginable', chance: 1/2147483648, color: '#00aaff', minValue: 500000000001, maxValue: 1000000000000 },
            { name: 'Impossible', chance: 1/4294967296, color: '#ff0066', minValue: 1000000000001, maxValue: 10000000000000 },
            { name: 'Paradox', chance: 1/8589934592, color: '#00ff99', minValue: 10000000000001, maxValue: 50000000000000 },
            { name: 'Singularity', chance: 1/17179869184, color: '#9900ff', minValue: 50000000000001, maxValue: 100000000000000 },
            { name: 'Void', chance: 1/34359738368, color: '#000000', minValue: 100000000000001, maxValue: 500000000000000 },
            { name: 'Nothingness', chance: 1/68719476736, color: '#111111', minValue: 500000000000001, maxValue: 1000000000000000 },
            { name: 'Everything', chance: 1/137438953472, color: '#ffffff', minValue: 1000000000000001, maxValue: 5000000000000000 },
            { name: 'The End', chance: 1/274877906944, color: '#ff0000', minValue: 5000000000000001, maxValue: 10000000000000000 },
            { name: 'The Beginning', chance: 1/549755813888, color: '#00ff00', minValue: 10000000000000001, maxValue: 50000000000000000 },
            { name: 'Alpha Omega', chance: 1/1099511627776, color: '#ffff00', minValue: 50000000000000001, maxValue: 100000000000000000 },
            { name: 'True Infinity', chance: 1/2199023255552, color: '#ff00ff', minValue: 100000000000000001, maxValue: 500000000000000000 },
            { name: 'The One', chance: 1/4398046511104, color: '#ffffff', minValue: 500000000000000001, maxValue: 1000000000000000000 },
            { name: 'Primeval', chance: 1/8796093022208, color: '#8b4513', minValue: 1000000000000000001, maxValue: 5000000000000000000 },
            { name: 'Celestial Prime', chance: 1/17592186044416, color: '#4169e1', minValue: 5000000000000000001, maxValue: 10000000000000000000 },
            { name: 'Quantum', chance: 1/35184372088832, color: '#00ffff', minValue: 10000000000000000001, maxValue: 50000000000000000000 },
            { name: 'Dimensional', chance: 1/70368744177664, color: '#9370db', minValue: 50000000000000000001, maxValue: 100000000000000000000 },
            { name: 'Hyperversal', chance: 1/140737488355328, color: '#ff1493', minValue: 100000000000000000001, maxValue: 500000000000000000000 },
            { name: 'Outerversal', chance: 1/281474976710656, color: '#00ff00', minValue: 500000000000000000001, maxValue: 1000000000000000000000 },
            { name: 'Boundaryless', chance: 1/562949953421312, color: '#ff4500', minValue: 1000000000000000000001, maxValue: 5000000000000000000000 },
            { name: 'Formless', chance: 1/1125899906842624, color: '#a9a9a9', minValue: 5000000000000000000001, maxValue: 10000000000000000000000 },
            { name: 'Abstract', chance: 1/2251799813685248, color: '#dda0dd', minValue: 10000000000000000000001, maxValue: 50000000000000000000000 },
            { name: 'Conceptual', chance: 1/4503599627370496, color: '#7fffd4', minValue: 50000000000000000000001, maxValue: 100000000000000000000000 },
            { name: 'Metaphysical', chance: 1/9007199254740992, color: '#dc143c', minValue: 100000000000000000000001, maxValue: 500000000000000000000000 },
            { name: 'The Source', chance: 1/18014398509481984, color: '#ffd700', minValue: 500000000000000000000001, maxValue: 1000000000000000000000000 },
            { name: 'The Eternal', chance: 1/36028797018963968, color: '#00bfff', minValue: 1000000000000000000000001, maxValue: 5000000000000000000000000 },
            { name: 'The Absolute Infinity', chance: 1/72057594037927936, color: '#ff00ff', minValue: 5000000000000000000000001, maxValue: 10000000000000000000000000 },
            { name: 'Beyond Infinity', chance: 1/1000000000000000000000, color: '#ffffff', minValue: 10000000000000000000000001, maxValue: 100000000000000000000000000 }
        ];
        
        // Item name pools by rarity
        const itemNames = {
            'Common': {
                prefixes: ['Rusty', 'Broken', 'Dirty', 'Smelly', 'Bent', 'Cracked', 'Dull', 'Worn', 'Tattered', 'Moldy'],
                items: ['Stick', 'Rock', 'Pebble', 'Twig', 'Leaf', 'Dirt Clump', 'Old Shoe', 'Trash', 'Junk', 'Scrap']
            },
            'Uncommon': {
                prefixes: ['Basic', 'Simple', 'Plain', 'Ordinary', 'Standard', 'Regular', 'Common', 'Typical', 'Normal', 'Average'],
                items: ['Sword', 'Dagger', 'Shield', 'Helmet', 'Boots', 'Gloves', 'Ring', 'Necklace', 'Potion', 'Scroll']
            },
            'Rare': {
                prefixes: ['Polished', 'Sharp', 'Sturdy', 'Fine', 'Quality', 'Steel', 'Iron', 'Silver', 'Reinforced', 'Crafted'],
                items: ['Blade', 'Axe', 'Mace', 'Armor', 'Gauntlets', 'Amulet', 'Gem', 'Tome', 'Elixir', 'Pendant']
            },
            'Epic': {
                prefixes: ['Enchanted', 'Mystic', 'Magical', 'Powerful', 'Superior', 'Enhanced', 'Arcane', 'Blessed', 'Forged', 'Master'],
                items: ['Sword', 'Staff', 'Bow', 'Shield', 'Crown', 'Scepter', 'Orb', 'Crystal', 'Artifact', 'Relic']
            },
            'Legendary': {
                prefixes: ['Ancient', 'Legendary', 'Mythical', 'Blazing', 'Frozen', 'Thunder', 'Shadow', 'Light', 'Dragon', 'Phoenix'],
                items: ['Blade', 'Staff', 'Shield', 'Crown', 'Amulet', 'Ring', 'Orb', 'Gem', 'Rune', 'Sigil']
            },
            'Mythic': {
                prefixes: ['Divine', 'Godly', 'Celestial', 'Ethereal', 'Cosmic', 'Primordial', 'Eternal', 'Immortal', 'Supreme', 'Ultimate'],
                items: ['Sword', 'Staff', 'Crown', 'Throne', 'Scepter', 'Eye', 'Heart', 'Soul', 'Essence', 'Core']
            },
            'Exotic': {
                prefixes: ['Transcendent', 'Omnipotent', 'Infinite', 'Void', 'Astral', 'Quantum', 'Temporal', 'Reality', 'Dimensional', 'Universal'],
                items: ['Weapon', 'Armor', 'Crown', 'Throne', 'Gate', 'Key', 'Fragment', 'Shard', 'Crystal', 'Nexus']
            },
            'Celestial': {
                prefixes: ['Galaxy', 'Nebula', 'Stellar', 'Solar', 'Lunar', 'Supernova', 'Constellation', 'Comet', 'Meteor', 'Aurora'],
                items: ['Crown', 'Throne', 'Scepter', 'Orb', 'Ring', 'Blade', 'Shield', 'Aegis', 'Mantle', 'Regalia']
            },
            'Divine': {
                prefixes: ['Omni', 'Absolute', 'Perfect', 'Sacred', 'Holy', 'Sanctified', 'Consecrated', 'Hallowed', 'Blessed', 'Exalted'],
                items: ['Godhead', 'Divinity', 'Supremacy', 'Sovereignty', 'Dominion', 'Authority', 'Power', 'Glory', 'Majesty', 'Radiance']
            },
            'Cosmic': {
                prefixes: ['Multiverse', 'Omniverse', 'Hyperspace', 'Singularity', 'Infinity', 'Eternity', 'Genesis', 'Apocalypse', 'Alpha', 'Omega'],
                items: ['Construct', 'Entity', 'Phenomenon', 'Anomaly', 'Paradox', 'Singularity', 'Convergence', 'Divergence', 'Matrix', 'Nexus']
            },
            'Infinite': {
                prefixes: ['Boundless', 'Limitless', 'Endless', 'Timeless', 'Formless', 'Nameless', 'Unknowable', 'Incomprehensible', 'Ineffable', 'Absolute'],
                items: ['Existence', 'Concept', 'Idea', 'Dream', 'Truth', 'Reality', 'Universe', 'Everything', 'Nothing', 'All']
            },
            'Transcendent': {
                prefixes: ['Beyond', 'Meta', 'Hyper', 'Ultra', 'Supra', 'Trans', 'Extra', 'Over', 'Super', 'Mega'],
                items: ['Dimension', 'Plane', 'Realm', 'Sphere', 'Domain', 'Territory', 'Space', 'Void', 'Chaos', 'Order']
            },
            'Ethereal': {
                prefixes: ['Spectral', 'Phantom', 'Ghost', 'Spirit', 'Wraith', 'Shade', 'Apparition', 'Vision', 'Mirage', 'Illusion'],
                items: ['Essence', 'Soul', 'Being', 'Entity', 'Presence', 'Force', 'Energy', 'Power', 'Aura', 'Manifestation']
            },
            'Primordial': {
                prefixes: ['Primal', 'Original', 'First', 'Ancient', 'Elder', 'Prehistoric', 'Antediluvian', 'Archaic', 'Primeval', 'Primitive'],
                items: ['Chaos', 'Void', 'Creation', 'Beginning', 'Origin', 'Genesis', 'Source', 'Root', 'Foundation', 'Basis']
            },
            'Omega': {
                prefixes: ['Final', 'Last', 'Ultimate', 'Terminal', 'Conclusive', 'Ending', 'Closing', 'Finishing', 'Concluding', 'Completing'],
                items: ['Judgement', 'Verdict', 'Decree', 'Sentence', 'Destiny', 'Fate', 'End', 'Finale', 'Conclusion', 'Termination']
            },
            'Supreme': {
                prefixes: ['Paramount', 'Preeminent', 'Dominant', 'Sovereign', 'Imperial', 'Regal', 'Royal', 'Majestic', 'Grand', 'Noble'],
                items: ['Authority', 'Command', 'Control', 'Rule', 'Reign', 'Empire', 'Kingdom', 'Dynasty', 'Legacy', 'Heritage']
            },
            'Godlike': {
                prefixes: ['Deific', 'Theistic', 'Apotheosis', 'Ascended', 'Transcended', 'Enlightened', 'Awakened', 'Elevated', 'Exalted', 'Glorified'],
                items: ['Godhood', 'Divinity', 'Deity', 'Immortal', 'Eternal', 'Infinite', 'Perfect', 'Flawless', 'Pure', 'Holy']
            },
            'Universal': {
                prefixes: ['Cosmic', 'Galactic', 'Stellar', 'Planetary', 'Astronomical', 'Celestial', 'Heavenly', 'Astral', 'Spatial', 'Interstellar'],
                items: ['Cosmos', 'Universe', 'Galaxy', 'Nebula', 'Supernova', 'Quasar', 'Pulsar', 'Black Hole', 'Wormhole', 'Singularity']
            },
            'Multiversal': {
                prefixes: ['Parallel', 'Alternate', 'Divergent', 'Branching', 'Split', 'Multiple', 'Infinite', 'Countless', 'Endless', 'Limitless'],
                items: ['Timeline', 'Reality', 'Dimension', 'Universe', 'World', 'Existence', 'Possibility', 'Probability', 'Outcome', 'Future']
            },
            'Omnipotent': {
                prefixes: ['All-Powerful', 'Almighty', 'Supreme', 'Unlimited', 'Unbound', 'Unrestricted', 'Unconstrained', 'Absolute', 'Total', 'Complete'],
                items: ['Power', 'Might', 'Strength', 'Force', 'Energy', 'Potential', 'Capability', 'Capacity', 'Ability', 'Faculty']
            },
            'Absolute': {
                prefixes: ['Pure', 'True', 'Real', 'Genuine', 'Authentic', 'Perfect', 'Ideal', 'Ultimate', 'Final', 'Complete'],
                items: ['Zero', 'One', 'Everything', 'Nothing', 'All', 'None', 'Beginning', 'End', 'Alpha', 'Omega']
            },
            'Beyond': {
                prefixes: ['Post', 'After', 'Outside', 'Past', 'Exceeding', 'Surpassing', 'Transcending', 'Outstripping', 'Eclipsing', 'Outdoing'],
                items: ['Comprehension', 'Understanding', 'Logic', 'Reason', 'Thought', 'Concept', 'Idea', 'Perception', 'Cognition', 'Awareness']
            },
            'Incomprehensible': {
                prefixes: ['Unfathomable', 'Inexplicable', 'Inscrutable', 'Impenetrable', 'Mysterious', 'Cryptic', 'Enigmatic', 'Arcane', 'Esoteric', 'Obscure'],
                items: ['Mystery', 'Enigma', 'Riddle', 'Puzzle', 'Secret', 'Unknown', 'Hidden', 'Veiled', 'Shrouded', 'Occult']
            },
            'Unimaginable': {
                prefixes: ['Inconceivable', 'Unthinkable', 'Incredible', 'Fantastic', 'Miraculous', 'Supernatural', 'Otherworldly', 'Unearthly', 'Preternatural', 'Paranormal'],
                items: ['Wonder', 'Marvel', 'Miracle', 'Phenomenon', 'Spectacle', 'Vision', 'Apparition', 'Manifestation', 'Revelation', 'Epiphany']
            },
            'Impossible': {
                prefixes: ['Never', 'Cannot', 'Non', 'Un', 'Anti', 'Contra', 'Counter', 'Opposite', 'Reverse', 'Inverse'],
                items: ['Existence', 'Reality', 'Truth', 'Fact', 'Actuality', 'Certainty', 'Inevitability', 'Necessity', 'Destiny', 'Fate']
            },
            'Infinite Absolute': {
                prefixes: ['Endless', 'Eternal', 'Perpetual', 'Everlasting', 'Immortal', 'Undying', 'Deathless', 'Ageless', 'Timeless', 'Permanent'],
                items: ['Perfection', 'Flawlessness', 'Excellence', 'Superiority', 'Supremacy', 'Preeminence', 'Dominance', 'Ascendancy', 'Sovereignty', 'Mastery']
            },
            'Eternal': {
                prefixes: ['Forever', 'Always', 'Constantly', 'Continuously', 'Ceaselessly', 'Perpetually', 'Endlessly', 'Infinitely', 'Boundlessly', 'Limitlessly'],
                items: ['Moment', 'Instant', 'Second', 'Eternity', 'Infinity', 'Forever', 'Always', 'Evermore', 'Perpetuity', 'Timelessness']
            },
            'Immortal': {
                prefixes: ['Undead', 'Undying', 'Deathless', 'Imperishable', 'Indestructible', 'Invincible', 'Unconquerable', 'Invulnerable', 'Impregnable', 'Unassailable'],
                items: ['Life', 'Soul', 'Spirit', 'Essence', 'Being', 'Entity', 'Creature', 'Organism', 'Individual', 'Person']
            },
            'Ascended': {
                prefixes: ['Risen', 'Elevated', 'Uplifted', 'Exalted', 'Glorified', 'Ennobled', 'Dignified', 'Honored', 'Revered', 'Venerated'],
                items: ['Master', 'Lord', 'King', 'Emperor', 'Ruler', 'Sovereign', 'Monarch', 'Potentate', 'Overlord', 'Supreme']
            },
            'Transcendental': {
                prefixes: ['Sublime', 'Magnificent', 'Majestic', 'Grand', 'Glorious', 'Splendid', 'Resplendent', 'Radiant', 'Brilliant', 'Luminous'],
                items: ['Beauty', 'Grace', 'Elegance', 'Refinement', 'Sophistication', 'Poise', 'Dignity', 'Nobility', 'Majesty', 'Grandeur']
            },
            'Boundless': {
                prefixes: ['Infinite', 'Unlimited', 'Unrestricted', 'Unconfined', 'Unbounded', 'Unconstrained', 'Unfettered', 'Unhampered', 'Unhindered', 'Unimpeded'],
                items: ['Freedom', 'Liberty', 'Independence', 'Autonomy', 'Sovereignty', 'Self-rule', 'Self-governance', 'Self-determination', 'Free-will', 'Choice']
            },
            'Limitless': {
                prefixes: ['Measureless', 'Immeasurable', 'Incalculable', 'Innumerable', 'Countless', 'Numberless', 'Untold', 'Infinite', 'Endless', 'Boundless'],
                items: ['Potential', 'Possibility', 'Capability', 'Capacity', 'Power', 'Strength', 'Might', 'Force', 'Energy', 'Vigor']
            },
            'Paradox': {
                prefixes: ['Self-Contradicting', 'Illogical', 'Absurd', 'Contradictory', 'Inconsistent', 'Conflicting', 'Opposing', 'Clashing', 'Incompatible', 'Irreconcilable'],
                items: ['Statement', 'Truth', 'Lie', 'Question', 'Answer', 'Problem', 'Solution', 'Cause', 'Effect', 'Loop']
            },
            'Singularity': {
                prefixes: ['Unique', 'One', 'Sole', 'Single', 'Only', 'Lone', 'Solitary', 'Individual', 'Distinct', 'Separate'],
                items: ['Point', 'Moment', 'Event', 'Instance', 'Occurrence', 'Happening', 'Phenomenon', 'Incident', 'Episode', 'Case']
            },
            'Void': {
                prefixes: ['Empty', 'Vacant', 'Hollow', 'Bare', 'Blank', 'Barren', 'Desolate', 'Abandoned', 'Forsaken', 'Deserted'],
                items: ['Space', 'Abyss', 'Chasm', 'Pit', 'Hole', 'Gap', 'Cavity', 'Vacuum', 'Emptiness', 'Nothingness']
            },
            'Nothingness': {
                prefixes: ['Absent', 'Missing', 'Gone', 'Lost', 'Vanished', 'Disappeared', 'Dissolved', 'Evaporated', 'Faded', 'Erased'],
                items: ['Void', 'Nil', 'Naught', 'Zero', 'Cipher', 'Nobody', 'Nothing', 'None', 'Not', 'Never']
            },
            'Everything': {
                prefixes: ['All', 'Total', 'Whole', 'Complete', 'Entire', 'Full', 'Absolute', 'Perfect', 'Pure', 'True'],
                items: ['Universe', 'Cosmos', 'Reality', 'Existence', 'Creation', 'World', 'Life', 'Matter', 'Energy', 'Time']
            },
            'The End': {
                prefixes: ['Final', 'Last', 'Ultimate', 'Terminal', 'Concluding', 'Closing', 'Finishing', 'Ending', 'Culminating', 'Completing'],
                items: ['Moment', 'Second', 'Day', 'Hour', 'Year', 'Age', 'Era', 'Epoch', 'Period', 'Time']
            },
            'The Beginning': {
                prefixes: ['First', 'Initial', 'Original', 'Primary', 'Primal', 'Primeval', 'Primordial', 'Ancient', 'Archaic', 'Antique'],
                items: ['Spark', 'Flame', 'Light', 'Dawn', 'Sunrise', 'Genesis', 'Origin', 'Birth', 'Creation', 'Start']
            },
            'Alpha Omega': {
                prefixes: ['First-Last', 'Beginning-End', 'Start-Finish', 'Alpha-Beta', 'Top-Bottom', 'High-Low', 'Left-Right', 'Up-Down', 'In-Out', 'On-Off'],
                items: ['Duality', 'Unity', 'Pair', 'Duo', 'Couple', 'Twin', 'Double', 'Binary', 'Dichotomy', 'Contrast']
            },
            'True Infinity': {
                prefixes: ['Real', 'Genuine', 'Authentic', 'Actual', 'Veritable', 'Legitimate', 'Bona-fide', 'Honest', 'Pure', 'Absolute'],
                items: ['Endlessness', 'Eternity', 'Perpetuity', 'Everlastingness', 'Timelessness', 'Boundlessness', 'Limitlessness', 'Immensity', 'Vastness', 'Infinity']
            },
            'The One': {
                prefixes: ['Only', 'Sole', 'Single', 'Singular', 'Unique', 'Exclusive', 'Individual', 'Particular', 'Specific', 'Distinct'],
                items: ['God', 'Creator', 'Source', 'Origin', 'Beginning', 'Root', 'Foundation', 'Base', 'Core', 'Heart']
            },
            'Primeval': {
                prefixes: ['Ancient', 'Primal', 'Primordial', 'Original', 'First', 'Proto', 'Archaic', 'Prehistoric', 'Antediluvian', 'Ancestral'],
                items: ['Force', 'Power', 'Energy', 'Essence', 'Spirit', 'Will', 'Consciousness', 'Mind', 'Soul', 'Being']
            },
            'Celestial Prime': {
                prefixes: ['Supreme', 'Ultimate', 'Paramount', 'Preeminent', 'Sovereign', 'Principal', 'Chief', 'Foremost', 'Primary', 'Leading'],
                items: ['Star', 'Galaxy', 'Universe', 'Cosmos', 'Constellation', 'Nebula', 'Supernova', 'Quasar', 'Pulsar', 'Void']
            },
            'Quantum': {
                prefixes: ['Subatomic', 'Particle', 'Wave', 'Probability', 'Superposition', 'Entangled', 'Collapsed', 'Uncertain', 'Discrete', 'Planck'],
                items: ['Field', 'State', 'Foam', 'Fluctuation', 'Leap', 'Tunnel', 'Decoherence', 'Spin', 'Charge', 'String']
            },
            'Dimensional': {
                prefixes: ['Multi', 'Extra', 'Higher', 'Parallel', 'Alternate', 'Perpendicular', 'Orthogonal', 'Spatial', 'Temporal', 'Planar'],
                items: ['Dimension', 'Reality', 'Plane', 'Axis', 'Membrane', 'Brane', 'Manifold', 'Space', 'Continuum', 'Fabric']
            },
            'Hyperversal': {
                prefixes: ['Super', 'Meta', 'Ultra', 'Hyper', 'Trans', 'Beyond', 'Above', 'Transcendent', 'Superior', 'Greater'],
                items: ['Realm', 'Domain', 'Sphere', 'Zone', 'Region', 'Territory', 'Province', 'Kingdom', 'Empire', 'Cosmos']
            },
            'Outerversal': {
                prefixes: ['Outer', 'External', 'Outside', 'Beyond', 'Exterior', 'Peripheral', 'Remote', 'Distant', 'Far', 'Edge'],
                items: ['Boundary', 'Limit', 'Border', 'Frontier', 'Threshold', 'Horizon', 'Edge', 'Rim', 'Periphery', 'Margin']
            },
            'Boundaryless': {
                prefixes: ['Unlimited', 'Infinite', 'Endless', 'Limitless', 'Unbounded', 'Measureless', 'Immeasurable', 'Vast', 'Expansive', 'Infinite'],
                items: ['Expanse', 'Vastness', 'Infinity', 'Eternity', 'Forever', 'Always', 'Never-ending', 'Perpetual', 'Everlasting', 'Timeless']
            },
            'Formless': {
                prefixes: ['Shapeless', 'Amorphous', 'Undefined', 'Vague', 'Nebulous', 'Abstract', 'Intangible', 'Incorporeal', 'Immaterial', 'Ethereal'],
                items: ['Void', 'Emptiness', 'Nothingness', 'Absence', 'Negation', 'Non-being', 'Non-existence', 'Nihility', 'Vacuum', 'Null']
            },
            'Abstract': {
                prefixes: ['Conceptual', 'Theoretical', 'Ideal', 'Pure', 'Platonic', 'Universal', 'General', 'Non-concrete', 'Mental', 'Intellectual'],
                items: ['Concept', 'Idea', 'Notion', 'Thought', 'Theory', 'Principle', 'Law', 'Truth', 'Form', 'Essence']
            },
            'Conceptual': {
                prefixes: ['Fundamental', 'Essential', 'Basic', 'Elementary', 'Primary', 'Core', 'Central', 'Key', 'Crucial', 'Vital'],
                items: ['Framework', 'Structure', 'System', 'Model', 'Pattern', 'Design', 'Scheme', 'Plan', 'Blueprint', 'Template']
            },
            'Metaphysical': {
                prefixes: ['Ontological', 'Existential', 'Phenomenal', 'Noumenal', 'Transcendental', 'A-priori', 'Absolute', 'Necessary', 'Contingent', 'Essential'],
                items: ['Being', 'Existence', 'Reality', 'Actuality', 'Substance', 'Essence', 'Nature', 'Property', 'Quality', 'Attribute']
            },
            'The Source': {
                prefixes: ['Originating', 'Generative', 'Creative', 'Productive', 'Fertile', 'Fruitful', 'Prolific', 'Causative', 'Formative', 'Constitutive'],
                items: ['Wellspring', 'Fountain', 'Spring', 'Origin', 'Genesis', 'Beginning', 'Start', 'Commencement', 'Inception', 'Birth']
            },
            'The Eternal': {
                prefixes: ['Everlasting', 'Immortal', 'Undying', 'Deathless', 'Imperishable', 'Indestructible', 'Permanent', 'Lasting', 'Enduring', 'Perpetual'],
                items: ['Cycle', 'Return', 'Recurrence', 'Repetition', 'Loop', 'Circle', 'Wheel', 'Spiral', 'Helix', 'Vortex']
            },
            'The Absolute Infinity': {
                prefixes: ['Total', 'Complete', 'Whole', 'Entire', 'Full', 'Perfect', 'Pure', 'Sheer', 'Utter', 'Absolute'],
                items: ['Aleph', 'Omega-plus', 'Cardinality', 'Ordinal', 'Transfinite', 'Inaccessible', 'Mahlo', 'Measurable', 'Worldly', 'Ineffable']
            },
            'Beyond Infinity': {
                prefixes: ['Post', 'After', 'Past', 'Over', 'Above', 'Supra', 'Super', 'Hyper', 'Ultra', 'Transcending'],
                items: ['Limit', 'Bound', 'End', 'Terminus', 'Finality', 'Conclusion', 'Completion', 'Culmination', 'Apex', 'Zenith']
            }
        };
        
        // Weather Event Items
        const weatherItems = {
            cloudy: [
                { name: '‚òÅÔ∏è Cloud Fragment', rarity: 'Rare' },
                { name: '‚òÅÔ∏è Misty Essence', rarity: 'Epic' },
                { name: '‚òÅÔ∏è Sky Vapor', rarity: 'Legendary' },
                { name: '‚òÅÔ∏è Cumulus Crown', rarity: 'Mythic' },
                { name: '‚òÅÔ∏è Nimbus Core', rarity: 'Exotic' },
                { name: '‚òÅÔ∏è Stratosphere Soul', rarity: 'Celestial' }
            ],
            rainy: [
                { name: 'üåßÔ∏è Raindrop Crystal', rarity: 'Rare' },
                { name: 'üåßÔ∏è Storm Tear', rarity: 'Epic' },
                { name: 'üåßÔ∏è Aqua Prism', rarity: 'Legendary' },
                { name: 'üåßÔ∏è Deluge Diamond', rarity: 'Mythic' },
                { name: 'üåßÔ∏è Monsoon Heart', rarity: 'Exotic' },
                { name: 'üåßÔ∏è Typhoon Spirit', rarity: 'Celestial' }
            ],
            storming: [
                { name: '‚õàÔ∏è Lightning Shard', rarity: 'Epic' },
                { name: '‚õàÔ∏è Thunder Stone', rarity: 'Legendary' },
                { name: '‚õàÔ∏è Storm Bolt', rarity: 'Mythic' },
                { name: '‚õàÔ∏è Tempest Core', rarity: 'Exotic' },
                { name: '‚õàÔ∏è Hurricane Eye', rarity: 'Celestial' },
                { name: '‚õàÔ∏è Cataclysm Crown', rarity: 'Divine' }
            ]
        };
        
        // Christmas Items
        const christmasItems = [
            { name: 'üéÖ Santa Hat', rarity: 'Legendary' },
            { name: 'üéÑ Christmas Tree', rarity: 'Epic' },
            { name: '‚õÑ Snowman', rarity: 'Rare' },
            { name: 'üéÅ Gift Box', rarity: 'Uncommon' },
            { name: '‚ùÑÔ∏è Snowflake', rarity: 'Common' },
            { name: 'üîî Jingle Bell', rarity: 'Rare' },
            { name: 'ü¶å Reindeer', rarity: 'Mythic' }
        ];
        
        // Disco Event Items (Every hour at :15-:19)
        const discoItems = [
            { name: 'ü™© Disco Ball', rarity: 'Epic' },
            { name: 'üï∫ Groove Shoes', rarity: 'Legendary' },
            { name: 'üíÉ Dance Floor Tile', rarity: 'Rare' },
            { name: 'üéµ Funky Beat', rarity: 'Mythic' },
            { name: '‚ú® Glitter Bomb', rarity: 'Exotic' },
            { name: 'üé∂ Rhythm Soul', rarity: 'Celestial' }
        ];
        
        // Galactic Event Items (Every hour at :30-:34)
        const galacticItems = [
            { name: 'üåå Nebula Fragment', rarity: 'Legendary' },
            { name: '‚≠ê Star Dust', rarity: 'Mythic' },
            { name: 'üå† Comet Tail', rarity: 'Exotic' },
            { name: 'ü™ê Planet Core', rarity: 'Celestial' },
            { name: 'üåü Supernova Spark', rarity: 'Divine' },
            { name: 'üî≠ Galaxy Eye', rarity: 'Cosmic' }
        ];
        
        // Glitch Event Items (Every hour at :45-:49)
        const glitchItems = [
            { name: '‚ö° Error Code', rarity: 'Epic' },
            { name: 'üî≤ Corrupted Pixel', rarity: 'Legendary' },
            { name: 'üìü Digital Anomaly', rarity: 'Mythic' },
            { name: 'üíæ Data Fragment', rarity: 'Exotic' },
            { name: 'üñ•Ô∏è System Break', rarity: 'Celestial' },
            { name: '‚å®Ô∏è Reality Bug', rarity: 'Divine' }
        ];
        
        // Full Moon Event Items (Every 2 hours at :20-:24)
        const fullMoonItems = [
            { name: 'üåï Moonstone', rarity: 'Legendary' },
            { name: 'üê∫ Lunar Howl', rarity: 'Mythic' },
            { name: 'üåô Silver Beam', rarity: 'Exotic' },
            { name: '‚ú® Moon Dust', rarity: 'Celestial' },
            { name: 'üåõ Crescent Blade', rarity: 'Divine' },
            { name: 'üîÆ Lunar Oracle', rarity: 'Cosmic' }
        ];
        
        // Blood Moon Event Items (Every 3 hours at :50-:54)
        const bloodMoonItems = [
            { name: 'üî¥ Crimson Orb', rarity: 'Mythic' },
            { name: 'ü©∏ Blood Crystal', rarity: 'Exotic' },
            { name: 'üåë Eclipse Shard', rarity: 'Celestial' },
            { name: '‚öîÔ∏è Scarlet Blade', rarity: 'Divine' },
            { name: 'üíÄ Cursed Relic', rarity: 'Cosmic' },
            { name: 'üëÅÔ∏è Crimson Eye', rarity: 'Infinite' }
        ];
        
        // NPC Types
        const npcTypes = ['honest', 'fair', 'scammer'];
        const npcNames = ['Bob', 'Alice', 'Charlie', 'Diana', 'Eve', 'Frank', 'Grace', 'Henry', 'Ivy', 'Jack', 
                          'Karma', 'Luna', 'Max', 'Nova', 'Oscar', 'Penny', 'Quinn', 'Ruby', 'Sam', 'Tina'];
        
        // Crafting Recipes
        const recipes = [
            { name: 'Steel Sword', requires: { 'Common': 5 }, result: 'Uncommon', value: 12 },
            { name: 'Magic Staff', requires: { 'Uncommon': 3 }, result: 'Rare', value: 30 },
            { name: 'Dragon Scale', requires: { 'Rare': 4 }, result: 'Epic', value: 80 },
            { name: 'Phoenix Feather', requires: { 'Epic': 3 }, result: 'Legendary', value: 200 },
            { name: 'Void Crystal', requires: { 'Legendary': 2 }, result: 'Mythic', value: 500 },
            { name: 'Stardust Shard', requires: { 'Mythic': 2 }, result: 'Exotic', value: 1200 },
            { name: 'Celestial Fragment', requires: { 'Exotic': 2 }, result: 'Celestial', value: 3000 },
            { name: 'Divine Essence', requires: { 'Celestial': 2 }, result: 'Divine', value: 8000 },
            { name: 'Cosmic Dust', requires: { 'Divine': 2 }, result: 'Cosmic', value: 20000 },
            { name: 'Infinite Loop', requires: { 'Cosmic': 2 }, result: 'Infinite', value: 50000 },
            { name: 'Transcendence Core', requires: { 'Infinite': 2 }, result: 'Transcendent', value: 120000 },
            { name: 'Ethereal Wisp', requires: { 'Transcendent': 2 }, result: 'Ethereal', value: 280000 },
            { name: 'Primordial Spark', requires: { 'Ethereal': 2 }, result: 'Primordial', value: 650000 },
            { name: 'Omega Sigil', requires: { 'Primordial': 2 }, result: 'Omega', value: 1500000 },
            { name: 'Supreme Authority', requires: { 'Omega': 2 }, result: 'Supreme', value: 3800000 },
            { name: 'Godly Pinnacle', requires: { 'Supreme': 2 }, result: 'Godlike', value: 9500000 },
            { name: 'Universal Key', requires: { 'Godlike': 2 }, result: 'Universal', value: 23000000 },
            { name: 'Multiversal Gate', requires: { 'Universal': 2 }, result: 'Multiversal', value: 55000000 },
            { name: 'Omnipotent Crown', requires: { 'Multiversal': 2 }, result: 'Omnipotent', value: 135000000 },
            { name: 'Absolute Perfection', requires: { 'Omnipotent': 3 }, result: 'Absolute', value: 75000000000 },
            { name: 'Beyond Comprehension', requires: { 'Absolute': 2 }, result: 'Beyond', value: 180000000000 },
            { name: 'Incomprehensible Core', requires: { 'Beyond': 2 }, result: 'Incomprehensible', value: 400000000000 },
            { name: 'Unimaginable Essence', requires: { 'Incomprehensible': 2 }, result: 'Unimaginable', value: 800000000000 },
            { name: 'Impossible Artifact', requires: { 'Unimaginable': 3 }, result: 'Impossible', value: 8000000000000 }
        ];
        
        // Achievements
        const achievements = [
            { id: 'first_spin', name: 'First Spin', desc: 'Spin your first item', reward: 'Lucky Charm (+0.1 Luck)', check: () => gameState.totalSpins >= 1 },
            { id: 'spin_master', name: 'Spin Master', desc: 'Spin 100 items', reward: 'Spin Token (+0.2 Luck)', check: () => gameState.totalSpins >= 100 },
            { id: 'spin_legend', name: 'Spin Legend', desc: 'Spin 1,000 items', reward: 'Legendary Spinner (+0.5 Luck)', check: () => gameState.totalSpins >= 1000 },
            { id: 'spin_god', name: 'Spin God', desc: 'Spin 10,000 items', reward: 'Divine Spinner (+1.0 Luck)', check: () => gameState.totalSpins >= 10000 },
            { id: 'spin_master_100k', name: 'Spin Mastery', desc: 'Spin 100,000 items', reward: 'Ultimate Spinner (+2.0 Luck)', check: () => gameState.totalSpins >= 100000 },
            { id: 'millionaire', name: 'Millionaire', desc: 'Reach $1,000,000 total value', reward: 'Golden Crown', check: () => gameState.totalValue >= 1000000 },
            { id: 'multi_millionaire', name: 'Multi-Millionaire', desc: 'Reach $10,000,000 total value', reward: 'Diamond Crown', check: () => gameState.totalValue >= 10000000 },
            { id: 'mega_rich', name: 'Mega Rich', desc: 'Reach $100,000,000 total value', reward: 'Cosmic Crown', check: () => gameState.totalValue >= 100000000 },
            { id: 'ultra_rich', name: 'Ultra Rich', desc: 'Reach $1,000,000,000 total value', reward: 'Absolute Crown', check: () => gameState.totalValue >= 1000000000 },
            { id: 'legendary_pull', name: 'Legendary Pull', desc: 'Get a Legendary item', reward: 'Rare Spin Boost', check: () => Object.keys(gameState.inventory).some(key => key.includes('Legendary')) },
            { id: 'mythic_pull', name: 'Mythic Hunter', desc: 'Get a Mythic item', reward: 'Mythic Aura', check: () => Object.keys(gameState.inventory).some(key => key.includes('Mythic')) },
            { id: 'exotic_pull', name: 'Exotic Collector', desc: 'Get an Exotic item', reward: 'Exotic Badge', check: () => Object.keys(gameState.inventory).some(key => key.includes('Exotic')) },
            { id: 'divine_pull', name: 'Divine Blessing', desc: 'Get a Divine item', reward: 'Divine Halo', check: () => Object.keys(gameState.inventory).some(key => key.includes('Divine')) },
            { id: 'infinite_pull', name: 'Infinite Luck', desc: 'Get an Infinite item', reward: 'Infinite Power', check: () => Object.keys(gameState.inventory).some(key => key.includes('Infinite')) },
            { id: 'absolute_pull', name: 'Absolute Master', desc: 'Get an Absolute item', reward: 'Absolute Authority', check: () => Object.keys(gameState.inventory).some(key => key.includes('Absolute')) },
            { id: 'trade_king', name: 'Trade King', desc: 'Win 50 trades', reward: 'Trader Badge', check: () => gameState.tradeWins >= 50 },
            { id: 'trade_emperor', name: 'Trade Emperor', desc: 'Win 500 trades', reward: 'Emperor Medal', check: () => gameState.tradeWins >= 500 },
            { id: 'trade_god', name: 'Trade God', desc: 'Win 5,000 trades', reward: 'Trade Master', check: () => gameState.tradeWins >= 5000 },
            { id: 'scammed', name: 'Getting Scammed', desc: 'Lose 100 trades', reward: 'Cautious Trader', check: () => gameState.tradeLosses >= 100 },
            { id: 'crafter', name: 'Master Crafter', desc: 'Craft 10 items', reward: 'Crafting Kit', check: () => gameState.craftCount >= 10 },
            { id: 'crafter_expert', name: 'Crafting Expert', desc: 'Craft 100 items', reward: 'Expert Kit', check: () => gameState.craftCount >= 100 },
            { id: 'enchanter', name: 'Enchantment Expert', desc: 'Successfully enchant 20 items', reward: 'Enchanter Robe', check: () => gameState.enchantSuccess >= 20 },
            { id: 'enchanter_master', name: 'Enchantment Master', desc: 'Successfully enchant 100 items', reward: 'Master Robe', check: () => gameState.enchantSuccess >= 100 },
            { id: 'failed_enchants', name: 'Destruction Expert', desc: 'Fail 50 enchantments', reward: 'Phoenix Charm', check: () => gameState.enchantFails >= 50 },
            { id: 'collector', name: 'Item Collector', desc: 'Have 50 different items', reward: 'Collector Badge', check: () => Object.keys(gameState.inventory).filter(k => gameState.inventory[k].count > 0).length >= 50 },
            { id: 'collector_master', name: 'Master Collector', desc: 'Have 100 different items', reward: 'Master Badge', check: () => Object.keys(gameState.inventory).filter(k => gameState.inventory[k].count > 0).length >= 100 },
            { id: 'hoarder', name: 'Hoarder', desc: 'Have 1,000 total items', reward: 'Storage Expansion', check: () => Object.values(gameState.inventory).reduce((sum, item) => sum + item.count, 0) >= 1000 },
            { id: 'rich_trader', name: 'Rich Trader', desc: 'Have $100,000 in cash', reward: 'Cash King Title', check: () => gameState.money >= 100000 },
            { id: 'cash_king', name: 'Cash King', desc: 'Have $1,000,000 in cash', reward: 'Golden Wallet', check: () => gameState.money >= 1000000 },
            { id: 'battle_pass_hero', name: 'Battle Pass Hero', desc: 'Reach Battle Pass Tier 15', reward: 'Hero Badge', check: () => gameState.battlePassTier >= 15 },
            { id: 'battle_pass_master', name: 'Battle Pass Master', desc: 'Complete Battle Pass (Tier 25)', reward: 'Master Crown', check: () => gameState.battlePassTier >= 25 },
            { id: 'christmas_spirit', name: 'Christmas Spirit', desc: 'Get 10 Christmas items', reward: 'Santa Hat', check: () => Object.keys(gameState.inventory).filter(k => k.includes('üéÖ') || k.includes('üéÑ') || k.includes('‚õÑ') || k.includes('üéÅ')).length >= 10 },
            { id: 'upgraded', name: 'Upgraded', desc: 'Buy any upgrade', reward: 'Upgrade Token', check: () => Object.values(gameState.upgrades).some(v => v > 0) },
            { id: 'fully_upgraded', name: 'Fully Upgraded', desc: 'Max out any upgrade', reward: 'Max Token', check: () => Object.entries(gameState.upgrades).some(([key, val]) => val >= upgradeData[key].maxLevel) },
            { id: 'first_rebirth', name: 'Reborn', desc: 'Complete your first rebirth', reward: 'Rebirth Crown', check: () => gameState.rebirths >= 1 },
            { id: 'rebirth_5', name: 'Serial Rebirther', desc: 'Complete 5 rebirths', reward: 'Eternal Crown', check: () => gameState.rebirths >= 5 },
            { id: 'rebirth_10', name: 'Rebirth Master', desc: 'Complete 10 rebirths', reward: 'Infinite Rebirth', check: () => gameState.rebirths >= 10 },
            { id: 'paradox_pull', name: 'Paradoxical', desc: 'Get a Paradox item', reward: 'Reality Breaker', check: () => Object.keys(gameState.inventory).some(key => key.includes('Paradox')) },
            { id: 'singularity_pull', name: 'Singularity Hunter', desc: 'Get a Singularity item', reward: 'Black Hole Core', check: () => Object.keys(gameState.inventory).some(key => key.includes('Singularity')) },
            { id: 'void_pull', name: 'Void Walker', desc: 'Get a Void item', reward: 'Void Cloak', check: () => Object.keys(gameState.inventory).some(key => key.includes('Void')) },
            { id: 'everything_pull', name: 'Universe Creator', desc: 'Get an Everything item', reward: 'Creation Power', check: () => Object.keys(gameState.inventory).some(key => key.includes('Everything')) },
            { id: 'theone_pull', name: 'THE ONE', desc: 'Get The One item', reward: 'EXISTENCE ITSELF', check: () => Object.keys(gameState.inventory).some(key => key.includes('The One')) },
            { id: 'quantum_pull', name: 'Quantum Collector', desc: 'Get a Quantum item', reward: 'Quantum Mastery', check: () => Object.keys(gameState.inventory).some(key => key.includes('Quantum')) },
            { id: 'hyperversal_pull', name: 'Hyperversal Explorer', desc: 'Get a Hyperversal item', reward: 'Reality Shifter', check: () => Object.keys(gameState.inventory).some(key => key.includes('Hyperversal')) },
            { id: 'abstract_pull', name: 'Conceptual Being', desc: 'Get an Abstract or Conceptual item', reward: 'Pure Thought', check: () => Object.keys(gameState.inventory).some(key => key.includes('Abstract') || key.includes('Conceptual')) },
            { id: 'source_pull', name: 'Source Finder', desc: 'Get The Source item', reward: 'Origin Power', check: () => Object.keys(gameState.inventory).some(key => key.includes('The Source')) },
            { id: 'beyond_infinity_pull', name: 'BEYOND ALL', desc: 'Get Beyond Infinity item', reward: 'TRANSCENDENCE', check: () => Object.keys(gameState.inventory).some(key => key.includes('Beyond Infinity')) },
            { id: 'ultra_rich', name: 'Quadrillionaire', desc: 'Reach $1 Quadrillion total value', reward: 'Ultimate Wealth', check: () => gameState.totalValue >= 1000000000000000 },
            { id: 'quest_master', name: 'Quest Master', desc: 'Complete 10 quests', reward: 'Quest Master Badge', check: () => gameState.questsCompleted >= 10 },
            { id: 'quest_legend', name: 'Quest Legend', desc: 'Complete 50 quests', reward: 'Quest Legend Crown', check: () => gameState.questsCompleted >= 50 },
            { id: 'daily_grinder', name: 'Daily Grinder', desc: 'Complete 5 daily quests in a row', reward: 'Dedication Medal', check: () => gameState.dailyStreak >= 5 },
            { id: 'weekly_warrior', name: 'Weekly Warrior', desc: 'Complete 10 weekly quests', reward: 'Warrior Badge', check: () => gameState.weeklyQuestsCompleted >= 10 },
            { id: 'enchant_god', name: 'Enchantment God', desc: 'Successfully enchant 500 items', reward: 'God Robe', check: () => gameState.enchantSuccess >= 500 },
            { id: 'shop_addict', name: 'Shop Addict', desc: 'Buy 100 items from shop', reward: 'VIP Card', check: () => gameState.shopPurchases >= 100 },
            { id: 'weather_chaser', name: 'Weather Chaser', desc: 'Collect 25 weather event items', reward: 'Storm Chaser Badge', check: () => Object.keys(gameState.inventory).filter(k => k.includes('‚òÅÔ∏è') || k.includes('üåßÔ∏è') || k.includes('‚õàÔ∏è')).length >= 25 },
            { id: 'lucky_devil', name: 'Lucky Devil', desc: 'Reach 10x luck multiplier', reward: 'Devil Horns', check: () => (gameState.luckMultiplier * gameState.permanentLuckBoost) >= 10 },
            { id: 'spin_addict', name: 'Spin Addict', desc: 'Spin 1,000,000 items', reward: 'Addiction Crown', check: () => gameState.totalSpins >= 1000000 },
            { id: 'trade_tycoon', name: 'Trade Tycoon', desc: 'Win 10,000 trades', reward: 'Tycoon Medal', check: () => gameState.tradeWins >= 10000 },
            { id: 'mega_crafter', name: 'Mega Crafter', desc: 'Craft 1,000 items', reward: 'Mega Kit', check: () => gameState.craftCount >= 1000 },
            { id: 'rebirth_legend', name: 'Rebirth Legend', desc: 'Complete 25 rebirths', reward: 'Legend Status', check: () => gameState.rebirths >= 25 },
            { id: 'rebirth_god', name: 'Rebirth God', desc: 'Complete 50 rebirths', reward: 'God Status', check: () => gameState.rebirths >= 50 },
            { id: 'ultimate_collector', name: 'Ultimate Collector', desc: 'Have 250 different items', reward: 'Ultimate Badge', check: () => Object.keys(gameState.inventory).filter(k => gameState.inventory[k].count > 0).length >= 250 }
        ];
        
        // Battle Pass Tiers
        const battlePassTiers = [
            { tier: 1, xpRequired: 100, reward: 'Common Crate' },
            { tier: 2, xpRequired: 250, reward: 'Uncommon Crate' },
            { tier: 3, xpRequired: 500, reward: 'Rare Crate' },
            { tier: 4, xpRequired: 1000, reward: 'Epic Crate' },
            { tier: 5, xpRequired: 2000, reward: 'Legendary Crate' },
            { tier: 6, xpRequired: 3500, reward: 'Mythic Crate' },
            { tier: 7, xpRequired: 5000, reward: 'Exotic Crate' },
            { tier: 8, xpRequired: 7500, reward: 'Celestial Crate' },
            { tier: 9, xpRequired: 10000, reward: 'Divine Crate' },
            { tier: 10, xpRequired: 13000, reward: 'Cosmic Crate' },
            { tier: 11, xpRequired: 16500, reward: 'Infinite Crate' },
            { tier: 12, xpRequired: 20000, reward: 'Transcendent Crate' },
            { tier: 13, xpRequired: 25000, reward: 'Ethereal Crate' },
            { tier: 14, xpRequired: 30000, reward: 'Primordial Crate' },
            { tier: 15, xpRequired: 35000, reward: 'Omega Badge' },
            { tier: 16, xpRequired: 40000, reward: 'Supreme Crown' },
            { tier: 17, xpRequired: 45000, reward: 'Godlike Aura' },
            { tier: 18, xpRequired: 50000, reward: 'Universal Key' },
            { tier: 19, xpRequired: 55000, reward: 'Multiversal Token' },
            { tier: 20, xpRequired: 60000, reward: 'Omnipotent Seal' },
            { tier: 21, xpRequired: 70000, reward: 'Absolute Fragment' },
            { tier: 22, xpRequired: 80000, reward: 'Ultimate Power' },
            { tier: 23, xpRequired: 90000, reward: 'Perfect Essence' },
            { tier: 24, xpRequired: 100000, reward: 'True Divinity' },
            { tier: 25, xpRequired: 125000, reward: 'Eternal Glory' }
        ];
        
        // Quest System
        const questTemplates = {
            daily: [
                { id: 'spin_25', name: 'Spin 25 Items', desc: 'Spin 25 items today', target: 25, xpReward: 100, check: (progress) => progress >= 25, track: 'spins' },
                { id: 'win_5_trades', name: 'Win 5 Trades', desc: 'Win 5 trades today', target: 5, xpReward: 150, check: (progress) => progress >= 5, track: 'tradeWins' },
                { id: 'craft_3', name: 'Craft 3 Items', desc: 'Craft 3 items today', target: 3, xpReward: 120, check: (progress) => progress >= 3, track: 'crafts' },
                { id: 'earn_10k', name: 'Earn $10K', desc: 'Earn $10,000 today', target: 10000, xpReward: 100, check: (progress) => progress >= 10000, track: 'moneyEarned' },
                { id: 'enchant_2', name: 'Enchant 2 Items', desc: 'Enchant 2 items today', target: 2, xpReward: 200, check: (progress) => progress >= 2, track: 'enchants' },
                { id: 'shop_buy_5', name: 'Shop Spree', desc: 'Buy 5 items from shop', target: 5, xpReward: 150, check: (progress) => progress >= 5, track: 'shopBuys' }
            ],
            weekly: [
                { id: 'spin_500', name: 'Spin Master', desc: 'Spin 500 items this week', target: 500, xpReward: 1000, check: (progress) => progress >= 500, track: 'spins' },
                { id: 'win_50_trades', name: 'Trade Master', desc: 'Win 50 trades this week', target: 50, xpReward: 1500, check: (progress) => progress >= 50, track: 'tradeWins' },
                { id: 'craft_30', name: 'Crafting Master', desc: 'Craft 30 items this week', target: 30, xpReward: 1200, check: (progress) => progress >= 30, track: 'crafts' },
                { id: 'rare_pull', name: 'Lucky Week', desc: 'Get 10 Legendary+ items', target: 10, xpReward: 2000, check: (progress) => progress >= 10, track: 'rarePulls' },
                { id: 'enchant_15', name: 'Enchanting Week', desc: 'Enchant 15 items this week', target: 15, xpReward: 1800, check: (progress) => progress >= 15, track: 'enchants' }
            ]
        };
        
        // Initialize
        gameState.craftCount = 0;
        gameState.enchantSuccess = 0;
        gameState.enchantFails = 0;
        
        // Enchantment System
        const enchantments = {
            // Regular Enchants
            'Value Upgrade I': { tier: 1, type: 'regular', chance: 0.15, effect: { valueMultiplier: 1.25 } },
            'Value Upgrade II': { tier: 2, type: 'regular', chance: 0.12, effect: { valueMultiplier: 1.5 } },
            'Value Upgrade III': { tier: 3, type: 'regular', chance: 0.09, effect: { valueMultiplier: 2.0 } },
            'Value Upgrade IV': { tier: 4, type: 'regular', chance: 0.06, effect: { valueMultiplier: 3.0 } },
            'Value Upgrade V': { tier: 5, type: 'regular', chance: 0.03, effect: { valueMultiplier: 5.0 } },
            
            'Traders Dream I': { tier: 1, type: 'regular', chance: 0.15, effect: { tradeAttraction: 1.25 } },
            'Traders Dream II': { tier: 2, type: 'regular', chance: 0.12, effect: { tradeAttraction: 1.5 } },
            'Traders Dream III': { tier: 3, type: 'regular', chance: 0.09, effect: { tradeAttraction: 2.0 } },
            'Traders Dream IV': { tier: 4, type: 'regular', chance: 0.06, effect: { tradeAttraction: 3.0 } },
            'Traders Dream V': { tier: 5, type: 'regular', chance: 0.03, effect: { tradeAttraction: 5.0 } },
            
            'Crafting Merger I': { tier: 1, type: 'regular', chance: 0.15, effect: { craftDupeChance: 0.1 } },
            'Crafting Merger II': { tier: 2, type: 'regular', chance: 0.12, effect: { craftDupeChance: 0.15 } },
            'Crafting Merger III': { tier: 3, type: 'regular', chance: 0.09, effect: { craftDupeChance: 0.25 } },
            'Crafting Merger IV': { tier: 4, type: 'regular', chance: 0.06, effect: { craftDupeChance: 0.35 } },
            'Crafting Merger V': { tier: 5, type: 'regular', chance: 0.03, effect: { craftDupeChance: 0.5 } },
            
            'Enchanters Tool I': { tier: 1, type: 'regular', chance: 0.15, effect: { enchantLuckBoost: 1.1 } },
            'Enchanters Tool II': { tier: 2, type: 'regular', chance: 0.12, effect: { enchantLuckBoost: 1.2 } },
            'Enchanters Tool III': { tier: 3, type: 'regular', chance: 0.09, effect: { enchantLuckBoost: 1.35 } },
            'Enchanters Tool IV': { tier: 4, type: 'regular', chance: 0.06, effect: { enchantLuckBoost: 1.5 } },
            'Enchanters Tool V': { tier: 5, type: 'regular', chance: 0.03, effect: { enchantLuckBoost: 2.0 } },
            
            'Money Multi I': { tier: 1, type: 'regular', chance: 0.15, effect: { sellMultiplier: 1.2 } },
            'Money Multi II': { tier: 2, type: 'regular', chance: 0.12, effect: { sellMultiplier: 1.4 } },
            'Money Multi III': { tier: 3, type: 'regular', chance: 0.09, effect: { sellMultiplier: 1.7 } },
            'Money Multi IV': { tier: 4, type: 'regular', chance: 0.06, effect: { sellMultiplier: 2.0 } },
            'Money Multi V': { tier: 5, type: 'regular', chance: 0.03, effect: { sellMultiplier: 2.5 } },
            
            'Event Starter III': { tier: 3, type: 'regular', chance: 0.08, effect: { eventStarter: true } },
            'Event Starter IV': { tier: 4, type: 'regular', chance: 0.05, effect: { eventStarter: true } },
            'Event Starter V': { tier: 5, type: 'regular', chance: 0.02, effect: { eventStarter: true } },
            
            'Lucky Item': { tier: 1, type: 'regular', chance: 0.15, effect: { luckBoost: 0.1 } },
            
            // Godly Enchants
            'Admins Dreams V': { tier: 5, type: 'godly', chance: 0.01, effect: { valueMultiplier: 2, luckBoost: 2, tradeAttraction: 2 } },
            'Emperors Style V': { tier: 5, type: 'godly', chance: 0.01, effect: { luckBoost: 4, tradeAttraction: 3 } },
            'Endless Possibilities V': { tier: 5, type: 'godly', chance: 0.01, effect: { craftDupeChance: 0.5, enchantLuckBoost: 2 } },
            'Chaotics Thoughts IV': { tier: 4, type: 'godly', chance: 0.015, effect: { spinMultiplier: 2, scammerBlock: true } },
            'Chaotics Thoughts V': { tier: 5, type: 'godly', chance: 0.01, effect: { spinMultiplier: 2, scammerBlock: true } },
            
            // Best Enchant
            'Ruler of the World VI': { tier: 6, type: 'ultimate', chance: 0.001, effect: { 
                valueMultiplier: 5, 
                luckBoost: 5, 
                tradeAttraction: 5,
                craftDupeChance: 0.75,
                enchantLuckBoost: 3,
                sellMultiplier: 3,
                spinMultiplier: 3
            }},
            
            // Bad Enchants
            'Ditto I': { tier: 1, type: 'bad', chance: 0.1, effect: { dittoCopy: 1.1 } },
            'Ditto II': { tier: 2, type: 'bad', chance: 0.08, effect: { dittoCopy: 1.15 } },
            'Ditto III': { tier: 3, type: 'bad', chance: 0.06, effect: { dittoCopy: 1.2 } },
            'Ditto IV': { tier: 4, type: 'bad', chance: 0.04, effect: { dittoCopy: 1.25 } },
            'Ditto V': { tier: 5, type: 'bad', chance: 0.02, effect: { dittoCopy: 1.3 } },
            'Too Much Energy': { tier: 0, type: 'bad', chance: 0.05, effect: { destroy: true } },
            'Too Little Energy': { tier: 0, type: 'bad', chance: 0.05, effect: { destroy: true } }
        };
        
        // Spin Function
        // Format large numbers (1000 -> 1K, 1000000 -> 1M, etc.)
        function formatNumber(num) {
            if (num === null || num === undefined || isNaN(num)) return '0';
            
            const absNum = Math.abs(num);
            const sign = num < 0 ? '-' : '';
            
            if (absNum >= 1e63) return sign + (absNum / 1e63).toFixed(2) + 'VG';
            if (absNum >= 1e60) return sign + (absNum / 1e60).toFixed(2) + 'NOD';
            if (absNum >= 1e57) return sign + (absNum / 1e57).toFixed(2) + 'OCD';
            if (absNum >= 1e54) return sign + (absNum / 1e54).toFixed(2) + 'SPD';
            if (absNum >= 1e51) return sign + (absNum / 1e51).toFixed(2) + 'SXD';
            if (absNum >= 1e48) return sign + (absNum / 1e48).toFixed(2) + 'QID';
            if (absNum >= 1e45) return sign + (absNum / 1e45).toFixed(2) + 'QAD';
            if (absNum >= 1e42) return sign + (absNum / 1e42).toFixed(2) + 'TD';
            if (absNum >= 1e39) return sign + (absNum / 1e39).toFixed(2) + 'DD';
            if (absNum >= 1e36) return sign + (absNum / 1e36).toFixed(2) + 'UD';
            if (absNum >= 1e33) return sign + (absNum / 1e33).toFixed(2) + 'DC';
            if (absNum >= 1e30) return sign + (absNum / 1e30).toFixed(2) + 'NO';
            if (absNum >= 1e27) return sign + (absNum / 1e27).toFixed(2) + 'OC';
            if (absNum >= 1e24) return sign + (absNum / 1e24).toFixed(2) + 'SP';
            if (absNum >= 1e21) return sign + (absNum / 1e21).toFixed(2) + 'SX';
            if (absNum >= 1e18) return sign + (absNum / 1e18).toFixed(2) + 'QI';
            if (absNum >= 1e15) return sign + (absNum / 1e15).toFixed(2) + 'QA';
            if (absNum >= 1e12) return sign + (absNum / 1e12).toFixed(2) + 'T';
            if (absNum >= 1e9) return sign + (absNum / 1e9).toFixed(2) + 'B';
            if (absNum >= 1e6) return sign + (absNum / 1e6).toFixed(2) + 'M';
            if (absNum >= 1e3) return sign + (absNum / 1e3).toFixed(2) + 'K';
            return sign + absNum.toFixed(0);
        }
        
        // ===== QUEST SYSTEM =====
        
        function generateDailyQuests() {
            const dailyQuests = [...questTemplates.daily];
            // Shuffle and pick 3 random daily quests
            for (let i = dailyQuests.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [dailyQuests[i], dailyQuests[j]] = [dailyQuests[j], dailyQuests[i]];
            }
            return dailyQuests.slice(0, 3).map(q => ({...q, progress: 0, type: 'daily', completed: false}));
        }
        
        function generateWeeklyQuests() {
            const weeklyQuests = [...questTemplates.weekly];
            // Shuffle and pick 2 random weekly quests
            for (let i = weeklyQuests.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [weeklyQuests[i], weeklyQuests[j]] = [weeklyQuests[j], weeklyQuests[i]];
            }
            return weeklyQuests.slice(0, 2).map(q => ({...q, progress: 0, type: 'weekly', completed: false}));
        }
        
        function refreshQuests() {
            const now = Date.now();
            const oneDay = 24 * 60 * 60 * 1000;
            const oneWeek = 7 * oneDay;
            
            if (!gameState.lastQuestRefresh || now - gameState.lastQuestRefresh >= oneDay) {
                // Refresh daily quests
                const dailyQuests = generateDailyQuests();
                const weeklyQuests = gameState.activeQuests.filter(q => q.type === 'weekly');
                
                // Check if weekly quests need refresh
                if (!gameState.lastQuestRefresh || now - gameState.lastQuestRefresh >= oneWeek) {
                    gameState.activeQuests = [...dailyQuests, ...generateWeeklyQuests()];
                } else {
                    gameState.activeQuests = [...dailyQuests, ...weeklyQuests];
                }
                
                gameState.lastQuestRefresh = now;
                saveGame(true);
            }
        }
        
        function updateQuestProgress(trackType, amount) {
            if (!gameState.activeQuests || gameState.activeQuests.length === 0) {
                refreshQuests();
            }
            
            if (!gameState.activeQuests) return; // Safety check
            
            for (const quest of gameState.activeQuests) {
                if (quest.track === trackType && !quest.completed) {
                    quest.progress += amount;
                    
                    if (quest.check(quest.progress)) {
                        completeQuest(quest);
                    }
                }
            }
            
            updateQuestDisplay();
        }
        
        function completeQuest(quest) {
            if (quest.completed) return;
            
            quest.completed = true;
            gameState.questsCompleted = (gameState.questsCompleted || 0) + 1;
            
            // Apply quest speed upgrade
            let questXP = quest.xpReward;
            if (gameState.upgrades.questSpeed > 0) {
                questXP = Math.floor(questXP * (1 + gameState.upgrades.questSpeed * 0.05)); // +5% per level
            }
            gameState.battlePassXP += questXP;
            
            if (quest.type === 'daily') {
                gameState.dailyStreak = (gameState.dailyStreak || 0) + 1;
            } else if (quest.type === 'weekly') {
                gameState.weeklyQuestsCompleted = (gameState.weeklyQuestsCompleted || 0) + 1;
            }
            
            showNotification(`‚úÖ Quest Complete: ${quest.name}! +${quest.xpReward} XP`, 'var(--success)');
            updateBattlePass();
            checkAchievements();
            saveGame(true);
        }
        
        function updateQuestDisplay() {
            const container = document.getElementById('questContainer');
            if (!container) return;
            
            if (!gameState.activeQuests || gameState.activeQuests.length === 0) {
                refreshQuests();
            }
            
            container.innerHTML = '';
            
            const dailyQuests = gameState.activeQuests.filter(q => q.type === 'daily');
            const weeklyQuests = gameState.activeQuests.filter(q => q.type === 'weekly');
            
            if (dailyQuests.length > 0) {
                const dailySection = document.createElement('div');
                dailySection.innerHTML = '<h3 style="color: var(--accent-gold); margin-bottom: 10px;">üìÖ Daily Quests</h3>';
                dailyQuests.forEach(quest => {
                    dailySection.innerHTML += createQuestCard(quest);
                });
                container.appendChild(dailySection);
            }
            
            if (weeklyQuests.length > 0) {
                const weeklySection = document.createElement('div');
                weeklySection.innerHTML = '<h3 style="color: var(--accent-primary); margin: 20px 0 10px 0;">üìÜ Weekly Quests</h3>';
                weeklyQuests.forEach(quest => {
                    weeklySection.innerHTML += createQuestCard(quest);
                });
                container.appendChild(weeklySection);
            }
        }
        
        function createQuestCard(quest) {
            const target = quest.target || 1;
            const progressPercent = Math.min(100, (quest.progress / target) * 100);
            const statusColor = quest.completed ? 'var(--success)' : 'var(--accent-primary)';
            const statusText = quest.completed ? '‚úÖ COMPLETED' : `${Math.floor(quest.progress)}/${target}`;
            
            return `
                <div class="recipe-card" style="border-color: ${statusColor}; opacity: ${quest.completed ? 0.7 : 1};">
                    <h4 style="color: ${statusColor};">${quest.name}</h4>
                    <p style="color: var(--text-secondary); margin: 5px 0;">${quest.desc}</p>
                    <div style="background: var(--bg-dark); border-radius: 10px; overflow: hidden; margin: 10px 0;">
                        <div style="background: ${statusColor}; height: 8px; width: ${progressPercent}%; transition: width 0.3s;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: ${statusColor};">${statusText}</span>
                        <span style="color: var(--accent-gold);">üéÅ ${quest.xpReward} XP</span>
                    </div>
                </div>
            `;
        }
        
        let spinCooldown = false;
        
        function spinItem() {
            if (spinCooldown) return;
            
            const btn = document.getElementById('spinBtn');
            btn.classList.add('spinning');
            btn.textContent = 'SPINNING...';
            
            // Apply speed upgrade
            const speedMultiplier = 1 - (gameState.upgrades.spinSpeed * 0.1); // 10% faster per level
            const spinTime = Math.max(500, 1000 * speedMultiplier);
            
            setTimeout(() => {
                // Apply both regular luck multiplier AND permanent luck boost
                const totalLuck = gameState.luckMultiplier * gameState.permanentLuckBoost;
                const roll = Math.random() * totalLuck;
                let selectedRarity = rarities[0];
                
                // Check for Special Event items (40% base + eventLuck upgrade)
                let specialEventChance = 0.4;
                if (gameState.upgrades.eventLuck > 0) {
                    specialEventChance += gameState.upgrades.eventLuck * 0.05; // +5% per level
                }
                if (gameState.specialEvent && Math.random() < specialEventChance) {
                    const eventItems = {
                        disco: discoItems,
                        galactic: galacticItems,
                        glitch: glitchItems,
                        fullmoon: fullMoonItems,
                        bloodmoon: bloodMoonItems
                    };
                    const specialItem = eventItems[gameState.specialEvent][Math.floor(Math.random() * eventItems[gameState.specialEvent].length)];
                    const rarity = rarities.find(r => r.name === specialItem.rarity);
                    if (rarity) {
                        selectedRarity = rarity;
                        addItemToInventory(specialItem.name, selectedRarity);
                    }
                }
                // Check for Weather Event items (30% base + eventLuck upgrade)
                else if (gameState.weatherEvent) {
                    let weatherEventChance = 0.3;
                    if (gameState.upgrades.eventLuck > 0) {
                        weatherEventChance += gameState.upgrades.eventLuck * 0.05; // +5% per level
                    }
                    if (Math.random() < weatherEventChance) {
                        const weatherItem = weatherItems[gameState.weatherEvent][Math.floor(Math.random() * weatherItems[gameState.weatherEvent].length)];
                        const rarity = rarities.find(r => r.name === weatherItem.rarity);
                        if (rarity) {
                            selectedRarity = rarity;
                            addItemToInventory(weatherItem.name, selectedRarity);
                        }
                    }
                }
                // Check for Christmas item
                else if (gameState.christmasEvent && Math.random() < 0.15) {
                    const christmasItem = christmasItems[Math.floor(Math.random() * christmasItems.length)];
                    const rarity = rarities.find(r => r.name === christmasItem.rarity);
                    if (rarity) {
                        selectedRarity = rarity;
                        addItemToInventory(christmasItem.name, selectedRarity);
                    }
                } else {
                    // Regular item generation
                    let cumulativeChance = 0;
                    for (let i = rarities.length - 1; i >= 0; i--) {
                        cumulativeChance += rarities[i].chance;
                        if (roll < cumulativeChance) {
                            selectedRarity = rarities[i];
                            break;
                        }
                    }
                    
                    const itemName = generateItemName(selectedRarity);
                    addItemToInventory(itemName, selectedRarity);
                }
                
                // Check for spin multiplier from Chaotics Thoughts enchant
                let spinMultiplier = 1;
                for (const [key, item] of Object.entries(gameState.inventory)) {
                    if (item.count > 0 && item.enchantments) {
                        for (const enchantName of item.enchantments) {
                            const enchantData = enchantments[enchantName];
                            if (enchantData && enchantData.effect.spinMultiplier) {
                                spinMultiplier = Math.max(spinMultiplier, enchantData.effect.spinMultiplier);
                            }
                        }
                    }
                }
                
                gameState.totalSpins += spinMultiplier;
                if (spinMultiplier > 1) {
                    showNotification(`‚ö° Chaotics Thoughts! ${spinMultiplier}x spin count!`, 'var(--accent-gold)');
                }
                
                // Apply XP boost upgrade
                let baseXP = 10;
                if (gameState.upgrades.xpBoost > 0) {
                    baseXP = Math.floor(baseXP * (1 + gameState.upgrades.xpBoost * 0.1));
                }
                gameState.battlePassXP += baseXP;
                
                // Mystery Box chance - give a bonus random item
                if (gameState.upgrades.mysteryBox > 0) {
                    const mysteryChance = gameState.upgrades.mysteryBox * 0.02; // 2% per level
                    if (Math.random() < mysteryChance) {
                        const bonusRarity = rarities[Math.floor(Math.random() * Math.min(15, rarities.length))];
                        const bonusItem = generateItemName(bonusRarity);
                        addItemToInventory(bonusItem, bonusRarity);
                        showNotification(`üéÅ MYSTERY BOX! Bonus: ${bonusItem}!`, bonusRarity.color);
                    }
                }
                
                // Update quests
                updateQuestProgress('spins', spinMultiplier);
                
                // Track rare pulls for quests
                const rarityIndex = rarities.findIndex(r => r.name === selectedRarity.name);
                if (rarityIndex >= 4) { // Legendary or higher
                    updateQuestProgress('rarePulls', 1);
                }
                
                updateStats();
                checkAchievements();
                updateBattlePass();
                
                btn.classList.remove('spinning');
                btn.textContent = 'SPIN AGAIN!';
                
                // Random event chance
                if (Math.random() < 0.05) {
                    triggerRandomEvent();
                }
                
                // Cooldown
                spinCooldown = true;
                setTimeout(() => {
                    spinCooldown = false;
                }, spinTime);
            }, spinTime);
        }
        
        // Auto-spin functionality
        function startAutoSpin() {
            if (gameState.upgrades.autoSpin > 0) {
                const interval = Math.max(3000, (11 - gameState.upgrades.autoSpin) * 1000);
                setInterval(() => {
                    if (gameState.upgrades.autoSpin > 0 && !spinCooldown) {
                        spinItem();
                    }
                }, interval);
            }
        }
        
        function triggerUltraRareAnimation(rarityName, rarityColor, itemName, itemValue) {
            const rarityIndex = rarities.findIndex(r => r.name === rarityName);
            
            // Only trigger for Cosmic (index 9) and beyond
            if (rarityIndex < 9) return;
            
            const overlay = document.createElement('div');
            overlay.className = 'ultra-rare-overlay';
            document.body.appendChild(overlay);
            
            // Different animations based on rarity
            if (rarityName === 'Cosmic') {
                // Purple sparkles
                for (let i = 0; i < 50; i++) {
                    const sparkle = document.createElement('div');
                    sparkle.style.position = 'absolute';
                    sparkle.style.width = '10px';
                    sparkle.style.height = '10px';
                    sparkle.style.background = '#ff69b4';
                    sparkle.style.borderRadius = '50%';
                    sparkle.style.left = Math.random() * 100 + '%';
                    sparkle.style.top = Math.random() * 100 + '%';
                    sparkle.style.animation = 'cosmic-sparkle 2s ease-out';
                    sparkle.style.animationDelay = (Math.random() * 0.5) + 's';
                    overlay.appendChild(sparkle);
                }
            } else if (rarityName === 'Infinite') {
                // Rainbow waves
                for (let i = 0; i < 5; i++) {
                    const wave = document.createElement('div');
                    wave.style.position = 'absolute';
                    wave.style.width = '200%';
                    wave.style.height = '100px';
                    wave.style.top = (i * 20) + '%';
                    wave.style.background = `linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent)`;
                    wave.style.animation = 'infinite-wave 2s ease-out';
                    wave.style.animationDelay = (i * 0.2) + 's';
                    overlay.appendChild(wave);
                }
            } else if (rarityName === 'Transcendent') {
                // Cyan lightning
                const lightning = document.createElement('div');
                lightning.style.position = 'absolute';
                lightning.style.width = '100%';
                lightning.style.height = '100%';
                lightning.style.background = '#00fff2';
                lightning.style.animation = 'transcendent-lightning 1.5s ease-out';
                overlay.appendChild(lightning);
            } else if (rarityName === 'Ethereal') {
                // Ghost wisps
                for (let i = 0; i < 20; i++) {
                    const wisp = document.createElement('div');
                    wisp.style.position = 'absolute';
                    wisp.style.width = '50px';
                    wisp.style.height = '50px';
                    wisp.style.background = 'radial-gradient(circle, rgba(177,156,217,0.8), transparent)';
                    wisp.style.left = Math.random() * 100 + '%';
                    wisp.style.animation = 'ethereal-wisp 3s ease-out';
                    wisp.style.animationDelay = (Math.random() * 0.5) + 's';
                    overlay.appendChild(wisp);
                }
            } else if (rarityName === 'Primordial') {
                // Fire explosion
                const explosion = document.createElement('div');
                explosion.style.position = 'absolute';
                explosion.style.width = '100px';
                explosion.style.height = '100px';
                explosion.style.left = '50%';
                explosion.style.top = '50%';
                explosion.style.transform = 'translate(-50%, -50%)';
                explosion.style.background = 'radial-gradient(circle, rgba(255,107,53,0.8), rgba(255,0,0,0.4), transparent)';
                explosion.style.animation = 'primordial-explosion 2s ease-out';
                overlay.appendChild(explosion);
            } else if (rarityName === 'Omega') {
                // Black hole vortex
                const vortex = document.createElement('div');
                vortex.style.position = 'absolute';
                vortex.style.width = '200px';
                vortex.style.height = '200px';
                vortex.style.left = '50%';
                vortex.style.top = '50%';
                vortex.style.transform = 'translate(-50%, -50%)';
                vortex.style.background = 'radial-gradient(circle, rgba(0,0,0,0.9), rgba(78,205,196,0.6), transparent)';
                vortex.style.animation = 'omega-vortex 3s ease-out';
                vortex.style.borderRadius = '50%';
                overlay.appendChild(vortex);
            } else if (rarityName === 'Supreme') {
                // Golden rays
                for (let i = 0; i < 12; i++) {
                    const ray = document.createElement('div');
                    ray.style.position = 'absolute';
                    ray.style.width = '5px';
                    ray.style.height = '100%';
                    ray.style.left = '50%';
                    ray.style.top = '0';
                    ray.style.background = 'linear-gradient(to bottom, transparent, rgba(255,230,109,0.8), transparent)';
                    ray.style.transformOrigin = 'center top';
                    ray.style.transform = `rotate(${i * 30}deg)`;
                    ray.style.animation = 'supreme-rays 2s ease-out';
                    overlay.appendChild(ray);
                }
            } else if (rarityName === 'Godlike') {
                // Divine pillars
                for (let i = 0; i < 8; i++) {
                    const pillar = document.createElement('div');
                    pillar.style.position = 'absolute';
                    pillar.style.width = '100px';
                    pillar.style.height = '100%';
                    pillar.style.left = (i * 12.5) + '%';
                    pillar.style.background = 'linear-gradient(to top, rgba(255,0,255,0.6), rgba(255,0,255,0))';
                    pillar.style.animation = 'godlike-pillar 2.5s ease-out';
                    pillar.style.animationDelay = (i * 0.1) + 's';
                    overlay.appendChild(pillar);
                }
            } else if (rarityName === 'Universal') {
                // Galaxy spiral
                const spiral = document.createElement('div');
                spiral.style.position = 'absolute';
                spiral.style.width = '300px';
                spiral.style.height = '300px';
                spiral.style.left = '50%';
                spiral.style.top = '50%';
                spiral.style.transform = 'translate(-50%, -50%)';
                spiral.style.background = 'radial-gradient(circle, rgba(0,255,170,0.4), rgba(0,255,170,0.2), transparent)';
                spiral.style.animation = 'universal-spiral 3s ease-out';
                spiral.style.borderRadius = '50%';
                overlay.appendChild(spiral);
            } else if (rarityName === 'Multiversal') {
                // Reality fracture
                const fracture = document.createElement('div');
                fracture.style.position = 'absolute';
                fracture.style.width = '100%';
                fracture.style.height = '100%';
                fracture.style.background = 'linear-gradient(45deg, rgba(255,51,153,0.5), rgba(0,255,255,0.5))';
                fracture.style.animation = 'multiversal-fracture 2s ease-out';
                overlay.appendChild(fracture);
            } else if (rarityName === 'Omnipotent') {
                // World shake
                document.body.style.animation = 'omnipotent-shake 2s ease-out';
                setTimeout(() => {
                    document.body.style.animation = '';
                }, 2000);
                
                // Add intense light flash
                const flash = document.createElement('div');
                flash.style.position = 'absolute';
                flash.style.width = '100%';
                flash.style.height = '100%';
                flash.style.background = 'rgba(255,204,0,0.8)';
                flash.style.animation = 'multiversal-fracture 2s ease-out';
                overlay.appendChild(flash);
            } else if (rarityName === 'Infinite Absolute') {
                // Dual infinity spirals
                for (let i = 0; i < 8; i++) {
                    const spiral = document.createElement('div');
                    spiral.style.position = 'absolute';
                    spiral.style.width = '100px';
                    spiral.style.height = '100px';
                    spiral.style.left = '50%';
                    spiral.style.top = '50%';
                    spiral.style.transform = 'translate(-50%, -50%)';
                    spiral.style.background = `radial-gradient(circle, rgba(255,153,255,0.6), transparent)`;
                    spiral.style.borderRadius = '50%';
                    spiral.style.animation = 'infinite-absolute-spiral 3s ease-out';
                    spiral.style.animationDelay = (i * 0.2) + 's';
                    overlay.appendChild(spiral);
                }
            } else if (rarityName === 'Eternal') {
                // Time ripples
                for (let i = 0; i < 10; i++) {
                    const ripple = document.createElement('div');
                    ripple.style.position = 'absolute';
                    ripple.style.width = '50px';
                    ripple.style.height = '50px';
                    ripple.style.left = '50%';
                    ripple.style.top = '50%';
                    ripple.style.transform = 'translate(-50%, -50%)';
                    ripple.style.border = '3px solid rgba(102,255,255,0.7)';
                    ripple.style.borderRadius = '50%';
                    ripple.style.animation = 'eternal-ripple 3s ease-out';
                    ripple.style.animationDelay = (i * 0.3) + 's';
                    overlay.appendChild(ripple);
                }
            } else if (rarityName === 'Immortal') {
                // Phoenix rebirth
                for (let i = 0; i < 12; i++) {
                    const feather = document.createElement('div');
                    feather.style.position = 'absolute';
                    feather.style.width = '80px';
                    feather.style.height = '80px';
                    feather.style.left = '50%';
                    feather.style.top = '50%';
                    feather.style.background = `radial-gradient(circle, rgba(255,255,102,0.8), rgba(255,102,102,0.6))`;
                    feather.style.borderRadius = '50%';
                    feather.style.animation = 'immortal-rebirth 3s ease-out';
                    feather.style.animationDelay = (i * 0.15) + 's';
                    overlay.appendChild(feather);
                }
            } else if (rarityName === 'Ascended') {
                // Heavenly ascension
                for (let i = 0; i < 10; i++) {
                    const beam = document.createElement('div');
                    beam.style.position = 'absolute';
                    beam.style.width = '50px';
                    beam.style.height = '100%';
                    beam.style.left = (i * 10) + '%';
                    beam.style.background = 'linear-gradient(to top, transparent, rgba(255,102,102,0.6))';
                    beam.style.animation = 'ascended-rise 3s ease-out';
                    beam.style.animationDelay = (i * 0.1) + 's';
                    overlay.appendChild(beam);
                }
            } else if (rarityName === 'Transcendental') {
                // Reality layers
                for (let i = 0; i < 8; i++) {
                    const layer = document.createElement('div');
                    layer.style.position = 'absolute';
                    layer.style.width = '100%';
                    layer.style.height = '100%';
                    layer.style.background = `rgba(102,255,102,${0.1 + i * 0.05})`;
                    layer.style.animation = 'transcendental-layers 3s ease-out';
                    layer.style.animationDelay = (i * 0.2) + 's';
                    overlay.appendChild(layer);
                }
            } else if (rarityName === 'Boundless') {
                // Expanding boundaries
                for (let i = 0; i < 6; i++) {
                    const boundary = document.createElement('div');
                    boundary.style.position = 'absolute';
                    boundary.style.width = '200px';
                    boundary.style.height = '200px';
                    boundary.style.left = '50%';
                    boundary.style.top = '50%';
                    boundary.style.transform = 'translate(-50%, -50%)';
                    boundary.style.border = '5px solid rgba(102,102,255,0.6)';
                    boundary.style.animation = 'boundless-expand 3s ease-out';
                    boundary.style.animationDelay = (i * 0.3) + 's';
                    overlay.appendChild(boundary);
                }
            } else if (rarityName === 'Limitless') {
                // Breaking limits
                const limitBreak = document.createElement('div');
                limitBreak.style.position = 'absolute';
                limitBreak.style.width = '300px';
                limitBreak.style.height = '300px';
                limitBreak.style.left = '50%';
                limitBreak.style.top = '50%';
                limitBreak.style.transform = 'translate(-50%, -50%)';
                limitBreak.style.background = 'radial-gradient(circle, rgba(255,102,255,0.8), transparent)';
                limitBreak.style.borderRadius = '50%';
                limitBreak.style.animation = 'limitless-break 3s ease-out';
                overlay.appendChild(limitBreak);
                
                // Add 15 breaking particles
                for (let i = 0; i < 15; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '20px';
                    particle.style.height = '20px';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.top = Math.random() * 100 + '%';
                    particle.style.background = 'rgba(255,102,255,0.8)';
                    particle.style.borderRadius = '50%';
                    particle.style.animation = 'limitless-break 3s ease-out';
                    particle.style.animationDelay = (Math.random() * 0.5) + 's';
                    overlay.appendChild(particle);
                }
            } else if (rarityName === 'Absolute') {
                // Universe explosion - THE BIG ONE!
                const bigBang = document.createElement('div');
                bigBang.style.position = 'absolute';
                bigBang.style.width = '50px';
                bigBang.style.height = '50px';
                bigBang.style.left = '50%';
                bigBang.style.top = '50%';
                bigBang.style.transform = 'translate(-50%, -50%)';
                bigBang.style.background = 'radial-gradient(circle, rgba(255,255,255,1), rgba(255,215,0,0.8), rgba(255,0,255,0.6), transparent)';
                bigBang.style.animation = 'absolute-big-bang 4s ease-out';
                bigBang.style.borderRadius = '50%';
                overlay.appendChild(bigBang);
                
                // Shake everything
                document.body.style.animation = 'omnipotent-shake 4s ease-out';
                setTimeout(() => {
                    document.body.style.animation = '';
                }, 4000);
            } else if (rarityName === 'Beyond') {
                // Dimension tear
                const tear = document.createElement('div');
                tear.style.position = 'absolute';
                tear.style.width = '100%';
                tear.style.height = '100%';
                tear.style.background = 'linear-gradient(45deg, rgba(255,170,0,0.8), rgba(255,0,170,0.8))';
                tear.style.animation = 'beyond-tear 5s ease-out';
                overlay.appendChild(tear);
                
                document.body.style.animation = 'omnipotent-shake 5s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 5000);
            } else if (rarityName === 'Incomprehensible') {
                // Reality distortion
                const distortion = document.createElement('div');
                distortion.style.position = 'absolute';
                distortion.style.width = '100%';
                distortion.style.height = '100%';
                distortion.style.background = 'radial-gradient(circle, rgba(170,0,255,0.7), rgba(0,255,255,0.7))';
                distortion.style.animation = 'incomprehensible-distort 6s ease-out';
                overlay.appendChild(distortion);
                
                document.body.style.animation = 'incomprehensible-distort 6s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 6000);
            } else if (rarityName === 'Unimaginable') {
                // Kaleidoscope explosion - OPTIMIZED
                for (let i = 0; i < 10; i++) {
                    const piece = document.createElement('div');
                    piece.style.position = 'absolute';
                    piece.style.width = '80px';
                    piece.style.height = '80px';
                    piece.style.left = '50%';
                    piece.style.top = '50%';
                    piece.style.background = `hsl(${i * 36}, 100%, 50%)`;
                    piece.style.animation = 'unimaginable-kaleidoscope 7s ease-out';
                    piece.style.animationDelay = (i * 0.2) + 's';
                    piece.style.borderRadius = '50%';
                    overlay.appendChild(piece);
                }
                
                document.body.style.animation = 'omnipotent-shake 7s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 7000);
            } else if (rarityName === 'Impossible') {
                // THE ULTIMATE IMPOSSIBLE ANIMATION - OPTIMIZED
                const ultimate = document.createElement('div');
                ultimate.style.position = 'absolute';
                ultimate.style.width = '100%';
                ultimate.style.height = '100%';
                ultimate.style.background = 'radial-gradient(circle, rgba(255,0,102,1), rgba(0,170,255,1), rgba(255,255,0,1))';
                ultimate.style.animation = 'impossible-ultimate 10s ease-out';
                overlay.appendChild(ultimate);
                
                // Add 30 particles instead of 100
                for (let i = 0; i < 30; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '20px';
                    particle.style.height = '20px';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.top = Math.random() * 100 + '%';
                    particle.style.background = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    particle.style.animation = 'impossible-ultimate 10s ease-out';
                    particle.style.animationDelay = (Math.random() * 2) + 's';
                    particle.style.borderRadius = '50%';
                    overlay.appendChild(particle);
                }
                
                document.body.style.animation = 'impossible-ultimate 10s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 10000);
            } else if (rarityName === 'Paradox') {
                // Reality breaks - impossible contradictions
                const paradox = document.createElement('div');
                paradox.style.position = 'absolute';
                paradox.style.width = '100%';
                paradox.style.height = '100%';
                paradox.style.background = 'linear-gradient(45deg, rgba(0,255,153,0.8), rgba(255,0,153,0.8))';
                paradox.style.animation = 'paradox-break 12s ease-out';
                overlay.appendChild(paradox);
                
                document.body.style.animation = 'paradox-break 12s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 12000);
            } else if (rarityName === 'Singularity') {
                // Black hole collapse - everything to a point
                const singularity = document.createElement('div');
                singularity.style.position = 'absolute';
                singularity.style.width = '500px';
                singularity.style.height = '500px';
                singularity.style.left = '50%';
                singularity.style.top = '50%';
                singularity.style.transform = 'translate(-50%, -50%)';
                singularity.style.background = 'radial-gradient(circle, rgba(153,0,255,1), rgba(0,0,0,0.9))';
                singularity.style.borderRadius = '50%';
                singularity.style.animation = 'singularity-collapse 14s ease-out';
                overlay.appendChild(singularity);
                
                document.body.style.animation = 'omnipotent-shake 14s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 14000);
            } else if (rarityName === 'Void') {
                // Consume everything into darkness
                const voidDiv = document.createElement('div');
                voidDiv.style.position = 'absolute';
                voidDiv.style.width = '100%';
                voidDiv.style.height = '100%';
                voidDiv.style.animation = 'void-consume 16s ease-out';
                overlay.appendChild(voidDiv);
                
                document.body.style.animation = 'void-consume 16s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 16000);
            } else if (rarityName === 'Nothingness') {
                // Erase reality itself
                const nothing = document.createElement('div');
                nothing.style.position = 'absolute';
                nothing.style.width = '100%';
                nothing.style.height = '100%';
                nothing.style.background = 'rgba(17,17,17,0.95)';
                nothing.style.animation = 'nothingness-erase 18s ease-out';
                overlay.appendChild(nothing);
                
                document.body.style.animation = 'nothingness-erase 18s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 18000);
            } else if (rarityName === 'Everything') {
                // Create an entire universe - OPTIMIZED
                const everything = document.createElement('div');
                everything.style.position = 'absolute';
                everything.style.width = '100px';
                everything.style.height = '100px';
                everything.style.left = '50%';
                everything.style.top = '50%';
                everything.style.transform = 'translate(-50%, -50%)';
                everything.style.background = 'radial-gradient(circle, rgba(255,255,255,1), rgba(255,255,0,0.8), rgba(0,255,255,0.6))';
                everything.style.borderRadius = '50%';
                everything.style.animation = 'everything-create 20s ease-out';
                overlay.appendChild(everything);
                
                // Add 50 creation particles instead of 200
                for (let i = 0; i < 50; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '15px';
                    particle.style.height = '15px';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.top = Math.random() * 100 + '%';
                    particle.style.background = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    particle.style.animation = 'everything-create 20s ease-out';
                    particle.style.animationDelay = (Math.random() * 5) + 's';
                    particle.style.borderRadius = '50%';
                    overlay.appendChild(particle);
                }
                
                document.body.style.animation = 'omnipotent-shake 20s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 20000);
            } else if (rarityName === 'The End') {
                // Time stops
                const end = document.createElement('div');
                end.style.position = 'absolute';
                end.style.width = '100%';
                end.style.height = '100%';
                end.style.background = 'rgba(255,0,0,0.3)';
                end.style.animation = 'end-timestop 25s ease-out';
                overlay.appendChild(end);
                
                document.body.style.animation = 'end-timestop 25s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 25000);
            } else if (rarityName === 'The Beginning') {
                // The Big Bang itself
                const beginning = document.createElement('div');
                beginning.style.position = 'absolute';
                beginning.style.width = '10px';
                beginning.style.height = '10px';
                beginning.style.left = '50%';
                beginning.style.top = '50%';
                beginning.style.transform = 'translate(-50%, -50%)';
                beginning.style.background = 'radial-gradient(circle, rgba(0,255,0,1), rgba(255,255,255,0.9))';
                beginning.style.borderRadius = '50%';
                beginning.style.animation = 'beginning-bigbang 30s ease-out';
                overlay.appendChild(beginning);
                
                document.body.style.animation = 'omnipotent-shake 30s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 30000);
            } else if (rarityName === 'Alpha Omega') {
                // Start and End merge
                const alphaomega = document.createElement('div');
                alphaomega.style.position = 'absolute';
                alphaomega.style.width = '100%';
                alphaomega.style.height = '100%';
                alphaomega.style.background = 'linear-gradient(90deg, rgba(255,255,0,0.8), rgba(0,0,0,0.8))';
                alphaomega.style.animation = 'alphaomega-merge 35s ease-out';
                overlay.appendChild(alphaomega);
                
                document.body.style.animation = 'alphaomega-merge 35s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 35000);
            } else if (rarityName === 'True Infinity') {
                // Endless recursion - OPTIMIZED
                const infinity = document.createElement('div');
                infinity.style.position = 'absolute';
                infinity.style.width = '200px';
                infinity.style.height = '200px';
                infinity.style.left = '50%';
                infinity.style.top = '50%';
                infinity.style.transform = 'translate(-50%, -50%)';
                infinity.style.background = 'radial-gradient(circle, rgba(255,0,255,1), transparent)';
                infinity.style.borderRadius = '50%';
                infinity.style.animation = 'infinity-recursion 40s ease-out';
                overlay.appendChild(infinity);
                
                // Add 20 recursive circles instead of 50
                for (let i = 0; i < 20; i++) {
                    const circle = document.createElement('div');
                    circle.style.position = 'absolute';
                    circle.style.width = (200 - i * 10) + 'px';
                    circle.style.height = (200 - i * 10) + 'px';
                    circle.style.left = '50%';
                    circle.style.top = '50%';
                    circle.style.transform = 'translate(-50%, -50%)';
                    circle.style.border = '2px solid rgba(255,0,255,0.5)';
                    circle.style.borderRadius = '50%';
                    circle.style.animation = 'infinity-recursion 40s ease-out';
                    circle.style.animationDelay = (i * 0.2) + 's';
                    overlay.appendChild(circle);
                }
                
                document.body.style.animation = 'infinity-recursion 40s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 40000);
            } else if (rarityName === 'The One') {
                // EXISTENCE ITSELF - THE ULTIMATE ULTIMATE - OPTIMIZED
                const theone = document.createElement('div');
                theone.style.position = 'absolute';
                theone.style.width = '100px';
                theone.style.height = '100px';
                theone.style.left = '50%';
                theone.style.top = '50%';
                theone.style.transform = 'translate(-50%, -50%)';
                theone.style.background = 'radial-gradient(circle, white, rgba(255,255,255,0))';
                theone.style.borderRadius = '50%';
                theone.style.boxShadow = '0 0 200px 100px white';
                theone.style.animation = 'theone-existence 30s ease-out';
                overlay.appendChild(theone);
                
                // Add 30 existence particles instead of 500
                for (let i = 0; i < 30; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '25px';
                    particle.style.height = '25px';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.top = Math.random() * 100 + '%';
                    particle.style.background = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    particle.style.animation = 'theone-existence 30s ease-out';
                    particle.style.animationDelay = (Math.random() * 5) + 's';
                    particle.style.borderRadius = '50%';
                    particle.style.boxShadow = `0 0 30px 15px hsl(${Math.random() * 360}, 100%, 50%)`;
                    overlay.appendChild(particle);
                }
                
                document.body.style.animation = 'theone-existence 30s ease-out';
                setTimeout(() => { document.body.style.animation = ''; }, 30000);
            }
            
            // Remove overlay after animation
            const duration = rarityName === 'The One' ? 30000 :
                           rarityName === 'True Infinity' ? 40000 :
                           rarityName === 'Alpha Omega' ? 35000 :
                           rarityName === 'The Beginning' ? 30000 :
                           rarityName === 'The End' ? 25000 :
                           rarityName === 'Everything' ? 20000 :
                           rarityName === 'Nothingness' ? 18000 :
                           rarityName === 'Void' ? 16000 :
                           rarityName === 'Singularity' ? 14000 :
                           rarityName === 'Paradox' ? 12000 :
                           rarityName === 'Impossible' ? 10000 : 
                           rarityName === 'Unimaginable' ? 7000 : 
                           rarityName === 'Incomprehensible' ? 6000 : 
                           rarityName === 'Beyond' ? 5000 : 
                           rarityName === 'Absolute' ? 4000 : 
                           rarityName === 'Limitless' ? 3000 :
                           rarityName === 'Boundless' ? 3000 :
                           rarityName === 'Transcendental' ? 3000 :
                           rarityName === 'Ascended' ? 3000 :
                           rarityName === 'Immortal' ? 3000 :
                           rarityName === 'Eternal' ? 3000 :
                           rarityName === 'Infinite Absolute' ? 3000 :
                           rarityName === 'Ethereal' || rarityName === 'Omega' || rarityName === 'Universal' ? 3000 : 
                           rarityName === 'Godlike' ? 2500 : 2000;
            
            setTimeout(() => {
                overlay.remove();
                
                // Show result display
                const rarity = rarities.find(r => r.name === rarityName);
                const chance = Math.round(1 / rarity.chance);
                
                // Special titles for ultra-rare items
                let title = 'üéâ ULTRA RARE PULL! üéâ';
                if (rarityName === 'The One') {
                    title = '‚≠ê EXISTENCE ITSELF ‚≠ê';
                } else if (rarityName === 'True Infinity') {
                    title = '‚ôæÔ∏è INFINITE POWER ‚ôæÔ∏è';
                } else if (rarityName === 'Alpha Omega') {
                    title = 'üåå BEGINNING AND END üåå';
                } else if (rarityName === 'The Beginning') {
                    title = 'üåÖ THE FIRST LIGHT üåÖ';
                } else if (rarityName === 'The End') {
                    title = 'üåë FINAL MOMENT üåë';
                } else if (rarityName === 'Everything') {
                    title = 'üåü UNIVERSE CREATED üåü';
                } else if (rarityName === 'Void') {
                    title = 'üñ§ CONSUMED BY VOID üñ§';
                } else if (rarityName === 'Impossible') {
                    title = '‚ùå IMPOSSIBILITY ACHIEVED ‚ùå';
                } else if (chance >= 1000000000) {
                    title = 'üíé LEGENDARY JACKPOT üíé';
                }
                
                const resultDiv = document.createElement('div');
                resultDiv.className = 'animation-result';
                resultDiv.style.cursor = 'pointer';
                resultDiv.innerHTML = `
                    <div class="animation-result-title">${title}</div>
                    <div class="animation-result-item" style="color: ${rarityColor};">${itemName}</div>
                    <div class="animation-result-rarity" style="color: ${rarityColor};">${rarityName}</div>
                    <div class="animation-result-chance">1 in ${formatNumber(chance)} chance</div>
                    <div style="margin-top: 20px; color: var(--accent-gold); font-size: 1.2rem;">Value: $${formatNumber(itemValue)}</div>
                    <div style="margin-top: 15px; color: var(--text-secondary); font-size: 0.9rem;">(Click to dismiss)</div>
                `;
                document.body.appendChild(resultDiv);
                
                // Click to dismiss
                const dismissResult = () => {
                    resultDiv.style.animation = 'resultFadeIn 0.5s ease-out reverse';
                    setTimeout(() => resultDiv.remove(), 500);
                };
                resultDiv.onclick = dismissResult;
            }, duration);
        }
        
        function generateItemName(rarity) {
            const namePool = itemNames[rarity.name] || itemNames['Common'];
            const prefix = namePool.prefixes[Math.floor(Math.random() * namePool.prefixes.length)];
            const item = namePool.items[Math.floor(Math.random() * namePool.items.length)];
            return `${prefix} ${item}`;
        }
        
        function addItemToInventory(name, rarity) {
            let value = Math.floor(Math.random() * (rarity.maxValue - rarity.minValue + 1)) + rarity.minValue;
            
            // Apply valueBoost upgrade
            if (gameState.upgrades.valueBoost > 0) {
                const boostMultiplier = 1 + (gameState.upgrades.valueBoost * 0.05); // 5% per level
                value = Math.floor(value * boostMultiplier);
            }
            
            const fullName = `${name} (${rarity.name})`;
            
            if (gameState.inventory[fullName]) {
                gameState.inventory[fullName].count++;
            } else {
                gameState.inventory[fullName] = {
                    name: name,
                    rarity: rarity.name,
                    color: rarity.color,
                    value: value,
                    count: 1
                };
            }
            
            gameState.totalValue += value;
            
            // Trigger ultra-rare animation for Cosmic and beyond (1 in 1024+)
            const rarityIndex = rarities.findIndex(r => r.name === rarity.name);
            if (rarityIndex >= 9) { // Index 9 is Cosmic
                triggerUltraRareAnimation(rarity.name, rarity.color, name, value);
            }
            
            // Display result
            const resultDiv = document.getElementById('resultDisplay');
            resultDiv.innerHTML = `
                <div class="item-display" style="background: ${rarity.color}; color: ${rarity.name === 'Common' ? 'black' : 'white'};">
                    ${fullName}
                </div>
                <div style="color: var(--accent-gold); font-size: 1.2rem; margin-top: 10px;">
                    Value: $${formatNumber(value)}
                </div>
                <div style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 5px;">
                    Chance: 1 in ${formatNumber(Math.round(1/rarities.find(r => r.name === rarity.name).chance))}
                </div>
            `;
            
            showNotification(`You got: ${fullName}!`, rarity.color);
        }
        
        function updateStats() {
            document.getElementById('money').textContent = '$' + formatNumber(gameState.money);
            document.getElementById('totalValue').textContent = '$' + formatNumber(gameState.totalValue);
            document.getElementById('totalSpins').textContent = formatNumber(gameState.totalSpins);
            const combinedLuck = gameState.luckMultiplier * gameState.permanentLuckBoost;
            document.getElementById('luckMultiplier').textContent = combinedLuck.toFixed(1) + 'x';
            document.getElementById('tradeWins').textContent = formatNumber(gameState.tradeWins);
        }
        
        function updateInventory() {
            const grid = document.getElementById('inventoryGrid');
            grid.innerHTML = '';
            
            for (const [key, item] of Object.entries(gameState.inventory)) {
                if (item.count > 0) {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'inventory-item' + (gameState.flexedItem === key ? ' flexed' : '');
                    itemDiv.style.borderColor = item.color;
                    itemDiv.onclick = () => flexItem(key);
                    itemDiv.oncontextmenu = (e) => {
                        e.preventDefault();
                        sellItem(key);
                    };
                    
                    // Show enchantments if present
                    let enchantDisplay = '';
                    if (item.enchantments && item.enchantments.length > 0) {
                        const enchantList = item.enchantments.map(e => {
                            const enchantData = enchantments[e];
                            const color = enchantData.type === 'ultimate' ? '#ff00ff' : 
                                         enchantData.type === 'godly' ? 'var(--accent-gold)' : 
                                         enchantData.type === 'bad' ? 'var(--danger)' : 
                                         'var(--accent-primary)';
                            return `<span style="color: ${color};">‚ú®${e}</span>`;
                        }).join(' ');
                        enchantDisplay = `<div style="font-size: 0.65rem; margin-top: 3px;">${enchantList}</div>`;
                    }
                    
                    itemDiv.innerHTML = `
                        ${item.count > 1 ? `<div class="item-count">${item.count}</div>` : ''}
                        <div style="font-size: 2rem;">üíé</div>
                        <div class="item-name" style="color: ${item.color};">${item.name}</div>
                        <div style="font-size: 0.8rem; color: ${item.color};">${item.rarity}</div>
                        <div class="item-value">$${formatNumber(item.value)}</div>
                        ${enchantDisplay}
                        <div style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 5px;">Right-click to sell</div>
                    `;
                    grid.appendChild(itemDiv);
                }
            }
        }
        
        function sellItem(itemKey) {
            const item = gameState.inventory[itemKey];
            if (!item || item.count === 0) return;
            
            let sellMultiplier = 0.7; // Base 70% sell value
            let hasEventStarter = false;
            
            // Check for enchantments that affect selling
            if (item.enchantments && item.enchantments.length > 0) {
                for (const enchantName of item.enchantments) {
                    const enchantData = enchantments[enchantName];
                    if (enchantData && enchantData.effect.sellMultiplier) {
                        sellMultiplier *= enchantData.effect.sellMultiplier;
                    }
                    if (enchantData && enchantData.effect.eventStarter) {
                        hasEventStarter = true;
                    }
                }
            }
            
            // Apply sell price upgrade
            if (gameState.upgrades.sellPrice > 0) {
                sellMultiplier *= (1 + gameState.upgrades.sellPrice * 0.02); // +2% per level
            }
            
            const sellPrice = Math.floor(item.value * sellMultiplier);
            gameState.money += sellPrice;
            gameState.totalValue -= item.value;
            item.count--;
            
            // Track money earned for quests
            updateQuestProgress('moneyEarned', sellPrice);
            
            if (gameState.flexedItem === itemKey && item.count === 0) {
                gameState.flexedItem = null;
            }
            
            // Trigger Event Starter effect
            if (hasEventStarter && !gameState.weatherEvent) {
                const events = ['cloudy', 'rainy', 'storming'];
                const selectedEvent = events[Math.floor(Math.random() * events.length)];
                startWeatherEvent(selectedEvent);
                showNotification(`üåü Event Starter activated! ${selectedEvent.toUpperCase()} event started!`, '#00aaff');
            }
            
            showNotification(`Sold for $${formatNumber(sellPrice)}!`, 'var(--success)');
            updateStats();
            updateInventory();
        }
        
        function flexItem(itemKey) {
            if (gameState.flexedItem === itemKey) {
                gameState.flexedItem = null;
                showNotification('Stopped flexing item', 'var(--text-secondary)');
            } else {
                gameState.flexedItem = itemKey;
                showNotification(`Now flexing: ${itemKey}!`, gameState.inventory[itemKey].color);
            }
            updateInventory();
        }
        
        function startAutoTrading() {
            if (gameState.tradeTimer) {
                clearInterval(gameState.tradeTimer);
            }
            
            // Generate initial trade
            setTimeout(generateNPCTrade, 5000);
            
            // Set up automatic trade generation
            gameState.tradeTimer = setInterval(() => {
                // More trades appear with higher wealth (adjusted thresholds)
                const baseInterval = 15000; // 15 seconds base
                const wealthFactor = Math.min(gameState.totalValue / 5000, 0.8); // Adjusted from 100000 to 5000, up to 80% faster
                const popularityBonus = gameState.upgrades.popularity * 0.15; // 15% more trades per level
                const actualInterval = baseInterval * (1 - wealthFactor);
                
                // Chance to spawn multiple trades for rich players and with popularity upgrade (adjusted threshold)
                const maxTrades = Math.min(Math.floor(gameState.totalValue / 2500) + 1 + Math.floor(popularityBonus * 3), 6); // Adjusted from 50000 to 2500
                const tradesToSpawn = Math.floor(Math.random() * maxTrades) + 1;
                
                for (let i = 0; i < tradesToSpawn; i++) {
                    setTimeout(() => generateNPCTrade(), i * 1000);
                }
            }, 20000); // Check every 20 seconds
        }
        
        function generateNPCTrade() {
            const inventoryKeys = Object.keys(gameState.inventory).filter(key => gameState.inventory[key].count > 0);
            if (inventoryKeys.length === 0) return;
            
            // Prioritize higher rarity items (weighted selection)
            const weightedItems = [];
            inventoryKeys.forEach(key => {
                const item = gameState.inventory[key];
                const rarityIndex = rarities.findIndex(r => r.name === item.rarity);
                // Higher rarity = more weight (multiply by rarity index + 1)
                let weight = Math.max(1, rarityIndex);
                
                // Check for Traders Dream enchant - increases trade attraction
                if (item.enchantments && item.enchantments.length > 0) {
                    for (const enchantName of item.enchantments) {
                        const enchantData = enchantments[enchantName];
                        if (enchantData && enchantData.effect.tradeAttraction) {
                            weight *= enchantData.effect.tradeAttraction;
                        }
                    }
                }
                
                for (let i = 0; i < Math.floor(weight); i++) {
                    weightedItems.push(key);
                }
            });
            
            const yourItemKey = weightedItems[Math.floor(Math.random() * weightedItems.length)];
            const yourItem = gameState.inventory[yourItemKey];
            
            // Check for Chaotics Thoughts enchant to block scammers
            let blockScammers = false;
            if (yourItem.enchantments && yourItem.enchantments.length > 0) {
                for (const enchantName of yourItem.enchantments) {
                    const enchantData = enchantments[enchantName];
                    if (enchantData && enchantData.effect.scammerBlock) {
                        blockScammers = true;
                        break;
                    }
                }
            }
            
            // Higher value items attract more scammers
            let npcType;
            if (blockScammers) {
                // Chaotics Thoughts blocks scammers
                npcType = Math.random() < 0.5 ? 'honest' : 'fair';
            } else if (yourItem.value > 500) { // Adjusted from 10000 to 500
                const roll = Math.random();
                if (roll < 0.5) npcType = 'scammer';
                else if (roll < 0.8) npcType = 'fair';
                else npcType = 'honest';
            } else {
                const roll = Math.random();
                if (roll < 0.2) npcType = 'scammer';
                else if (roll < 0.6) npcType = 'fair';
                else npcType = 'honest';
            }
            
            const npcName = npcNames[Math.floor(Math.random() * npcNames.length)];
            
            // Generate offer item
            let offerValue;
            if (npcType === 'honest') {
                offerValue = yourItem.value * (1.1 + Math.random() * 0.3); // 110-140% value
            } else if (npcType === 'fair') {
                offerValue = yourItem.value * (0.95 + Math.random() * 0.15); // 95-110% value
            } else {
                offerValue = yourItem.value * (0.3 + Math.random() * 0.5); // 30-80% value
            }
            
            // Find a rarity tier for the offer based on value
            let offerRarity = rarities[0];
            for (let i = rarities.length - 1; i >= 0; i--) {
                if (offerValue >= rarities[i].minValue && offerValue <= rarities[i].maxValue) {
                    offerRarity = rarities[i];
                    break;
                }
            }
            
            const offerItemName = generateItemName(offerRarity);
            offerValue = Math.floor(offerValue);
            
            // Create trade object
            const trade = {
                id: Date.now() + Math.random(),
                npcName,
                npcType,
                yourItemKey,
                yourItem: { ...yourItem },
                offerItem: {
                    name: offerItemName,
                    rarity: offerRarity.name,
                    color: offerRarity.color,
                    value: offerValue
                }
            };
            
            gameState.activeTrades.push(trade);
            displayTrade(trade);
        }
        
        function displayTrade(trade) {
            const container = document.getElementById('npcContainer');
            
            // Show popup notification for new trade
            showNotification(`üíº ${trade.npcName} wants to trade!`, 'var(--accent-primary)');
            
            const insightLevel = gameState.upgrades.tradeInsight;
            let yourValueDisplay = '<div style="color: var(--text-secondary); font-size: 0.8rem; margin-top: 5px;">‚ùì Unknown Value ‚ùì</div>';
            let offerValueDisplay = '<div style="color: var(--text-secondary); font-size: 0.8rem; margin-top: 5px;">‚ùì Unknown Value ‚ùì</div>';
            let tradeQualityDisplay = '';
            
            if (insightLevel >= 3) {
                // Show both values
                yourValueDisplay = `<div style="color: var(--accent-gold); font-size: 0.8rem; margin-top: 5px;">$${formatNumber(trade.yourItem.value)}</div>`;
                offerValueDisplay = `<div style="color: var(--accent-gold); font-size: 0.8rem; margin-top: 5px;">$${formatNumber(trade.offerItem.value)}</div>`;
            }
            
            if (insightLevel >= 1) {
                const diff = trade.offerItem.value - trade.yourItem.value;
                if (insightLevel === 1) {
                    // Show quality indicator
                    if (diff > 0) tradeQualityDisplay = '<div style="color: var(--success); margin-top: 10px;">‚úÖ Good Trade</div>';
                    else if (diff < 0) tradeQualityDisplay = '<div style="color: var(--danger); margin-top: 10px;">‚ö†Ô∏è Bad Trade</div>';
                    else tradeQualityDisplay = '<div style="color: var(--warning); margin-top: 10px;">‚öñÔ∏è Fair Trade</div>';
                } else if (insightLevel >= 2) {
                    // Show exact difference
                    if (diff > 0) tradeQualityDisplay = `<div style="color: var(--success); margin-top: 10px;">+$${formatNumber(diff)}</div>`;
                    else if (diff < 0) tradeQualityDisplay = `<div style="color: var(--danger); margin-top: 10px;">-$${formatNumber(Math.abs(diff))}</div>`;
                    else tradeQualityDisplay = '<div style="color: var(--warning); margin-top: 10px;">¬±$0</div>';
                }
            }
            
            const npcDiv = document.createElement('div');
            npcDiv.className = 'npc-card';
            npcDiv.setAttribute('data-trade-id', trade.id);
            npcDiv.innerHTML = `
                <div class="npc-header">
                    <div class="npc-name">${trade.npcName}</div>
                    <div style="color: var(--text-secondary); font-size: 0.8rem;">Expires in 30s</div>
                </div>
                <div class="trade-offer">
                    <div>
                        <div style="color: var(--text-secondary); margin-bottom: 5px;">You Give:</div>
                        <div style="color: ${trade.yourItem.color}; font-weight: bold; font-size: 1.1rem;">${trade.yourItem.name}</div>
                        <div style="color: ${trade.yourItem.color}; font-size: 0.9rem;">${trade.yourItem.rarity}</div>
                        ${yourValueDisplay}
                    </div>
                    <div style="font-size: 2rem;">‚ÜîÔ∏è</div>
                    <div>
                        <div style="color: var(--text-secondary); margin-bottom: 5px;">You Get:</div>
                        <div style="color: ${trade.offerItem.color}; font-weight: bold; font-size: 1.1rem;">${trade.offerItem.name}</div>
                        <div style="color: ${trade.offerItem.color}; font-size: 0.9rem;">${trade.offerItem.rarity}</div>
                        ${offerValueDisplay}
                    </div>
                </div>
                ${tradeQualityDisplay}
                <div class="trade-buttons">
                    <button class="btn btn-accept" onclick="acceptTrade(${trade.id})">Accept Trade</button>
                    <button class="btn btn-decline" onclick="declineTrade(${trade.id})">Decline</button>
                </div>
            `;
            
            // Add to top of container
            container.insertBefore(npcDiv, container.firstChild);
            
            // Auto-remove after 30 seconds
            setTimeout(() => {
                const element = document.querySelector(`[data-trade-id="${trade.id}"]`);
                if (element) {
                    showNotification(`Trade with ${trade.npcName} expired!`, 'var(--text-secondary)');
                    element.style.animation = 'slideIn 0.5s ease-out reverse';
                    setTimeout(() => {
                        element.remove();
                        gameState.activeTrades = gameState.activeTrades.filter(t => t.id !== trade.id);
                    }, 500);
                }
            }, 30000);
        }
        
        function acceptTrade(tradeId) {
            const trade = gameState.activeTrades.find(t => t.id === tradeId);
            if (!trade) return;
            
            const item = gameState.inventory[trade.yourItemKey];
            if (!item || item.count === 0) {
                showNotification('Item no longer available!', 'var(--danger)');
                declineTrade(tradeId);
                return;
            }
            
            // Remove your item
            item.count--;
            gameState.totalValue -= trade.yourItem.value;
            
            // Add received item
            const receivedFullName = `${trade.offerItem.name} (${trade.offerItem.rarity})`;
            if (gameState.inventory[receivedFullName]) {
                gameState.inventory[receivedFullName].count++;
            } else {
                gameState.inventory[receivedFullName] = {
                    name: trade.offerItem.name,
                    rarity: trade.offerItem.rarity,
                    color: trade.offerItem.color,
                    value: trade.offerItem.value,
                    count: 1
                };
            }
            gameState.totalValue += trade.offerItem.value;
            
            // Determine if it was a good trade
            const valueDiff = trade.offerItem.value - trade.yourItem.value;
            if (valueDiff > 0) {
                gameState.tradeWins++;
                updateQuestProgress('tradeWins', 1);
                showNotification(`Great trade! Gained $${formatNumber(valueDiff)} value! üìà`, 'var(--success)');
            } else if (valueDiff < 0) {
                gameState.tradeLosses++;
                showNotification(`Bad trade! Lost $${formatNumber(Math.abs(valueDiff))} value! üìâ`, 'var(--danger)');
            } else {
                showNotification('Fair trade! Same value üìä', 'var(--warning)');
            }
            
            gameState.battlePassXP += 5;
            updateStats();
            updateInventory();
            updateBattlePass();
            checkAchievements();
            
            declineTrade(tradeId);
        }
        
        function declineTrade(tradeId) {
            const element = document.querySelector(`[data-trade-id="${tradeId}"]`);
            if (element) {
                element.style.animation = 'slideIn 0.5s ease-out reverse';
                setTimeout(() => element.remove(), 500);
            }
            gameState.activeTrades = gameState.activeTrades.filter(t => t.id !== tradeId);
        }
        
        function initCrafting() {
            const grid = document.getElementById('craftingGrid');
            recipes.forEach(recipe => {
                const canCraft = Object.entries(recipe.requires).every(([rarity, count]) => {
                    return Object.values(gameState.inventory).filter(item => 
                        item.rarity === rarity && item.count > 0
                    ).length >= count;
                });
                
                const recipeDiv = document.createElement('div');
                recipeDiv.className = 'recipe-card';
                recipeDiv.innerHTML = `
                    <h3 style="color: var(--accent-primary);">${recipe.name}</h3>
                    <div class="recipe-requirements">
                        <div style="color: var(--text-secondary); margin-bottom: 10px;">Requires:</div>
                        ${Object.entries(recipe.requires).map(([rarity, count]) => 
                            `<div>${count}x ${rarity} items</div>`
                        ).join('')}
                    </div>
                    <div style="margin: 10px 0;">
                        <div style="color: var(--accent-gold);">Creates: ${recipe.result}</div>
                        <div style="color: var(--success);">Value: $${formatNumber(recipe.value)}</div>
                    </div>
                    <button class="btn btn-accept" ${!canCraft ? 'disabled' : ''} 
                            onclick="craftItem('${recipe.name}')" 
                            style="${!canCraft ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
                        Craft
                    </button>
                `;
                grid.appendChild(recipeDiv);
            });
        }
        
        function craftItem(recipeName) {
            const recipe = recipes.find(r => r.name === recipeName);
            if (!recipe) return;
            
            // Remove required items
            for (const [rarity, count] of Object.entries(recipe.requires)) {
                let removed = 0;
                for (const [key, item] of Object.entries(gameState.inventory)) {
                    if (item.rarity === rarity && item.count > 0 && removed < count) {
                        const toRemove = Math.min(item.count, count - removed);
                        item.count -= toRemove;
                        gameState.totalValue -= item.value * toRemove;
                        removed += toRemove;
                    }
                }
            }
            
            // Check for Crafting Merger enchants in inventory
            let craftDupeChance = 0;
            for (const [key, item] of Object.entries(gameState.inventory)) {
                if (item.enchantments && item.count > 0) {
                    for (const enchantName of item.enchantments) {
                        const enchantData = enchantments[enchantName];
                        if (enchantData && enchantData.effect.craftDupeChance) {
                            craftDupeChance = Math.max(craftDupeChance, enchantData.effect.craftDupeChance);
                        }
                    }
                }
            }
            
            // Add crafted item
            const rarity = rarities.find(r => r.name === recipe.result);
            
            if (!rarity) {
                showNotification('Error: Invalid recipe rarity!', 'var(--danger)');
                return;
            }
            
            let craftValue = recipe.value;
            
            // Apply craftingMastery upgrade - increases craft output value
            if (gameState.upgrades.craftingMastery > 0) {
                const masteryBonus = 1 + (gameState.upgrades.craftingMastery * 0.02); // 2% per level
                craftValue = Math.floor(craftValue * masteryBonus);
            }
            
            addItemToInventory(recipe.name, { ...rarity, minValue: craftValue, maxValue: craftValue });
            
            // Try to duplicate with Crafting Merger
            if (craftDupeChance > 0 && Math.random() < craftDupeChance) {
                addItemToInventory(recipe.name, { ...rarity, minValue: craftValue, maxValue: craftValue });
                showNotification(`üî® Crafting Merger! Duplicated craft!`, 'var(--accent-gold)');
            }
            
            gameState.craftCount = (gameState.craftCount || 0) + 1;
            gameState.battlePassXP += 20;
            
            // Update quests
            updateQuestProgress('crafts', 1);
            
            showNotification(`Crafted: ${recipe.name}!`, rarity.color);
            updateStats();
            updateInventory();
            updateBattlePass();
            checkAchievements();
            
            // Refresh crafting UI
            document.getElementById('craftingGrid').innerHTML = '';
            initCrafting();
        }
        
        function initShop() {
            const grid = document.getElementById('shopGrid');
            grid.innerHTML = '';
            
            // Generate shop items for each rarity (expanded to 20)
            const shopRarities = rarities.slice(0, 20); // Common to Primordial
            
            shopRarities.forEach(rarity => {
                const itemName = generateItemName(rarity);
                const baseValue = (rarity.minValue + rarity.maxValue) / 2;
                const shopPrice = Math.floor(baseValue * 1.5); // 50% markup
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'inventory-item';
                itemDiv.style.borderColor = rarity.color;
                itemDiv.innerHTML = `
                    <div style="font-size: 2rem;">üè™</div>
                    <div class="item-name" style="color: ${rarity.color};">${itemName}</div>
                    <div style="font-size: 0.8rem; color: ${rarity.color};">${rarity.name}</div>
                    <div class="item-value">$${formatNumber(shopPrice)}</div>
                    <button class="btn btn-accept" style="margin-top: 10px; padding: 8px 15px; font-size: 0.8rem;" 
                            onclick="buyItem('${itemName}', '${rarity.name}', '${rarity.color}', ${Math.floor(baseValue)}, ${shopPrice})"
                            ${gameState.money < shopPrice ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
                        Buy
                    </button>
                `;
                grid.appendChild(itemDiv);
            });
        }
        
        function buyItem(name, rarityName, color, value, price) {
            if (gameState.money < price) {
                showNotification('Not enough money!', 'var(--danger)');
                return;
            }
            
            gameState.money -= price;
            
            const fullName = `${name} (${rarityName})`;
            if (gameState.inventory[fullName]) {
                gameState.inventory[fullName].count++;
            } else {
                gameState.inventory[fullName] = {
                    name: name,
                    rarity: rarityName,
                    color: color,
                    value: value,
                    count: 1
                };
            }
            gameState.totalValue += value;
            gameState.shopPurchases = (gameState.shopPurchases || 0) + 1;
            
            // Update quests
            updateQuestProgress('shopBuys', 1);
            
            showNotification(`Purchased: ${name}!`, color);
            updateStats();
            updateInventory();
            initShop(); // Refresh shop to update buy buttons
            checkAchievements();
        }
        
        function updateEnchantInventory() {
            const grid = document.getElementById('enchantInventoryGrid');
            grid.innerHTML = '';
            
            // Only show Divine (index 8) and higher rarities
            const divineIndex = rarities.findIndex(r => r.name === 'Divine');
            
            let hasEligibleItems = false;
            for (const [key, item] of Object.entries(gameState.inventory)) {
                if (item.count > 0) {
                    const itemRarityIndex = rarities.findIndex(r => r.name === item.rarity);
                    if (itemRarityIndex >= divineIndex) {
                        hasEligibleItems = true;
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'inventory-item';
                        itemDiv.style.borderColor = item.color;
                        itemDiv.onclick = () => selectItemForEnchant(key);
                        
                        // Show existing enchantments
                        const enchantDisplay = item.enchantments && item.enchantments.length > 0 
                            ? `<div style="font-size: 0.7rem; color: var(--accent-gold); margin-top: 3px;">${item.enchantments.join(', ')}</div>` 
                            : '';
                        
                        itemDiv.innerHTML = `
                            ${item.count > 1 ? `<div class="item-count">${item.count}</div>` : ''}
                            <div style="font-size: 2rem;">‚ú®</div>
                            <div class="item-name" style="color: ${item.color};">${item.name}</div>
                            <div style="font-size: 0.8rem; color: ${item.color};">${item.rarity}</div>
                            <div class="item-value">$${formatNumber(item.value)}</div>
                            ${enchantDisplay}
                        `;
                        grid.appendChild(itemDiv);
                    }
                }
            }
            
            if (!hasEligibleItems) {
                grid.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">No Divine or higher rarity items available for enchanting.</p>';
            }
        }
        
        function initUpgrades() {
            const grid = document.getElementById('upgradesGrid');
            grid.innerHTML = '';
            
            for (const [key, data] of Object.entries(upgradeData)) {
                const currentLevel = gameState.upgrades[key];
                const cost = Math.floor(data.baseCost * Math.pow(data.costMultiplier, currentLevel));
                const canAfford = gameState.money >= cost;
                const isMaxed = currentLevel >= data.maxLevel;
                
                const upgradeDiv = document.createElement('div');
                upgradeDiv.className = 'recipe-card';
                upgradeDiv.innerHTML = `
                    <h3 style="color: var(--accent-primary);">${data.name}</h3>
                    <p style="color: var(--text-secondary); margin: 10px 0;">${data.description}</p>
                    <div class="recipe-requirements">
                        <div style="color: var(--accent-gold); font-weight: bold;">Level: ${currentLevel}/${data.maxLevel}</div>
                        <div style="color: var(--accent-primary); margin-top: 5px;">${data.effect(currentLevel)}</div>
                        ${!isMaxed ? `<div style="color: var(--warning); margin-top: 10px;">Next: ${data.effect(currentLevel + 1)}</div>` : ''}
                    </div>
                    <div style="margin: 10px 0;">
                        <div style="color: var(--accent-gold);">Cost: $${formatNumber(cost)}</div>
                    </div>
                    <button class="btn btn-accept" 
                            ${!canAfford || isMaxed ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}
                            onclick="purchaseUpgrade('${key}')">
                        ${isMaxed ? 'MAXED' : 'Upgrade'}
                    </button>
                `;
                grid.appendChild(upgradeDiv);
            }
        }
        
        function purchaseUpgrade(upgradeKey) {
            const data = upgradeData[upgradeKey];
            const currentLevel = gameState.upgrades[upgradeKey];
            
            if (currentLevel >= data.maxLevel) {
                showNotification('Already at max level!', 'var(--warning)');
                return;
            }
            
            const cost = Math.floor(data.baseCost * Math.pow(data.costMultiplier, currentLevel));
            
            if (gameState.money < cost) {
                showNotification('Not enough money!', 'var(--danger)');
                return;
            }
            
            gameState.money -= cost;
            gameState.upgrades[upgradeKey]++;
            
            // Apply upgrade effects
            if (upgradeKey === 'luckBoost') {
                gameState.luckMultiplier += 0.1;
            } else if (upgradeKey === 'autoSpin' && gameState.upgrades[upgradeKey] === 1) {
                startAutoSpin();
            }
            
            showNotification(`Upgraded ${data.name} to level ${gameState.upgrades[upgradeKey]}!`, 'var(--success)');
            updateStats();
            initUpgrades();
        }
        
        function selectItemForEnchant(itemKey) {
            const item = gameState.inventory[itemKey];
            if (!item || item.count === 0) {
                showNotification('Item no longer available!', 'var(--danger)');
                return;
            }
            
            gameState.enchantmentTarget = itemKey;
            
            const slot = document.getElementById('selectedEnchantItem');
            slot.innerHTML = `
                <strong style="color: ${item.color};">${item.name}</strong><br>
                <span style="color: ${item.color}; font-size: 0.9rem;">${item.rarity}</span><br>
                <span style="color: var(--accent-gold);">$${formatNumber(item.value)}</span>
            `;
            
            document.getElementById('enchantmentInterface').style.display = 'block';
        }
        
        function enchantItem() {
            if (!gameState.enchantmentTarget) {
                showNotification('Select an item first!', 'var(--danger)');
                return;
            }
            
            const item = gameState.inventory[gameState.enchantmentTarget];
            if (!item || item.count === 0) {
                showNotification('Item no longer available!', 'var(--danger)');
                gameState.enchantmentTarget = null;
                document.getElementById('enchantmentInterface').style.display = 'none';
                return;
            }
            
            // Check if item is Divine or higher
            const divineIndex = rarities.findIndex(r => r.name === 'Divine');
            const itemRarityIndex = rarities.findIndex(r => r.name === item.rarity);
            if (itemRarityIndex < divineIndex) {
                showNotification('Item must be Divine or higher rarity!', 'var(--danger)');
                return;
            }
            
            // Initialize enchantments array if it doesn't exist
            if (!item.enchantments) {
                item.enchantments = [];
            }
            
            // Check if item already has an enchantment (limit to 1)
            if (item.enchantments.length > 0) {
                showNotification('‚ö†Ô∏è Item already has an enchantment! Items can only have ONE enchantment.', 'var(--warning)');
                return;
            }
            
            // Roll for enchantment
            const roll = Math.random();
            let selectedEnchant = null;
            let cumulativeChance = 0;
            
            // Shuffle enchantments for fairness
            const enchantKeys = Object.keys(enchantments);
            for (let i = enchantKeys.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [enchantKeys[i], enchantKeys[j]] = [enchantKeys[j], enchantKeys[i]];
            }
            
            // Apply enchantPower upgrade boost
            let luckBoost = 1.0;
            
            // Apply enchantPower upgrade
            if (gameState.upgrades.enchantPower > 0) {
                const upgradeLuckBoost = 1 + (gameState.upgrades.enchantPower * 0.1); // 10% per level
                luckBoost *= upgradeLuckBoost;
            }
            
            for (const enchantName of enchantKeys) {
                const enchant = enchantments[enchantName];
                cumulativeChance += enchant.chance * luckBoost;
                if (roll < cumulativeChance) {
                    selectedEnchant = { name: enchantName, data: enchant };
                    break;
                }
            }
            
            if (!selectedEnchant) {
                showNotification('Enchantment failed - no effect!', 'var(--warning)');
                gameState.enchantmentTarget = null;
                document.getElementById('enchantmentInterface').style.display = 'none';
                updateEnchantInventory();
                saveGame(true); // Auto-save
                return;
            }
            
            const enchantName = selectedEnchant.name;
            const enchantData = selectedEnchant.data;
            const effect = enchantData.effect;
            
            // Handle bad enchants
            if (enchantName === 'Too Much Energy' || enchantName === 'Too Little Energy') {
                gameState.totalValue -= item.value;
                item.count--;
                gameState.enchantFails = (gameState.enchantFails || 0) + 1;
                showNotification(`üíÄ ${enchantName}! Item DESTROYED! üíÄ`, 'var(--danger)');
                
                gameState.enchantmentTarget = null;
                document.getElementById('enchantmentInterface').style.display = 'none';
                updateStats();
                updateInventory();
                updateEnchantInventory();
                checkAchievements();
                saveGame(true); // Auto-save
                return;
            }
            
            // Handle Ditto enchant - copies random item
            if (enchantName.startsWith('Ditto')) {
                const inventoryKeys = Object.keys(gameState.inventory).filter(k => gameState.inventory[k].count > 0 && k !== gameState.enchantmentTarget);
                if (inventoryKeys.length > 0) {
                    const randomKey = inventoryKeys[Math.floor(Math.random() * inventoryKeys.length)];
                    const copiedItem = gameState.inventory[randomKey];
                    const newValue = Math.floor(copiedItem.value * effect.dittoCopy);
                    
                    // Add copied item to inventory
                    const newKey = `${copiedItem.name} (${copiedItem.rarity}) [Ditto Copy]`;
                    gameState.inventory[newKey] = {
                        name: `${copiedItem.name} [Ditto Copy]`,
                        rarity: copiedItem.rarity,
                        color: copiedItem.color,
                        value: newValue,
                        count: 1,
                        enchantments: []
                    };
                    gameState.totalValue += newValue;
                    
                    showNotification(`üé≠ ${enchantName}! Copied ${copiedItem.name} (+${((effect.dittoCopy - 1) * 100).toFixed(0)}% value)`, 'var(--warning)');
                } else {
                    showNotification(`üé≠ ${enchantName}! But no items to copy...`, 'var(--warning)');
                }
                
                gameState.enchantmentTarget = null;
                document.getElementById('enchantmentInterface').style.display = 'none';
                updateStats();
                updateInventory();
                updateEnchantInventory();
                saveGame(true); // Auto-save
                return;
            }
            
            // Apply good enchantments
            item.enchantments.push(enchantName);
            
            // Apply value multiplier if present
            if (effect.valueMultiplier) {
                const oldValue = item.value;
                item.value = Math.floor(item.value * effect.valueMultiplier);
                gameState.totalValue += (item.value - oldValue);
            }
            
            // Apply luck boost if present
            if (effect.luckBoost) {
                gameState.luckMultiplier += effect.luckBoost;
            }
            
            gameState.enchantSuccess = (gameState.enchantSuccess || 0) + 1;
            gameState.battlePassXP += 15;
            
            // Update quests
            updateQuestProgress('enchants', 1);
            
            const rarityColor = enchantData.type === 'ultimate' ? '#ff00ff' : 
                               enchantData.type === 'godly' ? 'var(--accent-gold)' : 
                               'var(--success)';
            
            showNotification(`‚ú® ${enchantName} applied! ‚ú®`, rarityColor);
            
            gameState.enchantmentTarget = null;
            document.getElementById('enchantmentInterface').style.display = 'none';
            
            updateStats();
            updateInventory();
            updateEnchantInventory();
            updateBattlePass();
            checkAchievements();
            saveGame(true); // Auto-save after enchant
        }
        
        function initAchievements() {
            const list = document.getElementById('achievementList');
            achievements.forEach(achievement => {
                const unlocked = gameState.achievements[achievement.id] || achievement.check();
                if (unlocked && !gameState.achievements[achievement.id]) {
                    gameState.achievements[achievement.id] = true;
                    // Grant rewards
                    if (achievement.id === 'first_spin') {
                        gameState.luckMultiplier += 0.1;
                    } else if (achievement.id === 'spin_master') {
                        gameState.luckMultiplier += 0.2;
                    } else if (achievement.id === 'spin_legend') {
                        gameState.luckMultiplier += 0.5;
                    } else if (achievement.id === 'spin_god') {
                        gameState.luckMultiplier += 1.0;
                    } else if (achievement.id === 'spin_master_100k') {
                        gameState.luckMultiplier += 2.0;
                    }
                    
                    // Show achievement notification if enabled
                    if (gameState.settings.showAchievementNotifications) {
                        showNotification(`üèÜ Achievement Unlocked: ${achievement.name}!`, 'var(--accent-gold)');
                    }
                }
                
                const achDiv = document.createElement('div');
                achDiv.className = 'achievement-card' + (unlocked ? ' unlocked' : '');
                achDiv.innerHTML = `
                    <div class="achievement-icon">${unlocked ? 'üèÜ' : 'üîí'}</div>
                    <h3 style="color: ${unlocked ? 'var(--accent-gold)' : 'var(--text-secondary)'};">${achievement.name}</h3>
                    <p style="color: var(--text-secondary); margin: 10px 0;">${achievement.desc}</p>
                    <div style="color: var(--accent-primary); font-weight: bold;">Reward: ${achievement.reward}</div>
                `;
                list.appendChild(achDiv);
            });
        }
        
        function checkAchievements() {
            const list = document.getElementById('achievementList');
            list.innerHTML = '';
            initAchievements();
        }
        
        
        function updateBattlePass() {
            const currentTier = battlePassTiers.findIndex(t => gameState.battlePassXP < t.xpRequired);
            const tierIndex = currentTier === -1 ? battlePassTiers.length : currentTier;
            
            // Initialize claimed tiers tracking
            if (!gameState.claimedBPTiers) {
                gameState.claimedBPTiers = [];
            }
            
            // Check for newly unlocked tiers and give rewards
            for (let i = 0; i < tierIndex; i++) {
                const tier = battlePassTiers[i];
                if (!gameState.claimedBPTiers.includes(tier.tier)) {
                    // Give reward
                    giveRewardFromTier(tier);
                    gameState.claimedBPTiers.push(tier.tier);
                }
            }
            
            // Calculate current tier properly
            let currentTierNum = 0;
            for (let i = 0; i < battlePassTiers.length; i++) {
                if (gameState.battlePassXP >= battlePassTiers[i].xpRequired) {
                    currentTierNum = battlePassTiers[i].tier;
                }
            }
            gameState.battlePassTier = currentTierNum;
            
            const progress = document.getElementById('bpProgress');
            const maxXP = battlePassTiers[battlePassTiers.length - 1].xpRequired;
            const percentage = Math.min((gameState.battlePassXP / maxXP) * 100, 100);
            progress.style.width = percentage + '%';
            progress.textContent = `Tier ${currentTierNum}/${battlePassTiers.length} (${formatNumber(gameState.battlePassXP)} XP)`;
            
            const tiersDiv = document.getElementById('bpTiers');
            tiersDiv.innerHTML = '';
            initBattlePass();
        }
        
        function giveRewardFromTier(tier) {
            const reward = tier.reward;
            
            // Rewards are crates - give items based on crate type
            if (reward.includes('Crate')) {
                const rarityName = reward.replace(' Crate', '');
                const rarity = rarities.find(r => r.name === rarityName);
                
                if (rarity) {
                    const itemName = generateItemName(rarity);
                    addItemToInventory(itemName, rarity);
                    showNotification(`üéÅ Battle Pass Tier ${tier.tier} Reward: ${itemName}!`, rarity.color);
                } else {
                    console.error(`Could not find rarity for: ${rarityName}`);
                    showNotification(`üéÅ Battle Pass Tier ${tier.tier} Unlocked: ${reward}!`, 'var(--accent-gold)');
                }
            } else {
                // Non-crate rewards (badges, titles, etc) - just notify
                showNotification(`üéÅ Battle Pass Tier ${tier.tier} Unlocked: ${reward}!`, 'var(--accent-gold)');
            }
            
            updateInventory();
            saveGame(true);
        }
        
        function checkChristmasEvent() {
            const now = new Date();
            const minutes = now.getMinutes();
            
            // Event happens at the hour mark (00-04 minutes)
            if (minutes < 5 && !gameState.christmasEvent) {
                gameState.christmasEvent = true;
                gameState.christmasEventEnd = new Date(now.getTime() + 5 * 60000); // 5 minutes
                showNotification('üéÑ CHRISTMAS EVENT STARTED! 5 minutes remaining! üéÖ', '#ff0000');
                updateEventBonuses();
            } else if (gameState.christmasEvent && now >= gameState.christmasEventEnd) {
                gameState.christmasEvent = false;
                gameState.christmasEventEnd = null;
                showNotification('üéÑ Christmas Event Ended! See you next hour! ‚ùÑÔ∏è', 'var(--text-secondary)');
                updateEventBonuses();
            }
        }
        
        function checkWeatherEvents() {
            const now = Date.now();
            
            // Check if current weather event has ended
            if (gameState.weatherEvent && gameState.weatherEventEnd && now >= gameState.weatherEventEnd) {
                const eventEmojis = { cloudy: '‚òÅÔ∏è', rainy: 'üåßÔ∏è', storming: '‚õàÔ∏è' };
                showNotification(`${eventEmojis[gameState.weatherEvent]} ${gameState.weatherEvent.toUpperCase()} Event Ended!`, 'var(--text-secondary)');
                gameState.weatherEvent = null;
                gameState.weatherEventEnd = null;
                updateEventBonuses();
            }
            
            // Try to start a new weather event (every 10 minutes)
            if (!gameState.weatherEvent && now - gameState.lastWeatherEvent >= 600000) { // 10 minutes
                if (Math.random() < 0.8) { // 80% chance to start event
                    const events = ['cloudy', 'rainy', 'storming'];
                    const selectedEvent = events[Math.floor(Math.random() * events.length)];
                    startWeatherEvent(selectedEvent);
                }
                gameState.lastWeatherEvent = now;
            }
        }
        
        function startWeatherEvent(eventType) {
            gameState.weatherEvent = eventType;
            gameState.weatherEventEnd = Date.now() + 60000; // 1 minute
            
            const eventNames = { cloudy: 'CLOUDY', rainy: 'RAINY', storming: 'STORMING' };
            const eventEmojis = { cloudy: '‚òÅÔ∏è', rainy: 'üåßÔ∏è', storming: '‚õàÔ∏è' };
            showNotification(`${eventEmojis[eventType]} ${eventNames[eventType]} EVENT STARTED! 1 minute!`, '#00aaff');
            updateEventBonuses();
        }
        
        function checkSpecialEvents() {
            const now = new Date();
            const minutes = now.getMinutes();
            const hours = now.getHours();
            
            // Check if current special event has ended
            if (gameState.specialEvent && gameState.specialEventEnd && Date.now() >= gameState.specialEventEnd) {
                const eventEmojis = { disco: 'ü™©', galactic: 'üåå', glitch: '‚ö°', fullmoon: 'üåï', bloodmoon: 'üî¥' };
                showNotification(`${eventEmojis[gameState.specialEvent]} ${gameState.specialEvent.toUpperCase()} Event Ended!`, 'var(--text-secondary)');
                gameState.specialEvent = null;
                gameState.specialEventEnd = null;
                updateEventBonuses();
            }
            
            // Don't start new event if one is active
            if (gameState.specialEvent) return;
            
            // Disco Event - Every hour at :15-:19 (5 minutes)
            if (minutes >= 15 && minutes < 20) {
                if (!gameState.specialEvent) {
                    startSpecialEvent('disco');
                }
            }
            // Galactic Event - Every hour at :30-:34 (5 minutes)
            else if (minutes >= 30 && minutes < 35) {
                if (!gameState.specialEvent) {
                    startSpecialEvent('galactic');
                }
            }
            // Glitch Event - Every hour at :45-:49 (5 minutes)
            else if (minutes >= 45 && minutes < 50) {
                if (!gameState.specialEvent) {
                    startSpecialEvent('glitch');
                }
            }
            // Full Moon Event - Every 2 hours at :20-:24 (5 minutes)
            else if (minutes >= 20 && minutes < 25 && hours % 2 === 0) {
                if (!gameState.specialEvent) {
                    startSpecialEvent('fullmoon');
                }
            }
            // Blood Moon Event - Every 3 hours at :50-:54 (5 minutes)
            else if (minutes >= 50 && minutes < 55 && hours % 3 === 0) {
                if (!gameState.specialEvent) {
                    startSpecialEvent('bloodmoon');
                }
            }
        }
        
        function startSpecialEvent(eventType) {
            gameState.specialEvent = eventType;
            gameState.specialEventEnd = Date.now() + 300000; // 5 minutes
            
            const eventNames = { 
                disco: 'DISCO ü™©', 
                galactic: 'GALACTIC üåå', 
                glitch: 'GLITCH ‚ö°', 
                fullmoon: 'FULL MOON üåï', 
                bloodmoon: 'BLOOD MOON üî¥' 
            };
            const eventColors = {
                disco: '#ff00ff',
                galactic: '#4B0082',
                glitch: '#00ff00',
                fullmoon: '#f0f0f0',
                bloodmoon: '#8B0000'
            };
            showNotification(`‚ú® ${eventNames[eventType]} EVENT STARTED! 5 minutes! ‚ú®`, eventColors[eventType]);
            updateEventBonuses();
        }
        
        function sellAllItems() {
            if (!confirm('Are you sure you want to sell ALL items for 70% of their value?')) {
                return;
            }
            
            let totalSellValue = 0;
            let itemCount = 0;
            
            for (const [key, item] of Object.entries(gameState.inventory)) {
                if (item.count > 0) {
                    const sellValue = Math.floor(item.value * 0.7 * item.count);
                    totalSellValue += sellValue;
                    itemCount += item.count;
                    gameState.totalValue -= item.value * item.count;
                    item.count = 0;
                }
            }
            
            gameState.money += totalSellValue;
            gameState.flexedItem = null;
            
            showNotification(`Sold ${itemCount} items for $${formatNumber(totalSellValue)}!`, 'var(--success)');
            updateStats();
            updateInventory();
        }
        
        function saveGame(isAutoSave = false) {
            try {
                const saveData = {
                    inventory: gameState.inventory,
                    totalValue: gameState.totalValue,
                    money: gameState.money,
                    totalSpins: gameState.totalSpins,
                    luckMultiplier: gameState.luckMultiplier,
                    tradeWins: gameState.tradeWins,
                    tradeLosses: gameState.tradeLosses,
                    battlePassXP: gameState.battlePassXP,
                    achievements: gameState.achievements,
                    upgrades: gameState.upgrades,
                    rebirths: gameState.rebirths,
                    permanentLuckBoost: gameState.permanentLuckBoost,
                    settings: gameState.settings,
                    craftCount: gameState.craftCount,
                    enchantSuccess: gameState.enchantSuccess,
                    enchantFails: gameState.enchantFails,
                    adminUnlocked: gameState.adminUnlocked,
                    saveDate: new Date().toISOString()
                };
                
                localStorage.setItem('rngTraderSave', JSON.stringify(saveData));
                
                // Only show notification if it's a manual save OR if auto-save notifications are enabled
                if (!isAutoSave || gameState.settings.showAutoSaveNotifications) {
                    showNotification('Game saved successfully!', 'var(--success)');
                }
            } catch (error) {
                showNotification('Failed to save game!', 'var(--danger)');
                console.error('Save error:', error);
            }
        }
        
        function loadGame() {
            try {
                const saveData = localStorage.getItem('rngTraderSave');
                
                if (!saveData) {
                    showNotification('No save file found!', 'var(--warning)');
                    return;
                }
                
                if (!confirm('Loading will overwrite current progress. Continue?')) {
                    return;
                }
                
                const data = JSON.parse(saveData);
                
                // Load all saved data
                gameState.inventory = data.inventory || {};
                gameState.totalValue = data.totalValue || 0;
                gameState.money = data.money || 0;
                gameState.totalSpins = data.totalSpins || 0;
                gameState.luckMultiplier = data.luckMultiplier || 1.0;
                gameState.tradeWins = data.tradeWins || 0;
                gameState.tradeLosses = data.tradeLosses || 0;
                gameState.battlePassXP = data.battlePassXP || 0;
                gameState.achievements = data.achievements || {};
                gameState.upgrades = data.upgrades || {
                    spinSpeed: 0,
                    popularity: 0,
                    luckBoost: 0,
                    autoSpin: 0,
                    tradeInsight: 0,
                    valueBoost: 0,
                    craftingMastery: 0,
                    enchantPower: 0,
                    multiSpin: 0,
                    shopDiscount: 0,
                    rarityBoost: 0
                };
                // Ensure new upgrades exist in old saves
                if (gameState.upgrades.valueBoost === undefined) gameState.upgrades.valueBoost = 0;
                if (gameState.upgrades.craftingMastery === undefined) gameState.upgrades.craftingMastery = 0;
                if (gameState.upgrades.enchantPower === undefined) gameState.upgrades.enchantPower = 0;
                if (gameState.upgrades.multiSpin === undefined) gameState.upgrades.multiSpin = 0;
                if (gameState.upgrades.shopDiscount === undefined) gameState.upgrades.shopDiscount = 0;
                if (gameState.upgrades.rarityBoost === undefined) gameState.upgrades.rarityBoost = 0;
                if (gameState.upgrades.eventLuck === undefined) gameState.upgrades.eventLuck = 0;
                if (gameState.upgrades.xpBoost === undefined) gameState.upgrades.xpBoost = 0;
                if (gameState.upgrades.sellPrice === undefined) gameState.upgrades.sellPrice = 0;
                if (gameState.upgrades.questSpeed === undefined) gameState.upgrades.questSpeed = 0;
                if (gameState.upgrades.mysteryBox === undefined) gameState.upgrades.mysteryBox = 0;
                gameState.rebirths = data.rebirths || 0;
                gameState.permanentLuckBoost = data.permanentLuckBoost || 1.0;
                gameState.settings = data.settings || {
                    showTradeNotifications: true,
                    showExpiredNotifications: true,
                    showSpinResults: true,
                    showAchievementNotifications: true,
                    showRandomEvents: true,
                    showAutoSaveNotifications: false
                };
                // Ensure new setting exists in old saves
                if (gameState.settings.showAutoSaveNotifications === undefined) {
                    gameState.settings.showAutoSaveNotifications = false;
                }
                gameState.craftCount = data.craftCount || 0;
                gameState.enchantSuccess = data.enchantSuccess || 0;
                gameState.enchantFails = data.enchantFails || 0;
                gameState.adminUnlocked = data.adminUnlocked || false;
                gameState.questsCompleted = data.questsCompleted || 0;
                gameState.dailyStreak = data.dailyStreak || 0;
                gameState.weeklyQuestsCompleted = data.weeklyQuestsCompleted || 0;
                gameState.shopPurchases = data.shopPurchases || 0;
                gameState.activeQuests = data.activeQuests || [];
                gameState.completedQuests = data.completedQuests || [];
                gameState.lastQuestRefresh = data.lastQuestRefresh || 0;
                gameState.claimedBPTiers = data.claimedBPTiers || [];
                
                // Update all displays
                updateStats();
                updateInventory();
                updateBattlePass();
                updateRebirthDisplay();
                refreshQuests();
                updateQuestDisplay();
                checkAchievements();
                
                const saveDate = data.saveDate ? new Date(data.saveDate) : 'Unknown';
                showNotification(`Game loaded! (Saved: ${saveDate})`, 'var(--success)');
            } catch (error) {
                showNotification('Failed to load game!', 'var(--danger)');
                console.error('Load error:', error);
            }
        }
        
        // ===== ADMIN FUNCTIONS =====
        
        function adminAddMoney(amount) {
            gameState.money += amount;
            updateStats();
            showNotification(`Admin: Added $${formatNumber(amount)}!`, 'var(--accent-gold)');
        }
        
        function adminSpawnItem() {
            const rarityIndex = parseInt(document.getElementById('adminRaritySelect').value);
            const count = parseInt(document.getElementById('adminItemCount').value) || 1;
            const rarity = rarities[rarityIndex];
            
            for (let i = 0; i < count; i++) {
                const itemName = generateItemName(rarity);
                addItemToInventory(itemName, rarity);
            }
            
            updateInventory();
            showNotification(`Admin: Spawned ${count}x ${rarity.name} item(s)!`, rarity.color);
        }
        
        function adminSetLuck(multiplier) {
            gameState.luckMultiplier = multiplier;
            updateStats();
            showNotification(`Admin: Luck set to ${multiplier}x`, 'var(--accent-primary)');
        }
        
        function adminMaxUpgrades() {
            for (const key in gameState.upgrades) {
                gameState.upgrades[key] = upgradeData[key].maxLevel;
            }
            // Apply effects
            gameState.luckMultiplier = 1.0 + (upgradeData.luckBoost.maxLevel * 0.1);
            updateStats();
            initUpgrades();
            showNotification('Admin: All upgrades maxed!', 'var(--success)');
        }
        
        function adminAddBPXP(amount) {
            gameState.battlePassXP += amount;
            updateBattlePass();
            showNotification(`Admin: Added ${formatNumber(amount)} BP XP`, 'var(--accent-primary)');
        }
        
        function adminMaxBP() {
            gameState.battlePassXP = battlePassTiers[battlePassTiers.length - 1].xpRequired;
            updateBattlePass();
            showNotification('Admin: Battle Pass maxed!', 'var(--accent-gold)');
        }
        
        function adminToggleChristmas() {
            gameState.christmasEvent = !gameState.christmasEvent;
            if (gameState.christmasEvent) {
                gameState.christmasEventEnd = new Date(Date.now() + 5 * 60000);
            } else {
                gameState.christmasEventEnd = null;
            }
            updateEventBonuses();
            showNotification(`Admin: Christmas Event ${gameState.christmasEvent ? 'Activated' : 'Deactivated'}!`, '#ff0000');
        }
        
        function adminSpawnTrade() {
            generateNPCTrade();
            showNotification('Admin: Spawned trade!', 'var(--accent-primary)');
        }
        
        function adminStartWeatherEvent(eventType) {
            startWeatherEvent(eventType);
            showNotification(`Admin: Started ${eventType} event!`, '#00aaff');
        }
        
        function adminClearInventory() {
            if (!confirm('Clear entire inventory?')) return;
            gameState.inventory = {};
            gameState.totalValue = 0;
            gameState.flexedItem = null;
            updateStats();
            updateInventory();
            showNotification('Admin: Inventory cleared!', 'var(--warning)');
        }
        
        function adminDuplicateInventory() {
            let duplicatedItems = 0;
            for (const [key, item] of Object.entries(gameState.inventory)) {
                if (item.count > 0) {
                    const originalCount = item.count;
                    item.count *= 2;
                    gameState.totalValue += item.value * originalCount;
                    duplicatedItems += originalCount;
                }
            }
            updateStats();
            updateInventory();
            showNotification(`Admin: Duplicated ${duplicatedItems} items!`, 'var(--success)');
        }
        
        function adminUnlockAllAchievements() {
            achievements.forEach(achievement => {
                if (!gameState.achievements[achievement.id]) {
                    gameState.achievements[achievement.id] = true;
                }
            });
            checkAchievements();
            showNotification('Admin: All achievements unlocked!', 'var(--accent-gold)');
        }
        
        function adminResetAchievements() {
            if (!confirm('Reset all achievements?')) return;
            gameState.achievements = {};
            checkAchievements();
            showNotification('Admin: Achievements reset!', 'var(--warning)');
        }
        
        function adminSetSpins(amount) {
            gameState.totalSpins = amount;
            updateStats();
            checkAchievements();
            showNotification(`Admin: Set spins to ${formatNumber(amount)}!`, 'var(--accent-primary)');
        }
        
        function adminAddRebirths(amount) {
            gameState.rebirths += amount;
            gameState.permanentLuckBoost += (amount * 2.0);
            updateStats();
            updateRebirthDisplay();
            showNotification(`Admin: Added ${amount} rebirth(s)!`, 'var(--accent-gold)');
        }
        
        function adminSetTradeWins(amount) {
            gameState.tradeWins = amount;
            updateStats();
            checkAchievements();
            showNotification(`Admin: Set trade wins to ${formatNumber(amount)}!`, 'var(--accent-primary)');
        }
        
        function adminCompleteEverything() {
            if (!confirm('This will max out upgrades, battle pass, money, and unlock achievements. Continue?')) return;
            
            // Max upgrades
            for (const key in gameState.upgrades) {
                gameState.upgrades[key] = upgradeData[key].maxLevel;
            }
            gameState.luckMultiplier = 1.0 + (upgradeData.luckBoost.maxLevel * 0.1);
            
            // Max battle pass
            gameState.battlePassXP = battlePassTiers[battlePassTiers.length - 1].xpRequired;
            
            // Add money
            gameState.money += 100000000;
            
            // Unlock achievements
            achievements.forEach(achievement => {
                gameState.achievements[achievement.id] = true;
            });
            
            updateStats();
            updateBattlePass();
            initUpgrades();
            checkAchievements();
            
            showNotification('Admin: Everything completed!', 'var(--accent-gold)');
        }
        
        function adminResetGame() {
            if (confirm('Are you SURE you want to reset all progress? This cannot be undone!')) {
                if (confirm('Last chance! Reset everything?')) {
                    localStorage.removeItem('rngTraderSave');
                    location.reload();
                }
            }
        }
        
        function updateEventBonuses() {
            const bonusesDiv = document.getElementById('eventBonuses');
            let activeEvents = [];
            
            if (gameState.christmasEvent) {
                const timeLeft = gameState.christmasEventEnd ? Math.max(0, Math.floor((gameState.christmasEventEnd - new Date()) / 1000)) : 300;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                activeEvents.push(`
                    <div class="stat-card">
                        <div class="stat-label">üéÑ Holiday Luck</div>
                        <div class="stat-value" style="color: var(--success);">+15% Holiday Items</div>
                        <div class="stat-label" style="margin-top: 5px;">Time: ${minutes}:${seconds.toString().padStart(2, '0')}</div>
                    </div>
                `);
            }
            
            if (gameState.specialEvent) {
                const timeLeft = Math.max(0, Math.floor((gameState.specialEventEnd - Date.now()) / 1000));
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                const eventNames = { 
                    disco: 'ü™© Disco', 
                    galactic: 'üåå Galactic', 
                    glitch: '‚ö° Glitch', 
                    fullmoon: 'üåï Full Moon', 
                    bloodmoon: 'üî¥ Blood Moon' 
                };
                const eventColors = {
                    disco: '#ff00ff',
                    galactic: '#4B0082',
                    glitch: '#00ff00',
                    fullmoon: '#f0f0f0',
                    bloodmoon: '#8B0000'
                };
                activeEvents.push(`
                    <div class="stat-card">
                        <div class="stat-label">${eventNames[gameState.specialEvent]} Event</div>
                        <div class="stat-value" style="color: ${eventColors[gameState.specialEvent]};">Special Items! 40%</div>
                        <div class="stat-label" style="margin-top: 5px;">Time: ${minutes}:${seconds.toString().padStart(2, '0')}</div>
                    </div>
                `);
            }
            
            if (gameState.weatherEvent) {
                const timeLeft = Math.max(0, Math.floor((gameState.weatherEventEnd - Date.now()) / 1000));
                const eventNames = { cloudy: '‚òÅÔ∏è Cloudy', rainy: 'üåßÔ∏è Rainy', storming: '‚õàÔ∏è Storming' };
                activeEvents.push(`
                    <div class="stat-card">
                        <div class="stat-label">${eventNames[gameState.weatherEvent]} Event</div>
                        <div class="stat-value" style="color: var(--accent-primary);">Weather Items! 30%</div>
                        <div class="stat-label" style="margin-top: 5px;">Time: ${timeLeft}s</div>
                    </div>
                `);
            }
            
            if (activeEvents.length > 0) {
                bonusesDiv.innerHTML = activeEvents.join('');
            } else {
                const now = new Date();
                const currentMinute = now.getMinutes();
                const currentHour = now.getHours();
                
                // Calculate next event
                let nextEventText = '';
                if (currentMinute < 15) {
                    nextEventText = `ü™© Disco in ${15 - currentMinute} min`;
                } else if (currentMinute < 20) {
                    nextEventText = `üåï Full Moon in ${20 - currentMinute} min`;
                } else if (currentMinute < 30) {
                    nextEventText = `üåå Galactic in ${30 - currentMinute} min`;
                } else if (currentMinute < 45) {
                    nextEventText = `‚ö° Glitch in ${45 - currentMinute} min`;
                } else if (currentMinute < 50) {
                    nextEventText = `üî¥ Blood Moon in ${50 - currentMinute} min`;
                } else {
                    nextEventText = `üéÑ Christmas in ${60 - currentMinute} min`;
                }
                
                bonusesDiv.innerHTML = `
                    <p style="color: var(--text-secondary);">No active event bonuses</p>
                    <p style="color: var(--accent-gold); margin-top: 10px; font-weight: bold;">Next: ${nextEventText}</p>
                    <p style="color: var(--text-secondary); margin-top: 5px; font-size: 0.9rem;">Weather events happen randomly</p>
                `;
            }
        }
        
        function triggerRandomEvent() {
            const events = [
                { name: 'Lucky Streak!', effect: () => { gameState.luckMultiplier += 0.2; }, message: 'Luck increased by 0.2x!' },
                { name: 'Mysterious Trader', effect: () => { gameState.money += 5000; }, message: 'A mysterious trader gave you $5,000!' },
                { name: 'Item Duplication', effect: () => {
                    const keys = Object.keys(gameState.inventory).filter(k => gameState.inventory[k].count > 0);
                    if (keys.length > 0) {
                        const key = keys[Math.floor(Math.random() * keys.length)];
                        gameState.inventory[key].count++;
                        gameState.totalValue += gameState.inventory[key].value;
                    }
                }, message: 'A random item was duplicated!' }
            ];
            
            const event = events[Math.floor(Math.random() * events.length)];
            event.effect();
            showNotification(`üéâ ${event.name}: ${event.message}`, 'var(--accent-gold)');
            updateStats();
            updateInventory();
        }
        
        function showNotification(message, color) {
            // Check settings before showing certain notifications
            if (message.includes('wants to trade') && !gameState.settings.showTradeNotifications) return;
            if (message.includes('expired') && !gameState.settings.showExpiredNotifications) return;
            if (message.includes('You got:') && !gameState.settings.showSpinResults) return;
            if (message.includes('Achievement') && !gameState.settings.showAchievementNotifications) return;
            if (message.includes('Random Event') && !gameState.settings.showRandomEvents) return;
            
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.style.borderColor = color;
            notification.innerHTML = `<strong style="color: ${color};">${message}</strong>`;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideInRight 0.5s ease-out reverse';
                setTimeout(() => notification.remove(), 500);
            }, 3000);
        }
        
        function unlockAdmin() {
            const password = document.getElementById('adminPasswordInput').value;
            if (password === ADMIN_PASSWORD) {
                gameState.adminUnlocked = true;
                document.getElementById('adminLogin').style.display = 'none';
                document.getElementById('adminPanel').style.display = 'block';
                showNotification('Admin panel unlocked!', 'var(--success)');
            } else {
                showNotification('Incorrect password!', 'var(--danger)');
                document.getElementById('adminPasswordInput').value = '';
            }
        }
        
        function updateSettings() {
            gameState.settings.showTradeNotifications = document.getElementById('settingTradeNotif').checked;
            gameState.settings.showExpiredNotifications = document.getElementById('settingExpiredNotif').checked;
            gameState.settings.showSpinResults = document.getElementById('settingSpinNotif').checked;
            gameState.settings.showAchievementNotifications = document.getElementById('settingAchievementNotif').checked;
            gameState.settings.showRandomEvents = document.getElementById('settingEventNotif').checked;
            gameState.settings.showAutoSaveNotifications = document.getElementById('settingAutoSaveNotif').checked;
            showNotification('Settings saved!', 'var(--success)');
        }
        
        function updateRebirthDisplay() {
            const rebirthLevel = gameState.rebirths || 0;
            document.getElementById('rebirthCount').textContent = rebirthLevel;
            document.getElementById('permanentLuck').textContent = gameState.permanentLuckBoost.toFixed(1) + 'x';
            
            // Show next rebirth requirements
            const moneyRequired = Math.floor(1000000 * Math.pow(2, Math.min(rebirthLevel, 20)));
            let requiredRarityIndex = 5 + Math.floor(rebirthLevel / 5);
            requiredRarityIndex = Math.min(requiredRarityIndex, rarities.length - 1);
            const requiredRarity = rarities[requiredRarityIndex];
            
            // Calculate next rebirth bonus
            let luckBonus = 2.0;
            if (rebirthLevel >= 10) luckBonus += 1.0;
            if (rebirthLevel >= 25) luckBonus += 2.0;
            if (rebirthLevel >= 50) luckBonus += 5.0;
            
            const reqDisplay = document.getElementById('rebirthRequirements');
            if (reqDisplay) {
                reqDisplay.innerHTML = `
                    <p style="color: var(--accent-gold);">Next Rebirth Requirements:</p>
                    <p style="color: var(--text-secondary);">üí∞ Money: $${formatNumber(moneyRequired)}</p>
                    <p style="color: ${requiredRarity.color};">‚ú® Item: ${requiredRarity.name}+ rarity</p>
                    <p style="color: var(--success);">üéÅ Reward: +${luckBonus}x permanent luck</p>
                `;
            }
        }
        
        function performRebirth() {
            // Calculate rebirth requirements based on current rebirth count
            const rebirthLevel = gameState.rebirths || 0;
            
            // Scaling money requirement
            const moneyRequired = Math.floor(1000000 * Math.pow(2, Math.min(rebirthLevel, 20))); // Caps at 2^20 multiplier
            
            // Scaling rarity requirement
            let requiredRarityIndex = 5 + Math.floor(rebirthLevel / 5); // Mythic at 0, increases every 5 rebirths
            requiredRarityIndex = Math.min(requiredRarityIndex, rarities.length - 1);
            const requiredRarity = rarities[requiredRarityIndex];
            
            // Check money requirement
            if (gameState.money < moneyRequired) {
                showNotification(`Need $${formatNumber(moneyRequired)} to rebirth!`, 'var(--danger)');
                return;
            }
            
            // Check for required rarity item
            const hasRequiredRarity = Object.keys(gameState.inventory).some(key => {
                const item = gameState.inventory[key];
                if (item.count === 0) return false;
                const rarityIndex = rarities.findIndex(r => r.name === item.rarity);
                return rarityIndex >= requiredRarityIndex;
            });
            
            if (!hasRequiredRarity) {
                showNotification(`Need at least 1 ${requiredRarity.name} (or higher) item to rebirth!`, 'var(--danger)');
                return;
            }
            
            // Confirm rebirth
            if (!confirm(`Rebirth #${rebirthLevel + 1}\n\nCost: $${formatNumber(moneyRequired)}\nRequired: ${requiredRarity.name}+ item\n\nYou will lose ALL progress except achievements!\n\nContinue?`)) {
                return;
            }
            
            // Calculate rebirth rewards
            let luckBonus = 2.0; // Base luck bonus
            
            // Scaling bonuses for higher rebirths
            if (rebirthLevel >= 10) luckBonus += 1.0;
            if (rebirthLevel >= 25) luckBonus += 2.0;
            if (rebirthLevel >= 50) luckBonus += 5.0;
            
            // Perform rebirth
            gameState.rebirths++;
            gameState.permanentLuckBoost += luckBonus;
            
            // Reset everything except achievements, rebirths, and permanent luck
            const savedAchievements = { ...gameState.achievements };
            const savedRebirths = gameState.rebirths;
            const savedPermanentLuck = gameState.permanentLuckBoost;
            const savedSettings = { ...gameState.settings };
            const savedAdminUnlocked = gameState.adminUnlocked;
            const savedQuestsCompleted = gameState.questsCompleted || 0;
            const savedDailyStreak = gameState.dailyStreak || 0;
            const savedWeeklyQuestsCompleted = gameState.weeklyQuestsCompleted || 0;
            
            // Clear inventory
            gameState.inventory = {};
            gameState.totalValue = 0;
            gameState.money = 0;
            gameState.totalSpins = 0;
            gameState.luckMultiplier = 1.0; // Start fresh at 1.0, permanent luck applies separately
            gameState.tradeWins = 0;
            gameState.tradeLosses = 0;
            gameState.flexedItem = null;
            gameState.battlePassTier = 0;
            gameState.battlePassXP = 0;
            gameState.claimedBPTiers = [];
            gameState.enchantmentTarget = null;
            gameState.activeTrades = [];
            gameState.activeQuests = [];
            gameState.completedQuests = [];
            gameState.lastQuestRefresh = 0;
            gameState.shopPurchases = 0;
            gameState.upgrades = {
                spinSpeed: 0,
                popularity: 0,
                luckBoost: 0,
                autoSpin: 0,
                tradeInsight: 0,
                valueBoost: 0,
                craftingMastery: 0,
                enchantPower: 0,
                multiSpin: 0,
                shopDiscount: 0,
                rarityBoost: 0,
                eventLuck: 0,
                xpBoost: 0,
                sellPrice: 0,
                questSpeed: 0,
                mysteryBox: 0
            };
            gameState.craftCount = 0;
            gameState.enchantSuccess = 0;
            gameState.enchantFails = 0;
            
            // Restore what shouldn't be reset
            gameState.achievements = savedAchievements;
            gameState.rebirths = savedRebirths;
            gameState.permanentLuckBoost = savedPermanentLuck;
            gameState.settings = savedSettings;
            gameState.adminUnlocked = savedAdminUnlocked;
            gameState.questsCompleted = savedQuestsCompleted;
            gameState.dailyStreak = savedDailyStreak;
            gameState.weeklyQuestsCompleted = savedWeeklyQuestsCompleted;
            
            // Refresh quests
            refreshQuests();
            
            // Update all displays
            updateStats();
            updateInventory();
            updateBattlePass();
            updateRebirthDisplay();
            updateQuestDisplay();
            checkAchievements();
            
            showNotification(`üéâ REBIRTH #${gameState.rebirths} COMPLETE! Permanent luck is now ${gameState.permanentLuckBoost.toFixed(1)}x! (+${luckBonus}x this rebirth) üéâ`, 'var(--accent-gold)');
        }
        
        function initBattlePass() {
            const tiersDiv = document.getElementById('bpTiers');
            tiersDiv.innerHTML = '';
            
            battlePassTiers.forEach(tier => {
                const unlocked = gameState.battlePassXP >= tier.xpRequired;
                
                const tierDiv = document.createElement('div');
                tierDiv.className = 'battlepass-tier' + (unlocked ? ' unlocked' : '');
                tierDiv.innerHTML = `
                    <div>
                        <h3 style="color: var(--accent-primary);">Tier ${tier.tier}</h3>
                        <p style="color: var(--text-secondary);">${formatNumber(tier.xpRequired)} XP Required</p>
                        <p style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 5px;">Current: ${formatNumber(gameState.battlePassXP)} XP</p>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 1.5rem;">${unlocked ? '‚úÖ' : 'üîí'}</div>
                        <div style="color: var(--accent-gold); font-weight: bold;">${tier.reward}</div>
                    </div>
                `;
                tiersDiv.appendChild(tierDiv);
            });
        }
        
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            if (tabName === 'inventory') updateInventory();
            if (tabName === 'shop') initShop();
            if (tabName === 'upgrades') initUpgrades();
            if (tabName === 'trading') {
                // Trading tab is now automatically populated
            }
            if (tabName === 'crafting') {
                document.getElementById('craftingGrid').innerHTML = '';
                initCrafting();
            }
            if (tabName === 'enchanting') {
                updateEnchantInventory();
            }
            if (tabName === 'quests') {
                updateQuestDisplay();
            }
            if (tabName === 'settings') {
                // Load current settings
                document.getElementById('settingTradeNotif').checked = gameState.settings.showTradeNotifications;
                document.getElementById('settingExpiredNotif').checked = gameState.settings.showExpiredNotifications;
                document.getElementById('settingSpinNotif').checked = gameState.settings.showSpinResults;
                document.getElementById('settingAchievementNotif').checked = gameState.settings.showAchievementNotifications;
                document.getElementById('settingEventNotif').checked = gameState.settings.showRandomEvents;
                document.getElementById('settingAutoSaveNotif').checked = gameState.settings.showAutoSaveNotifications;
            }
            if (tabName === 'rebirth') {
                updateRebirthDisplay();
            }
            if (tabName === 'admin') {
                if (gameState.adminUnlocked) {
                    document.getElementById('adminLogin').style.display = 'none';
                    document.getElementById('adminPanel').style.display = 'block';
                } else {
                    document.getElementById('adminLogin').style.display = 'block';
                    document.getElementById('adminPanel').style.display = 'none';
                }
            }
        }
        
        // Initialize game
        // Try to auto-load save file on startup
        const hasSaveFile = localStorage.getItem('rngTraderSave');
        if (hasSaveFile) {
            try {
                const data = JSON.parse(hasSaveFile);
                gameState.inventory = data.inventory || {};
                gameState.totalValue = data.totalValue || 0;
                gameState.money = data.money || 0;
                gameState.totalSpins = data.totalSpins || 0;
                gameState.luckMultiplier = data.luckMultiplier || 1.0;
                gameState.tradeWins = data.tradeWins || 0;
                gameState.tradeLosses = data.tradeLosses || 0;
                gameState.battlePassXP = data.battlePassXP || 0;
                gameState.achievements = data.achievements || {};
                gameState.upgrades = data.upgrades || {
                    spinSpeed: 0,
                    popularity: 0,
                    luckBoost: 0,
                    autoSpin: 0,
                    tradeInsight: 0,
                    valueBoost: 0,
                    craftingMastery: 0,
                    enchantPower: 0,
                    multiSpin: 0,
                    shopDiscount: 0,
                    rarityBoost: 0
                };
                // Ensure new upgrades exist in old saves
                if (gameState.upgrades.valueBoost === undefined) gameState.upgrades.valueBoost = 0;
                if (gameState.upgrades.craftingMastery === undefined) gameState.upgrades.craftingMastery = 0;
                if (gameState.upgrades.enchantPower === undefined) gameState.upgrades.enchantPower = 0;
                if (gameState.upgrades.multiSpin === undefined) gameState.upgrades.multiSpin = 0;
                if (gameState.upgrades.shopDiscount === undefined) gameState.upgrades.shopDiscount = 0;
                if (gameState.upgrades.rarityBoost === undefined) gameState.upgrades.rarityBoost = 0;
                if (gameState.upgrades.eventLuck === undefined) gameState.upgrades.eventLuck = 0;
                if (gameState.upgrades.xpBoost === undefined) gameState.upgrades.xpBoost = 0;
                if (gameState.upgrades.sellPrice === undefined) gameState.upgrades.sellPrice = 0;
                if (gameState.upgrades.questSpeed === undefined) gameState.upgrades.questSpeed = 0;
                if (gameState.upgrades.mysteryBox === undefined) gameState.upgrades.mysteryBox = 0;
                
                gameState.rebirths = data.rebirths || 0;
                gameState.permanentLuckBoost = data.permanentLuckBoost || 1.0;
                gameState.settings = data.settings || {
                    showTradeNotifications: true,
                    showExpiredNotifications: true,
                    showSpinResults: true,
                    showAchievementNotifications: true,
                    showRandomEvents: true,
                    showAutoSaveNotifications: false
                };
                // Ensure new setting exists in old saves
                if (gameState.settings.showAutoSaveNotifications === undefined) {
                    gameState.settings.showAutoSaveNotifications = false;
                }
                gameState.craftCount = data.craftCount || 0;
                gameState.enchantSuccess = data.enchantSuccess || 0;
                gameState.enchantFails = data.enchantFails || 0;
                gameState.adminUnlocked = data.adminUnlocked || false;
                gameState.questsCompleted = data.questsCompleted || 0;
                gameState.dailyStreak = data.dailyStreak || 0;
                gameState.weeklyQuestsCompleted = data.weeklyQuestsCompleted || 0;
                gameState.shopPurchases = data.shopPurchases || 0;
                gameState.activeQuests = data.activeQuests || [];
                gameState.completedQuests = data.completedQuests || [];
                gameState.lastQuestRefresh = data.lastQuestRefresh || 0;
                gameState.claimedBPTiers = data.claimedBPTiers || [];
            } catch (error) {
                console.error('Auto-load failed:', error);
            }
        }
        
        updateStats();
        initAchievements();
        initBattlePass();
        updateEventBonuses();
        startAutoTrading();
        updateRebirthDisplay();
        refreshQuests();
        updateQuestDisplay();
        
        // Start auto-spin if unlocked
        if (gameState.upgrades.autoSpin > 0) {
            startAutoSpin();
        }
        
        // Check for Christmas events every minute
        setInterval(checkChristmasEvent, 60000);
        checkChristmasEvent();
        
        // Check for Weather events every 30 seconds
        setInterval(checkWeatherEvents, 30000);
        checkWeatherEvents();
        
        // Check for Special events every 30 seconds
        setInterval(checkSpecialEvents, 30000);
        checkSpecialEvents();
        
        // Update event timers every second
        setInterval(() => {
            if (gameState.christmasEvent || gameState.weatherEvent) {
                updateEventBonuses();
            }
        }, 1000);
        
        // Check for quest refresh every minute
        setInterval(() => {
            refreshQuests();
        }, 60000);
        
        // Auto-save every 30 seconds
        setInterval(() => {
            saveGame(true); // Pass true to indicate auto-save
        }, 30000);
    </script>
</body>
</html>